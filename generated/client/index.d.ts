
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserStatusHistory
 * 
 */
export type UserStatusHistory = $Result.DefaultSelection<Prisma.$UserStatusHistoryPayload>
/**
 * Model CandidateNote
 * 
 */
export type CandidateNote = $Result.DefaultSelection<Prisma.$CandidateNotePayload>
/**
 * Model JobListing
 * 
 */
export type JobListing = $Result.DefaultSelection<Prisma.$JobListingPayload>
/**
 * Model Candidate
 * 
 */
export type Candidate = $Result.DefaultSelection<Prisma.$CandidatePayload>
/**
 * Model JobApplication
 * 
 */
export type JobApplication = $Result.DefaultSelection<Prisma.$JobApplicationPayload>
/**
 * Model CvAnalysis
 * 
 */
export type CvAnalysis = $Result.DefaultSelection<Prisma.$CvAnalysisPayload>
/**
 * Model JobApplicationHistory
 * 
 */
export type JobApplicationHistory = $Result.DefaultSelection<Prisma.$JobApplicationHistoryPayload>
/**
 * Model PersonalInfo
 * 
 */
export type PersonalInfo = $Result.DefaultSelection<Prisma.$PersonalInfoPayload>
/**
 * Model IdentificationDocument
 * 
 */
export type IdentificationDocument = $Result.DefaultSelection<Prisma.$IdentificationDocumentPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentVerification
 * 
 */
export type DocumentVerification = $Result.DefaultSelection<Prisma.$DocumentVerificationPayload>
/**
 * Model OnboardingProgress
 * 
 */
export type OnboardingProgress = $Result.DefaultSelection<Prisma.$OnboardingProgressPayload>
/**
 * Model OnboardingInvitation
 * 
 */
export type OnboardingInvitation = $Result.DefaultSelection<Prisma.$OnboardingInvitationPayload>
/**
 * Model EmergencyContact
 * 
 */
export type EmergencyContact = $Result.DefaultSelection<Prisma.$EmergencyContactPayload>
/**
 * Model DependentMember
 * 
 */
export type DependentMember = $Result.DefaultSelection<Prisma.$DependentMemberPayload>
/**
 * Model UserEmail
 * 
 */
export type UserEmail = $Result.DefaultSelection<Prisma.$UserEmailPayload>
/**
 * Model UserPhone
 * 
 */
export type UserPhone = $Result.DefaultSelection<Prisma.$UserPhonePayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model LanguageSkill
 * 
 */
export type LanguageSkill = $Result.DefaultSelection<Prisma.$LanguageSkillPayload>
/**
 * Model Request
 * 
 */
export type Request = $Result.DefaultSelection<Prisma.$RequestPayload>
/**
 * Model RequestStatusHistory
 * 
 */
export type RequestStatusHistory = $Result.DefaultSelection<Prisma.$RequestStatusHistoryPayload>
/**
 * Model StatusAttachment
 * 
 */
export type StatusAttachment = $Result.DefaultSelection<Prisma.$StatusAttachmentPayload>
/**
 * Model RequestAttachment
 * 
 */
export type RequestAttachment = $Result.DefaultSelection<Prisma.$RequestAttachmentPayload>
/**
 * Model LeaveRequest
 * 
 */
export type LeaveRequest = $Result.DefaultSelection<Prisma.$LeaveRequestPayload>
/**
 * Model LeaveAttachment
 * 
 */
export type LeaveAttachment = $Result.DefaultSelection<Prisma.$LeaveAttachmentPayload>
/**
 * Model LeaveStatusHistory
 * 
 */
export type LeaveStatusHistory = $Result.DefaultSelection<Prisma.$LeaveStatusHistoryPayload>
/**
 * Model LeaveStatusAttachment
 * 
 */
export type LeaveStatusAttachment = $Result.DefaultSelection<Prisma.$LeaveStatusAttachmentPayload>
/**
 * Model Holiday
 * 
 */
export type Holiday = $Result.DefaultSelection<Prisma.$HolidayPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Position
 * 
 */
export type Position = $Result.DefaultSelection<Prisma.$PositionPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model TimeEntry
 * 
 */
export type TimeEntry = $Result.DefaultSelection<Prisma.$TimeEntryPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model TimeSchedule
 * 
 */
export type TimeSchedule = $Result.DefaultSelection<Prisma.$TimeSchedulePayload>
/**
 * Model ShiftEntry
 * 
 */
export type ShiftEntry = $Result.DefaultSelection<Prisma.$ShiftEntryPayload>
/**
 * Model CompanySettings
 * 
 */
export type CompanySettings = $Result.DefaultSelection<Prisma.$CompanySettingsPayload>
/**
 * Model CareerSettings
 * 
 */
export type CareerSettings = $Result.DefaultSelection<Prisma.$CareerSettingsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const EmploymentType: {
  FULL_TIME: 'FULL_TIME',
  PART_TIME: 'PART_TIME',
  CONTRACT: 'CONTRACT',
  TEMPORARY: 'TEMPORARY',
  OTHER: 'OTHER',
  VOLUNTEER: 'VOLUNTEER',
  INTERNSHIP: 'INTERNSHIP'
};

export type EmploymentType = (typeof EmploymentType)[keyof typeof EmploymentType]


export const WorkplaceType: {
  ON_SITE: 'ON_SITE',
  HYBRID: 'HYBRID',
  REMOTE: 'REMOTE'
};

export type WorkplaceType = (typeof WorkplaceType)[keyof typeof WorkplaceType]


export const JobStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  EXPIRED: 'EXPIRED'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const ApplicationStatus: {
  PENDING: 'PENDING',
  REVIEW: 'REVIEW',
  INTERVIEWING: 'INTERVIEWING',
  OFFERED: 'OFFERED',
  ONBOARDING: 'ONBOARDING',
  HIRED: 'HIRED',
  REJECTED: 'REJECTED'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const UserRole: {
  ONBOARDING_EMPLOYEE: 'ONBOARDING_EMPLOYEE',
  EMPLOYEE: 'EMPLOYEE',
  HR: 'HR',
  EXTERNAL_ACCOUNTANT: 'EXTERNAL_ACCOUNTANT',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  PENDING: 'PENDING'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const DocumentType: {
  AMKA: 'AMKA',
  AFM: 'AFM',
  ID_CARD: 'ID_CARD',
  PASSPORT: 'PASSPORT',
  RESIDENCE_PERMIT: 'RESIDENCE_PERMIT',
  MILITARY_DOC: 'MILITARY_DOC',
  DEGREE: 'DEGREE',
  BANK_ACCOUNT: 'BANK_ACCOUNT',
  STUDENT_CERTIFICATE: 'STUDENT_CERTIFICATE',
  FAMILY_STATUS: 'FAMILY_STATUS',
  INSURANCE_RECORD: 'INSURANCE_RECORD',
  INSURANCE_REGISTRATION_CERT: 'INSURANCE_REGISTRATION_CERT',
  TAX_REGISTRY_CERT: 'TAX_REGISTRY_CERT',
  LANGUAGE_CERTIFICATE: 'LANGUAGE_CERTIFICATE',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const VerificationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  NEEDS_REVISION: 'NEEDS_REVISION'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const OnboardingStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED'
};

export type OnboardingStatus = (typeof OnboardingStatus)[keyof typeof OnboardingStatus]


export const Phase: {
  PERSONAL_INFO: 'PERSONAL_INFO',
  IDENTITY_DOCS: 'IDENTITY_DOCS',
  EMPLOYMENT_DOCS: 'EMPLOYMENT_DOCS',
  BANK_INFO: 'BANK_INFO',
  COMPLETED: 'COMPLETED'
};

export type Phase = (typeof Phase)[keyof typeof Phase]


export const MaritalStatus: {
  SINGLE: 'SINGLE',
  MARRIED: 'MARRIED',
  DIVORCED: 'DIVORCED',
  WIDOWED: 'WIDOWED',
  CIVIL_PARTNERSHIP: 'CIVIL_PARTNERSHIP'
};

export type MaritalStatus = (typeof MaritalStatus)[keyof typeof MaritalStatus]


export const AddressType: {
  PERMANENT: 'PERMANENT',
  TEMPORARY: 'TEMPORARY',
  WORK: 'WORK',
  POSTAL: 'POSTAL',
  FAMILY: 'FAMILY',
  OTHER: 'OTHER'
};

export type AddressType = (typeof AddressType)[keyof typeof AddressType]


export const EmailType: {
  PERSONAL: 'PERSONAL',
  WORK: 'WORK',
  OTHER: 'OTHER'
};

export type EmailType = (typeof EmailType)[keyof typeof EmailType]


export const PhoneType: {
  PERSONAL: 'PERSONAL',
  WORK: 'WORK',
  HOME: 'HOME',
  OTHER: 'OTHER'
};

export type PhoneType = (typeof PhoneType)[keyof typeof PhoneType]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const IdentificationDocumentType: {
  ID_CARD: 'ID_CARD',
  PASSPORT: 'PASSPORT',
  RESIDENCE_PERMIT: 'RESIDENCE_PERMIT'
};

export type IdentificationDocumentType = (typeof IdentificationDocumentType)[keyof typeof IdentificationDocumentType]


export const EducationLevel: {
  PRIMARY: 'PRIMARY',
  SECONDARY: 'SECONDARY',
  POST_SECONDARY: 'POST_SECONDARY',
  BACHELOR: 'BACHELOR',
  MASTER: 'MASTER',
  PHD: 'PHD'
};

export type EducationLevel = (typeof EducationLevel)[keyof typeof EducationLevel]


export const GreekBank: {
  NATIONAL_BANK: 'NATIONAL_BANK',
  ALPHA_BANK: 'ALPHA_BANK',
  PIRAEUS_BANK: 'PIRAEUS_BANK',
  EUROBANK: 'EUROBANK',
  ATTICA_BANK: 'ATTICA_BANK',
  OPTIMA_BANK: 'OPTIMA_BANK',
  PANCRETA_BANK: 'PANCRETA_BANK',
  OTHER: 'OTHER'
};

export type GreekBank = (typeof GreekBank)[keyof typeof GreekBank]


export const ContractStatus: {
  PENDING: 'PENDING',
  UPLOADED: 'UPLOADED',
  SIGNED: 'SIGNED',
  REJECTED: 'REJECTED'
};

export type ContractStatus = (typeof ContractStatus)[keyof typeof ContractStatus]


export const Language: {
  ENGLISH: 'ENGLISH',
  FRENCH: 'FRENCH',
  GERMAN: 'GERMAN',
  SPANISH: 'SPANISH',
  ITALIAN: 'ITALIAN',
  RUSSIAN: 'RUSSIAN',
  CHINESE: 'CHINESE',
  ARABIC: 'ARABIC',
  TURKISH: 'TURKISH',
  BULGARIAN: 'BULGARIAN',
  ROMANIAN: 'ROMANIAN',
  ALBANIAN: 'ALBANIAN',
  OTHER: 'OTHER'
};

export type Language = (typeof Language)[keyof typeof Language]


export const Proficiency: {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
  NATIVE: 'NATIVE'
};

export type Proficiency = (typeof Proficiency)[keyof typeof Proficiency]


export const RequestStatus: {
  PENDING: 'PENDING',
  IN_REVIEW: 'IN_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const RequestPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type RequestPriority = (typeof RequestPriority)[keyof typeof RequestPriority]


export const LeaveType: {
  ANNUAL: 'ANNUAL',
  UNPAID: 'UNPAID',
  SICK: 'SICK',
  EXAM: 'EXAM',
  POSTGRADUATE_EXAM: 'POSTGRADUATE_EXAM',
  BLOOD_DONATION: 'BLOOD_DONATION',
  MARRIAGE: 'MARRIAGE',
  BEREAVEMENT: 'BEREAVEMENT',
  MATERNITY: 'MATERNITY',
  SPECIAL_MATERNITY: 'SPECIAL_MATERNITY',
  PATERNITY: 'PATERNITY',
  CHILD_CARE: 'CHILD_CARE',
  PARENTAL: 'PARENTAL',
  CAREGIVER: 'CAREGIVER',
  FORCE_MAJEURE: 'FORCE_MAJEURE',
  FLEXIBLE_WORK: 'FLEXIBLE_WORK',
  IVF: 'IVF',
  PRENATAL_CHECKUP: 'PRENATAL_CHECKUP',
  CHILD_ILLNESS: 'CHILD_ILLNESS',
  CHILD_HOSPITAL: 'CHILD_HOSPITAL',
  SCHOOL_VISIT: 'SCHOOL_VISIT',
  DEPENDENT_CARE: 'DEPENDENT_CARE',
  SINGLE_PARENT: 'SINGLE_PARENT',
  DISABLED_CHILD: 'DISABLED_CHILD',
  NIGHT_WORK_EXEMPT: 'NIGHT_WORK_EXEMPT',
  BEREAVED_PARENT: 'BEREAVED_PARENT',
  GYNECOLOGICAL_EXAM: 'GYNECOLOGICAL_EXAM',
  OTHER: 'OTHER'
};

export type LeaveType = (typeof LeaveType)[keyof typeof LeaveType]


export const LeaveStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const ClientStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ARCHIVED: 'ARCHIVED'
};

export type ClientStatus = (typeof ClientStatus)[keyof typeof ClientStatus]


export const ProjectStatus: {
  ACTIVE: 'ACTIVE',
  ON_HOLD: 'ON_HOLD',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  ARCHIVED: 'ARCHIVED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const ProjectMemberRole: {
  MANAGER: 'MANAGER',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER'
};

export type ProjectMemberRole = (typeof ProjectMemberRole)[keyof typeof ProjectMemberRole]


export const TimeEntryStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type TimeEntryStatus = (typeof TimeEntryStatus)[keyof typeof TimeEntryStatus]


export const ShiftStatus: {
  SCHEDULED: 'SCHEDULED',
  COMPLETED: 'COMPLETED',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  ON_LEAVE: 'ON_LEAVE'
};

export type ShiftStatus = (typeof ShiftStatus)[keyof typeof ShiftStatus]

}

export type EmploymentType = $Enums.EmploymentType

export const EmploymentType: typeof $Enums.EmploymentType

export type WorkplaceType = $Enums.WorkplaceType

export const WorkplaceType: typeof $Enums.WorkplaceType

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type OnboardingStatus = $Enums.OnboardingStatus

export const OnboardingStatus: typeof $Enums.OnboardingStatus

export type Phase = $Enums.Phase

export const Phase: typeof $Enums.Phase

export type MaritalStatus = $Enums.MaritalStatus

export const MaritalStatus: typeof $Enums.MaritalStatus

export type AddressType = $Enums.AddressType

export const AddressType: typeof $Enums.AddressType

export type EmailType = $Enums.EmailType

export const EmailType: typeof $Enums.EmailType

export type PhoneType = $Enums.PhoneType

export const PhoneType: typeof $Enums.PhoneType

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type IdentificationDocumentType = $Enums.IdentificationDocumentType

export const IdentificationDocumentType: typeof $Enums.IdentificationDocumentType

export type EducationLevel = $Enums.EducationLevel

export const EducationLevel: typeof $Enums.EducationLevel

export type GreekBank = $Enums.GreekBank

export const GreekBank: typeof $Enums.GreekBank

export type ContractStatus = $Enums.ContractStatus

export const ContractStatus: typeof $Enums.ContractStatus

export type Language = $Enums.Language

export const Language: typeof $Enums.Language

export type Proficiency = $Enums.Proficiency

export const Proficiency: typeof $Enums.Proficiency

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type RequestPriority = $Enums.RequestPriority

export const RequestPriority: typeof $Enums.RequestPriority

export type LeaveType = $Enums.LeaveType

export const LeaveType: typeof $Enums.LeaveType

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type ClientStatus = $Enums.ClientStatus

export const ClientStatus: typeof $Enums.ClientStatus

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type ProjectMemberRole = $Enums.ProjectMemberRole

export const ProjectMemberRole: typeof $Enums.ProjectMemberRole

export type TimeEntryStatus = $Enums.TimeEntryStatus

export const TimeEntryStatus: typeof $Enums.TimeEntryStatus

export type ShiftStatus = $Enums.ShiftStatus

export const ShiftStatus: typeof $Enums.ShiftStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userStatusHistory`: Exposes CRUD operations for the **UserStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStatusHistories
    * const userStatusHistories = await prisma.userStatusHistory.findMany()
    * ```
    */
  get userStatusHistory(): Prisma.UserStatusHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.candidateNote`: Exposes CRUD operations for the **CandidateNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CandidateNotes
    * const candidateNotes = await prisma.candidateNote.findMany()
    * ```
    */
  get candidateNote(): Prisma.CandidateNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobListing`: Exposes CRUD operations for the **JobListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobListings
    * const jobListings = await prisma.jobListing.findMany()
    * ```
    */
  get jobListing(): Prisma.JobListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.candidate`: Exposes CRUD operations for the **Candidate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Candidates
    * const candidates = await prisma.candidate.findMany()
    * ```
    */
  get candidate(): Prisma.CandidateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobApplication`: Exposes CRUD operations for the **JobApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobApplications
    * const jobApplications = await prisma.jobApplication.findMany()
    * ```
    */
  get jobApplication(): Prisma.JobApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cvAnalysis`: Exposes CRUD operations for the **CvAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CvAnalyses
    * const cvAnalyses = await prisma.cvAnalysis.findMany()
    * ```
    */
  get cvAnalysis(): Prisma.CvAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobApplicationHistory`: Exposes CRUD operations for the **JobApplicationHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobApplicationHistories
    * const jobApplicationHistories = await prisma.jobApplicationHistory.findMany()
    * ```
    */
  get jobApplicationHistory(): Prisma.JobApplicationHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personalInfo`: Exposes CRUD operations for the **PersonalInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalInfos
    * const personalInfos = await prisma.personalInfo.findMany()
    * ```
    */
  get personalInfo(): Prisma.PersonalInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.identificationDocument`: Exposes CRUD operations for the **IdentificationDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IdentificationDocuments
    * const identificationDocuments = await prisma.identificationDocument.findMany()
    * ```
    */
  get identificationDocument(): Prisma.IdentificationDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentVerification`: Exposes CRUD operations for the **DocumentVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentVerifications
    * const documentVerifications = await prisma.documentVerification.findMany()
    * ```
    */
  get documentVerification(): Prisma.DocumentVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.onboardingProgress`: Exposes CRUD operations for the **OnboardingProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnboardingProgresses
    * const onboardingProgresses = await prisma.onboardingProgress.findMany()
    * ```
    */
  get onboardingProgress(): Prisma.OnboardingProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.onboardingInvitation`: Exposes CRUD operations for the **OnboardingInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnboardingInvitations
    * const onboardingInvitations = await prisma.onboardingInvitation.findMany()
    * ```
    */
  get onboardingInvitation(): Prisma.OnboardingInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergencyContact`: Exposes CRUD operations for the **EmergencyContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmergencyContacts
    * const emergencyContacts = await prisma.emergencyContact.findMany()
    * ```
    */
  get emergencyContact(): Prisma.EmergencyContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dependentMember`: Exposes CRUD operations for the **DependentMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DependentMembers
    * const dependentMembers = await prisma.dependentMember.findMany()
    * ```
    */
  get dependentMember(): Prisma.DependentMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userEmail`: Exposes CRUD operations for the **UserEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserEmails
    * const userEmails = await prisma.userEmail.findMany()
    * ```
    */
  get userEmail(): Prisma.UserEmailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPhone`: Exposes CRUD operations for the **UserPhone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPhones
    * const userPhones = await prisma.userPhone.findMany()
    * ```
    */
  get userPhone(): Prisma.UserPhoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.languageSkill`: Exposes CRUD operations for the **LanguageSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LanguageSkills
    * const languageSkills = await prisma.languageSkill.findMany()
    * ```
    */
  get languageSkill(): Prisma.LanguageSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.request`: Exposes CRUD operations for the **Request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requests
    * const requests = await prisma.request.findMany()
    * ```
    */
  get request(): Prisma.RequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestStatusHistory`: Exposes CRUD operations for the **RequestStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestStatusHistories
    * const requestStatusHistories = await prisma.requestStatusHistory.findMany()
    * ```
    */
  get requestStatusHistory(): Prisma.RequestStatusHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statusAttachment`: Exposes CRUD operations for the **StatusAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusAttachments
    * const statusAttachments = await prisma.statusAttachment.findMany()
    * ```
    */
  get statusAttachment(): Prisma.StatusAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestAttachment`: Exposes CRUD operations for the **RequestAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestAttachments
    * const requestAttachments = await prisma.requestAttachment.findMany()
    * ```
    */
  get requestAttachment(): Prisma.RequestAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveRequest`: Exposes CRUD operations for the **LeaveRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveRequests
    * const leaveRequests = await prisma.leaveRequest.findMany()
    * ```
    */
  get leaveRequest(): Prisma.LeaveRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveAttachment`: Exposes CRUD operations for the **LeaveAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveAttachments
    * const leaveAttachments = await prisma.leaveAttachment.findMany()
    * ```
    */
  get leaveAttachment(): Prisma.LeaveAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveStatusHistory`: Exposes CRUD operations for the **LeaveStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveStatusHistories
    * const leaveStatusHistories = await prisma.leaveStatusHistory.findMany()
    * ```
    */
  get leaveStatusHistory(): Prisma.LeaveStatusHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveStatusAttachment`: Exposes CRUD operations for the **LeaveStatusAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveStatusAttachments
    * const leaveStatusAttachments = await prisma.leaveStatusAttachment.findMany()
    * ```
    */
  get leaveStatusAttachment(): Prisma.LeaveStatusAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.holiday`: Exposes CRUD operations for the **Holiday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holidays
    * const holidays = await prisma.holiday.findMany()
    * ```
    */
  get holiday(): Prisma.HolidayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeEntry`: Exposes CRUD operations for the **TimeEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeEntries
    * const timeEntries = await prisma.timeEntry.findMany()
    * ```
    */
  get timeEntry(): Prisma.TimeEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeSchedule`: Exposes CRUD operations for the **TimeSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSchedules
    * const timeSchedules = await prisma.timeSchedule.findMany()
    * ```
    */
  get timeSchedule(): Prisma.TimeScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shiftEntry`: Exposes CRUD operations for the **ShiftEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftEntries
    * const shiftEntries = await prisma.shiftEntry.findMany()
    * ```
    */
  get shiftEntry(): Prisma.ShiftEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companySettings`: Exposes CRUD operations for the **CompanySettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanySettings
    * const companySettings = await prisma.companySettings.findMany()
    * ```
    */
  get companySettings(): Prisma.CompanySettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.careerSettings`: Exposes CRUD operations for the **CareerSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CareerSettings
    * const careerSettings = await prisma.careerSettings.findMany()
    * ```
    */
  get careerSettings(): Prisma.CareerSettingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    User: 'User',
    UserStatusHistory: 'UserStatusHistory',
    CandidateNote: 'CandidateNote',
    JobListing: 'JobListing',
    Candidate: 'Candidate',
    JobApplication: 'JobApplication',
    CvAnalysis: 'CvAnalysis',
    JobApplicationHistory: 'JobApplicationHistory',
    PersonalInfo: 'PersonalInfo',
    IdentificationDocument: 'IdentificationDocument',
    Address: 'Address',
    Document: 'Document',
    DocumentVerification: 'DocumentVerification',
    OnboardingProgress: 'OnboardingProgress',
    OnboardingInvitation: 'OnboardingInvitation',
    EmergencyContact: 'EmergencyContact',
    DependentMember: 'DependentMember',
    UserEmail: 'UserEmail',
    UserPhone: 'UserPhone',
    BankAccount: 'BankAccount',
    Contract: 'Contract',
    LanguageSkill: 'LanguageSkill',
    Request: 'Request',
    RequestStatusHistory: 'RequestStatusHistory',
    StatusAttachment: 'StatusAttachment',
    RequestAttachment: 'RequestAttachment',
    LeaveRequest: 'LeaveRequest',
    LeaveAttachment: 'LeaveAttachment',
    LeaveStatusHistory: 'LeaveStatusHistory',
    LeaveStatusAttachment: 'LeaveStatusAttachment',
    Holiday: 'Holiday',
    Department: 'Department',
    Location: 'Location',
    Position: 'Position',
    Client: 'Client',
    Project: 'Project',
    ProjectMember: 'ProjectMember',
    TimeEntry: 'TimeEntry',
    Announcement: 'Announcement',
    TimeSchedule: 'TimeSchedule',
    ShiftEntry: 'ShiftEntry',
    CompanySettings: 'CompanySettings',
    CareerSettings: 'CareerSettings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "session" | "verificationToken" | "user" | "userStatusHistory" | "candidateNote" | "jobListing" | "candidate" | "jobApplication" | "cvAnalysis" | "jobApplicationHistory" | "personalInfo" | "identificationDocument" | "address" | "document" | "documentVerification" | "onboardingProgress" | "onboardingInvitation" | "emergencyContact" | "dependentMember" | "userEmail" | "userPhone" | "bankAccount" | "contract" | "languageSkill" | "request" | "requestStatusHistory" | "statusAttachment" | "requestAttachment" | "leaveRequest" | "leaveAttachment" | "leaveStatusHistory" | "leaveStatusAttachment" | "holiday" | "department" | "location" | "position" | "client" | "project" | "projectMember" | "timeEntry" | "announcement" | "timeSchedule" | "shiftEntry" | "companySettings" | "careerSettings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserStatusHistory: {
        payload: Prisma.$UserStatusHistoryPayload<ExtArgs>
        fields: Prisma.UserStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.UserStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.UserStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.UserStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.UserStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserStatusHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload>[]
          }
          delete: {
            args: Prisma.UserStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload>
          }
          update: {
            args: Prisma.UserStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UserStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserStatusHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload>[]
          }
          upsert: {
            args: Prisma.UserStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStatusHistory>
          }
          groupBy: {
            args: Prisma.UserStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      CandidateNote: {
        payload: Prisma.$CandidateNotePayload<ExtArgs>
        fields: Prisma.CandidateNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandidateNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandidateNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload>
          }
          findFirst: {
            args: Prisma.CandidateNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandidateNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload>
          }
          findMany: {
            args: Prisma.CandidateNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload>[]
          }
          create: {
            args: Prisma.CandidateNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload>
          }
          createMany: {
            args: Prisma.CandidateNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CandidateNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload>[]
          }
          delete: {
            args: Prisma.CandidateNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload>
          }
          update: {
            args: Prisma.CandidateNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload>
          }
          deleteMany: {
            args: Prisma.CandidateNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CandidateNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CandidateNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload>[]
          }
          upsert: {
            args: Prisma.CandidateNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateNotePayload>
          }
          aggregate: {
            args: Prisma.CandidateNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCandidateNote>
          }
          groupBy: {
            args: Prisma.CandidateNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CandidateNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CandidateNoteCountArgs<ExtArgs>
            result: $Utils.Optional<CandidateNoteCountAggregateOutputType> | number
          }
        }
      }
      JobListing: {
        payload: Prisma.$JobListingPayload<ExtArgs>
        fields: Prisma.JobListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          findFirst: {
            args: Prisma.JobListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          findMany: {
            args: Prisma.JobListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>[]
          }
          create: {
            args: Prisma.JobListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          createMany: {
            args: Prisma.JobListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>[]
          }
          delete: {
            args: Prisma.JobListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          update: {
            args: Prisma.JobListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          deleteMany: {
            args: Prisma.JobListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>[]
          }
          upsert: {
            args: Prisma.JobListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobListingPayload>
          }
          aggregate: {
            args: Prisma.JobListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobListing>
          }
          groupBy: {
            args: Prisma.JobListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobListingCountArgs<ExtArgs>
            result: $Utils.Optional<JobListingCountAggregateOutputType> | number
          }
        }
      }
      Candidate: {
        payload: Prisma.$CandidatePayload<ExtArgs>
        fields: Prisma.CandidateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandidateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandidateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          findFirst: {
            args: Prisma.CandidateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandidateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          findMany: {
            args: Prisma.CandidateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>[]
          }
          create: {
            args: Prisma.CandidateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          createMany: {
            args: Prisma.CandidateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CandidateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>[]
          }
          delete: {
            args: Prisma.CandidateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          update: {
            args: Prisma.CandidateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          deleteMany: {
            args: Prisma.CandidateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CandidateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CandidateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>[]
          }
          upsert: {
            args: Prisma.CandidateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatePayload>
          }
          aggregate: {
            args: Prisma.CandidateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCandidate>
          }
          groupBy: {
            args: Prisma.CandidateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CandidateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CandidateCountArgs<ExtArgs>
            result: $Utils.Optional<CandidateCountAggregateOutputType> | number
          }
        }
      }
      JobApplication: {
        payload: Prisma.$JobApplicationPayload<ExtArgs>
        fields: Prisma.JobApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          findFirst: {
            args: Prisma.JobApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          findMany: {
            args: Prisma.JobApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          create: {
            args: Prisma.JobApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          createMany: {
            args: Prisma.JobApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          delete: {
            args: Prisma.JobApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          update: {
            args: Prisma.JobApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          deleteMany: {
            args: Prisma.JobApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          upsert: {
            args: Prisma.JobApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          aggregate: {
            args: Prisma.JobApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobApplication>
          }
          groupBy: {
            args: Prisma.JobApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<JobApplicationCountAggregateOutputType> | number
          }
        }
      }
      CvAnalysis: {
        payload: Prisma.$CvAnalysisPayload<ExtArgs>
        fields: Prisma.CvAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CvAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CvAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload>
          }
          findFirst: {
            args: Prisma.CvAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CvAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload>
          }
          findMany: {
            args: Prisma.CvAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload>[]
          }
          create: {
            args: Prisma.CvAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload>
          }
          createMany: {
            args: Prisma.CvAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CvAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload>[]
          }
          delete: {
            args: Prisma.CvAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload>
          }
          update: {
            args: Prisma.CvAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.CvAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CvAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CvAnalysisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload>[]
          }
          upsert: {
            args: Prisma.CvAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CvAnalysisPayload>
          }
          aggregate: {
            args: Prisma.CvAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCvAnalysis>
          }
          groupBy: {
            args: Prisma.CvAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<CvAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.CvAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<CvAnalysisCountAggregateOutputType> | number
          }
        }
      }
      JobApplicationHistory: {
        payload: Prisma.$JobApplicationHistoryPayload<ExtArgs>
        fields: Prisma.JobApplicationHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobApplicationHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobApplicationHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload>
          }
          findFirst: {
            args: Prisma.JobApplicationHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobApplicationHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload>
          }
          findMany: {
            args: Prisma.JobApplicationHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload>[]
          }
          create: {
            args: Prisma.JobApplicationHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload>
          }
          createMany: {
            args: Prisma.JobApplicationHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobApplicationHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload>[]
          }
          delete: {
            args: Prisma.JobApplicationHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload>
          }
          update: {
            args: Prisma.JobApplicationHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload>
          }
          deleteMany: {
            args: Prisma.JobApplicationHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobApplicationHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobApplicationHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload>[]
          }
          upsert: {
            args: Prisma.JobApplicationHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationHistoryPayload>
          }
          aggregate: {
            args: Prisma.JobApplicationHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobApplicationHistory>
          }
          groupBy: {
            args: Prisma.JobApplicationHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobApplicationHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobApplicationHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<JobApplicationHistoryCountAggregateOutputType> | number
          }
        }
      }
      PersonalInfo: {
        payload: Prisma.$PersonalInfoPayload<ExtArgs>
        fields: Prisma.PersonalInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload>
          }
          findFirst: {
            args: Prisma.PersonalInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload>
          }
          findMany: {
            args: Prisma.PersonalInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload>[]
          }
          create: {
            args: Prisma.PersonalInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload>
          }
          createMany: {
            args: Prisma.PersonalInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload>[]
          }
          delete: {
            args: Prisma.PersonalInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload>
          }
          update: {
            args: Prisma.PersonalInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload>
          }
          deleteMany: {
            args: Prisma.PersonalInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonalInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload>[]
          }
          upsert: {
            args: Prisma.PersonalInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalInfoPayload>
          }
          aggregate: {
            args: Prisma.PersonalInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalInfo>
          }
          groupBy: {
            args: Prisma.PersonalInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalInfoCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalInfoCountAggregateOutputType> | number
          }
        }
      }
      IdentificationDocument: {
        payload: Prisma.$IdentificationDocumentPayload<ExtArgs>
        fields: Prisma.IdentificationDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdentificationDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdentificationDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload>
          }
          findFirst: {
            args: Prisma.IdentificationDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdentificationDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload>
          }
          findMany: {
            args: Prisma.IdentificationDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload>[]
          }
          create: {
            args: Prisma.IdentificationDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload>
          }
          createMany: {
            args: Prisma.IdentificationDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdentificationDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload>[]
          }
          delete: {
            args: Prisma.IdentificationDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload>
          }
          update: {
            args: Prisma.IdentificationDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload>
          }
          deleteMany: {
            args: Prisma.IdentificationDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdentificationDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdentificationDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload>[]
          }
          upsert: {
            args: Prisma.IdentificationDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentificationDocumentPayload>
          }
          aggregate: {
            args: Prisma.IdentificationDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdentificationDocument>
          }
          groupBy: {
            args: Prisma.IdentificationDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdentificationDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdentificationDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<IdentificationDocumentCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentVerification: {
        payload: Prisma.$DocumentVerificationPayload<ExtArgs>
        fields: Prisma.DocumentVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload>
          }
          findFirst: {
            args: Prisma.DocumentVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload>
          }
          findMany: {
            args: Prisma.DocumentVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload>[]
          }
          create: {
            args: Prisma.DocumentVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload>
          }
          createMany: {
            args: Prisma.DocumentVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload>[]
          }
          delete: {
            args: Prisma.DocumentVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload>
          }
          update: {
            args: Prisma.DocumentVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload>
          }
          deleteMany: {
            args: Prisma.DocumentVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload>[]
          }
          upsert: {
            args: Prisma.DocumentVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVerificationPayload>
          }
          aggregate: {
            args: Prisma.DocumentVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentVerification>
          }
          groupBy: {
            args: Prisma.DocumentVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentVerificationCountAggregateOutputType> | number
          }
        }
      }
      OnboardingProgress: {
        payload: Prisma.$OnboardingProgressPayload<ExtArgs>
        fields: Prisma.OnboardingProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnboardingProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnboardingProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          findFirst: {
            args: Prisma.OnboardingProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnboardingProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          findMany: {
            args: Prisma.OnboardingProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>[]
          }
          create: {
            args: Prisma.OnboardingProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          createMany: {
            args: Prisma.OnboardingProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnboardingProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>[]
          }
          delete: {
            args: Prisma.OnboardingProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          update: {
            args: Prisma.OnboardingProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          deleteMany: {
            args: Prisma.OnboardingProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnboardingProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OnboardingProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>[]
          }
          upsert: {
            args: Prisma.OnboardingProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          aggregate: {
            args: Prisma.OnboardingProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnboardingProgress>
          }
          groupBy: {
            args: Prisma.OnboardingProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnboardingProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnboardingProgressCountArgs<ExtArgs>
            result: $Utils.Optional<OnboardingProgressCountAggregateOutputType> | number
          }
        }
      }
      OnboardingInvitation: {
        payload: Prisma.$OnboardingInvitationPayload<ExtArgs>
        fields: Prisma.OnboardingInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnboardingInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnboardingInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload>
          }
          findFirst: {
            args: Prisma.OnboardingInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnboardingInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload>
          }
          findMany: {
            args: Prisma.OnboardingInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload>[]
          }
          create: {
            args: Prisma.OnboardingInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload>
          }
          createMany: {
            args: Prisma.OnboardingInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnboardingInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload>[]
          }
          delete: {
            args: Prisma.OnboardingInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload>
          }
          update: {
            args: Prisma.OnboardingInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload>
          }
          deleteMany: {
            args: Prisma.OnboardingInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnboardingInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OnboardingInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload>[]
          }
          upsert: {
            args: Prisma.OnboardingInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingInvitationPayload>
          }
          aggregate: {
            args: Prisma.OnboardingInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnboardingInvitation>
          }
          groupBy: {
            args: Prisma.OnboardingInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnboardingInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnboardingInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<OnboardingInvitationCountAggregateOutputType> | number
          }
        }
      }
      EmergencyContact: {
        payload: Prisma.$EmergencyContactPayload<ExtArgs>
        fields: Prisma.EmergencyContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findFirst: {
            args: Prisma.EmergencyContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          findMany: {
            args: Prisma.EmergencyContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          create: {
            args: Prisma.EmergencyContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          createMany: {
            args: Prisma.EmergencyContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmergencyContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          delete: {
            args: Prisma.EmergencyContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          update: {
            args: Prisma.EmergencyContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmergencyContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>[]
          }
          upsert: {
            args: Prisma.EmergencyContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyContactPayload>
          }
          aggregate: {
            args: Prisma.EmergencyContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergencyContact>
          }
          groupBy: {
            args: Prisma.EmergencyContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyContactCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyContactCountAggregateOutputType> | number
          }
        }
      }
      DependentMember: {
        payload: Prisma.$DependentMemberPayload<ExtArgs>
        fields: Prisma.DependentMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DependentMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DependentMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload>
          }
          findFirst: {
            args: Prisma.DependentMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DependentMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload>
          }
          findMany: {
            args: Prisma.DependentMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload>[]
          }
          create: {
            args: Prisma.DependentMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload>
          }
          createMany: {
            args: Prisma.DependentMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DependentMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload>[]
          }
          delete: {
            args: Prisma.DependentMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload>
          }
          update: {
            args: Prisma.DependentMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload>
          }
          deleteMany: {
            args: Prisma.DependentMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DependentMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DependentMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload>[]
          }
          upsert: {
            args: Prisma.DependentMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependentMemberPayload>
          }
          aggregate: {
            args: Prisma.DependentMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDependentMember>
          }
          groupBy: {
            args: Prisma.DependentMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<DependentMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.DependentMemberCountArgs<ExtArgs>
            result: $Utils.Optional<DependentMemberCountAggregateOutputType> | number
          }
        }
      }
      UserEmail: {
        payload: Prisma.$UserEmailPayload<ExtArgs>
        fields: Prisma.UserEmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserEmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserEmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          findFirst: {
            args: Prisma.UserEmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserEmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          findMany: {
            args: Prisma.UserEmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>[]
          }
          create: {
            args: Prisma.UserEmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          createMany: {
            args: Prisma.UserEmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserEmailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>[]
          }
          delete: {
            args: Prisma.UserEmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          update: {
            args: Prisma.UserEmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          deleteMany: {
            args: Prisma.UserEmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserEmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserEmailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>[]
          }
          upsert: {
            args: Prisma.UserEmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          aggregate: {
            args: Prisma.UserEmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserEmail>
          }
          groupBy: {
            args: Prisma.UserEmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserEmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserEmailCountArgs<ExtArgs>
            result: $Utils.Optional<UserEmailCountAggregateOutputType> | number
          }
        }
      }
      UserPhone: {
        payload: Prisma.$UserPhonePayload<ExtArgs>
        fields: Prisma.UserPhoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPhoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPhoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          findFirst: {
            args: Prisma.UserPhoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPhoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          findMany: {
            args: Prisma.UserPhoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>[]
          }
          create: {
            args: Prisma.UserPhoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          createMany: {
            args: Prisma.UserPhoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPhoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>[]
          }
          delete: {
            args: Prisma.UserPhoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          update: {
            args: Prisma.UserPhoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          deleteMany: {
            args: Prisma.UserPhoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPhoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPhoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>[]
          }
          upsert: {
            args: Prisma.UserPhoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          aggregate: {
            args: Prisma.UserPhoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPhone>
          }
          groupBy: {
            args: Prisma.UserPhoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPhoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPhoneCountArgs<ExtArgs>
            result: $Utils.Optional<UserPhoneCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      LanguageSkill: {
        payload: Prisma.$LanguageSkillPayload<ExtArgs>
        fields: Prisma.LanguageSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload>
          }
          findFirst: {
            args: Prisma.LanguageSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload>
          }
          findMany: {
            args: Prisma.LanguageSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload>[]
          }
          create: {
            args: Prisma.LanguageSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload>
          }
          createMany: {
            args: Prisma.LanguageSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload>[]
          }
          delete: {
            args: Prisma.LanguageSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload>
          }
          update: {
            args: Prisma.LanguageSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload>
          }
          deleteMany: {
            args: Prisma.LanguageSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload>[]
          }
          upsert: {
            args: Prisma.LanguageSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSkillPayload>
          }
          aggregate: {
            args: Prisma.LanguageSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguageSkill>
          }
          groupBy: {
            args: Prisma.LanguageSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageSkillCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageSkillCountAggregateOutputType> | number
          }
        }
      }
      Request: {
        payload: Prisma.$RequestPayload<ExtArgs>
        fields: Prisma.RequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          findFirst: {
            args: Prisma.RequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          findMany: {
            args: Prisma.RequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          create: {
            args: Prisma.RequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          createMany: {
            args: Prisma.RequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          delete: {
            args: Prisma.RequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          update: {
            args: Prisma.RequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          deleteMany: {
            args: Prisma.RequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          upsert: {
            args: Prisma.RequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          aggregate: {
            args: Prisma.RequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequest>
          }
          groupBy: {
            args: Prisma.RequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestCountArgs<ExtArgs>
            result: $Utils.Optional<RequestCountAggregateOutputType> | number
          }
        }
      }
      RequestStatusHistory: {
        payload: Prisma.$RequestStatusHistoryPayload<ExtArgs>
        fields: Prisma.RequestStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.RequestStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.RequestStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.RequestStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.RequestStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestStatusHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>[]
          }
          delete: {
            args: Prisma.RequestStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          update: {
            args: Prisma.RequestStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.RequestStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestStatusHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>[]
          }
          upsert: {
            args: Prisma.RequestStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.RequestStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestStatusHistory>
          }
          groupBy: {
            args: Prisma.RequestStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<RequestStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      StatusAttachment: {
        payload: Prisma.$StatusAttachmentPayload<ExtArgs>
        fields: Prisma.StatusAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload>
          }
          findFirst: {
            args: Prisma.StatusAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload>
          }
          findMany: {
            args: Prisma.StatusAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload>[]
          }
          create: {
            args: Prisma.StatusAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload>
          }
          createMany: {
            args: Prisma.StatusAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatusAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload>[]
          }
          delete: {
            args: Prisma.StatusAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload>
          }
          update: {
            args: Prisma.StatusAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.StatusAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatusAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StatusAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.StatusAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAttachmentPayload>
          }
          aggregate: {
            args: Prisma.StatusAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatusAttachment>
          }
          groupBy: {
            args: Prisma.StatusAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<StatusAttachmentCountAggregateOutputType> | number
          }
        }
      }
      RequestAttachment: {
        payload: Prisma.$RequestAttachmentPayload<ExtArgs>
        fields: Prisma.RequestAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
          }
          findFirst: {
            args: Prisma.RequestAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
          }
          findMany: {
            args: Prisma.RequestAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>[]
          }
          create: {
            args: Prisma.RequestAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
          }
          createMany: {
            args: Prisma.RequestAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>[]
          }
          delete: {
            args: Prisma.RequestAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
          }
          update: {
            args: Prisma.RequestAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.RequestAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.RequestAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestAttachmentPayload>
          }
          aggregate: {
            args: Prisma.RequestAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestAttachment>
          }
          groupBy: {
            args: Prisma.RequestAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<RequestAttachmentCountAggregateOutputType> | number
          }
        }
      }
      LeaveRequest: {
        payload: Prisma.$LeaveRequestPayload<ExtArgs>
        fields: Prisma.LeaveRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findFirst: {
            args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findMany: {
            args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          create: {
            args: Prisma.LeaveRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          createMany: {
            args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          delete: {
            args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          update: {
            args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          deleteMany: {
            args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          upsert: {
            args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          aggregate: {
            args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveRequest>
          }
          groupBy: {
            args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveRequestCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestCountAggregateOutputType> | number
          }
        }
      }
      LeaveAttachment: {
        payload: Prisma.$LeaveAttachmentPayload<ExtArgs>
        fields: Prisma.LeaveAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload>
          }
          findFirst: {
            args: Prisma.LeaveAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload>
          }
          findMany: {
            args: Prisma.LeaveAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload>[]
          }
          create: {
            args: Prisma.LeaveAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload>
          }
          createMany: {
            args: Prisma.LeaveAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload>[]
          }
          delete: {
            args: Prisma.LeaveAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload>
          }
          update: {
            args: Prisma.LeaveAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.LeaveAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.LeaveAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveAttachmentPayload>
          }
          aggregate: {
            args: Prisma.LeaveAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveAttachment>
          }
          groupBy: {
            args: Prisma.LeaveAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveAttachmentCountAggregateOutputType> | number
          }
        }
      }
      LeaveStatusHistory: {
        payload: Prisma.$LeaveStatusHistoryPayload<ExtArgs>
        fields: Prisma.LeaveStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.LeaveStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.LeaveStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.LeaveStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.LeaveStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveStatusHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload>[]
          }
          delete: {
            args: Prisma.LeaveStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload>
          }
          update: {
            args: Prisma.LeaveStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.LeaveStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveStatusHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload>[]
          }
          upsert: {
            args: Prisma.LeaveStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.LeaveStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveStatusHistory>
          }
          groupBy: {
            args: Prisma.LeaveStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      LeaveStatusAttachment: {
        payload: Prisma.$LeaveStatusAttachmentPayload<ExtArgs>
        fields: Prisma.LeaveStatusAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveStatusAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveStatusAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload>
          }
          findFirst: {
            args: Prisma.LeaveStatusAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveStatusAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload>
          }
          findMany: {
            args: Prisma.LeaveStatusAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload>[]
          }
          create: {
            args: Prisma.LeaveStatusAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload>
          }
          createMany: {
            args: Prisma.LeaveStatusAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveStatusAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload>[]
          }
          delete: {
            args: Prisma.LeaveStatusAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload>
          }
          update: {
            args: Prisma.LeaveStatusAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.LeaveStatusAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveStatusAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveStatusAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.LeaveStatusAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveStatusAttachmentPayload>
          }
          aggregate: {
            args: Prisma.LeaveStatusAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveStatusAttachment>
          }
          groupBy: {
            args: Prisma.LeaveStatusAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveStatusAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveStatusAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveStatusAttachmentCountAggregateOutputType> | number
          }
        }
      }
      Holiday: {
        payload: Prisma.$HolidayPayload<ExtArgs>
        fields: Prisma.HolidayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HolidayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HolidayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findFirst: {
            args: Prisma.HolidayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HolidayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findMany: {
            args: Prisma.HolidayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          create: {
            args: Prisma.HolidayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          createMany: {
            args: Prisma.HolidayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HolidayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          delete: {
            args: Prisma.HolidayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          update: {
            args: Prisma.HolidayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          deleteMany: {
            args: Prisma.HolidayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HolidayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HolidayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          upsert: {
            args: Prisma.HolidayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          aggregate: {
            args: Prisma.HolidayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoliday>
          }
          groupBy: {
            args: Prisma.HolidayGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolidayGroupByOutputType>[]
          }
          count: {
            args: Prisma.HolidayCountArgs<ExtArgs>
            result: $Utils.Optional<HolidayCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Position: {
        payload: Prisma.$PositionPayload<ExtArgs>
        fields: Prisma.PositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findFirst: {
            args: Prisma.PositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findMany: {
            args: Prisma.PositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          create: {
            args: Prisma.PositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          createMany: {
            args: Prisma.PositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          delete: {
            args: Prisma.PositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          update: {
            args: Prisma.PositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          deleteMany: {
            args: Prisma.PositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          upsert: {
            args: Prisma.PositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          aggregate: {
            args: Prisma.PositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosition>
          }
          groupBy: {
            args: Prisma.PositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PositionCountArgs<ExtArgs>
            result: $Utils.Optional<PositionCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      TimeEntry: {
        payload: Prisma.$TimeEntryPayload<ExtArgs>
        fields: Prisma.TimeEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          findFirst: {
            args: Prisma.TimeEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          findMany: {
            args: Prisma.TimeEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
          }
          create: {
            args: Prisma.TimeEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          createMany: {
            args: Prisma.TimeEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
          }
          delete: {
            args: Prisma.TimeEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          update: {
            args: Prisma.TimeEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          deleteMany: {
            args: Prisma.TimeEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
          }
          upsert: {
            args: Prisma.TimeEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          aggregate: {
            args: Prisma.TimeEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeEntry>
          }
          groupBy: {
            args: Prisma.TimeEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeEntryCountArgs<ExtArgs>
            result: $Utils.Optional<TimeEntryCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      TimeSchedule: {
        payload: Prisma.$TimeSchedulePayload<ExtArgs>
        fields: Prisma.TimeScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload>
          }
          findFirst: {
            args: Prisma.TimeScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload>
          }
          findMany: {
            args: Prisma.TimeScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload>[]
          }
          create: {
            args: Prisma.TimeScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload>
          }
          createMany: {
            args: Prisma.TimeScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload>[]
          }
          delete: {
            args: Prisma.TimeScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload>
          }
          update: {
            args: Prisma.TimeScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload>
          }
          deleteMany: {
            args: Prisma.TimeScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload>[]
          }
          upsert: {
            args: Prisma.TimeScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSchedulePayload>
          }
          aggregate: {
            args: Prisma.TimeScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeSchedule>
          }
          groupBy: {
            args: Prisma.TimeScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<TimeScheduleCountAggregateOutputType> | number
          }
        }
      }
      ShiftEntry: {
        payload: Prisma.$ShiftEntryPayload<ExtArgs>
        fields: Prisma.ShiftEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload>
          }
          findFirst: {
            args: Prisma.ShiftEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload>
          }
          findMany: {
            args: Prisma.ShiftEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload>[]
          }
          create: {
            args: Prisma.ShiftEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload>
          }
          createMany: {
            args: Prisma.ShiftEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload>[]
          }
          delete: {
            args: Prisma.ShiftEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload>
          }
          update: {
            args: Prisma.ShiftEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload>
          }
          deleteMany: {
            args: Prisma.ShiftEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload>[]
          }
          upsert: {
            args: Prisma.ShiftEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftEntryPayload>
          }
          aggregate: {
            args: Prisma.ShiftEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftEntry>
          }
          groupBy: {
            args: Prisma.ShiftEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftEntryCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftEntryCountAggregateOutputType> | number
          }
        }
      }
      CompanySettings: {
        payload: Prisma.$CompanySettingsPayload<ExtArgs>
        fields: Prisma.CompanySettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanySettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanySettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          findFirst: {
            args: Prisma.CompanySettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanySettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          findMany: {
            args: Prisma.CompanySettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>[]
          }
          create: {
            args: Prisma.CompanySettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          createMany: {
            args: Prisma.CompanySettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanySettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>[]
          }
          delete: {
            args: Prisma.CompanySettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          update: {
            args: Prisma.CompanySettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          deleteMany: {
            args: Prisma.CompanySettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanySettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanySettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>[]
          }
          upsert: {
            args: Prisma.CompanySettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          aggregate: {
            args: Prisma.CompanySettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanySettings>
          }
          groupBy: {
            args: Prisma.CompanySettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanySettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanySettingsCountArgs<ExtArgs>
            result: $Utils.Optional<CompanySettingsCountAggregateOutputType> | number
          }
        }
      }
      CareerSettings: {
        payload: Prisma.$CareerSettingsPayload<ExtArgs>
        fields: Prisma.CareerSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CareerSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CareerSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload>
          }
          findFirst: {
            args: Prisma.CareerSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CareerSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload>
          }
          findMany: {
            args: Prisma.CareerSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload>[]
          }
          create: {
            args: Prisma.CareerSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload>
          }
          createMany: {
            args: Prisma.CareerSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CareerSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload>[]
          }
          delete: {
            args: Prisma.CareerSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload>
          }
          update: {
            args: Prisma.CareerSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload>
          }
          deleteMany: {
            args: Prisma.CareerSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CareerSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CareerSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload>[]
          }
          upsert: {
            args: Prisma.CareerSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerSettingsPayload>
          }
          aggregate: {
            args: Prisma.CareerSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCareerSettings>
          }
          groupBy: {
            args: Prisma.CareerSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CareerSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CareerSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<CareerSettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    user?: UserOmit
    userStatusHistory?: UserStatusHistoryOmit
    candidateNote?: CandidateNoteOmit
    jobListing?: JobListingOmit
    candidate?: CandidateOmit
    jobApplication?: JobApplicationOmit
    cvAnalysis?: CvAnalysisOmit
    jobApplicationHistory?: JobApplicationHistoryOmit
    personalInfo?: PersonalInfoOmit
    identificationDocument?: IdentificationDocumentOmit
    address?: AddressOmit
    document?: DocumentOmit
    documentVerification?: DocumentVerificationOmit
    onboardingProgress?: OnboardingProgressOmit
    onboardingInvitation?: OnboardingInvitationOmit
    emergencyContact?: EmergencyContactOmit
    dependentMember?: DependentMemberOmit
    userEmail?: UserEmailOmit
    userPhone?: UserPhoneOmit
    bankAccount?: BankAccountOmit
    contract?: ContractOmit
    languageSkill?: LanguageSkillOmit
    request?: RequestOmit
    requestStatusHistory?: RequestStatusHistoryOmit
    statusAttachment?: StatusAttachmentOmit
    requestAttachment?: RequestAttachmentOmit
    leaveRequest?: LeaveRequestOmit
    leaveAttachment?: LeaveAttachmentOmit
    leaveStatusHistory?: LeaveStatusHistoryOmit
    leaveStatusAttachment?: LeaveStatusAttachmentOmit
    holiday?: HolidayOmit
    department?: DepartmentOmit
    location?: LocationOmit
    position?: PositionOmit
    client?: ClientOmit
    project?: ProjectOmit
    projectMember?: ProjectMemberOmit
    timeEntry?: TimeEntryOmit
    announcement?: AnnouncementOmit
    timeSchedule?: TimeScheduleOmit
    shiftEntry?: ShiftEntryOmit
    companySettings?: CompanySettingsOmit
    careerSettings?: CareerSettingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    candidateNotes: number
    jobApplicationHistory: number
    accounts: number
    sessions: number
    statusHistory: number
    statusChangesBy: number
    documents: number
    documentReviews: number
    DocumentVerification: number
    emergencyContacts: number
    dependentMembers: number
    emails: number
    phones: number
    managedOnboardings: number
    employees: number
    requestsMade: number
    requestsToManage: number
    requestHistory: number
    leavesRequested: number
    leavesToApprove: number
    leaveStatusHistory: number
    managedProjects: number
    projectMemberships: number
    timeEntries: number
    shifts: number
    announcementsChanged: number
    announcementsPublished: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidateNotes?: boolean | UserCountOutputTypeCountCandidateNotesArgs
    jobApplicationHistory?: boolean | UserCountOutputTypeCountJobApplicationHistoryArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    statusHistory?: boolean | UserCountOutputTypeCountStatusHistoryArgs
    statusChangesBy?: boolean | UserCountOutputTypeCountStatusChangesByArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    documentReviews?: boolean | UserCountOutputTypeCountDocumentReviewsArgs
    DocumentVerification?: boolean | UserCountOutputTypeCountDocumentVerificationArgs
    emergencyContacts?: boolean | UserCountOutputTypeCountEmergencyContactsArgs
    dependentMembers?: boolean | UserCountOutputTypeCountDependentMembersArgs
    emails?: boolean | UserCountOutputTypeCountEmailsArgs
    phones?: boolean | UserCountOutputTypeCountPhonesArgs
    managedOnboardings?: boolean | UserCountOutputTypeCountManagedOnboardingsArgs
    employees?: boolean | UserCountOutputTypeCountEmployeesArgs
    requestsMade?: boolean | UserCountOutputTypeCountRequestsMadeArgs
    requestsToManage?: boolean | UserCountOutputTypeCountRequestsToManageArgs
    requestHistory?: boolean | UserCountOutputTypeCountRequestHistoryArgs
    leavesRequested?: boolean | UserCountOutputTypeCountLeavesRequestedArgs
    leavesToApprove?: boolean | UserCountOutputTypeCountLeavesToApproveArgs
    leaveStatusHistory?: boolean | UserCountOutputTypeCountLeaveStatusHistoryArgs
    managedProjects?: boolean | UserCountOutputTypeCountManagedProjectsArgs
    projectMemberships?: boolean | UserCountOutputTypeCountProjectMembershipsArgs
    timeEntries?: boolean | UserCountOutputTypeCountTimeEntriesArgs
    shifts?: boolean | UserCountOutputTypeCountShiftsArgs
    announcementsChanged?: boolean | UserCountOutputTypeCountAnnouncementsChangedArgs
    announcementsPublished?: boolean | UserCountOutputTypeCountAnnouncementsPublishedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCandidateNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJobApplicationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStatusHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStatusChangesByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStatusHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVerificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVerificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDependentMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DependentMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEmailWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhoneWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedOnboardingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequestsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequestsToManageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequestHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestStatusHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeavesRequestedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeavesToApproveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveStatusHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementsChangedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementsPublishedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }


  /**
   * Count Type JobListingCountOutputType
   */

  export type JobListingCountOutputType = {
    applications: number
  }

  export type JobListingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | JobListingCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * JobListingCountOutputType without action
   */
  export type JobListingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListingCountOutputType
     */
    select?: JobListingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobListingCountOutputType without action
   */
  export type JobListingCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
  }


  /**
   * Count Type CandidateCountOutputType
   */

  export type CandidateCountOutputType = {
    applications: number
    notes: number
  }

  export type CandidateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | CandidateCountOutputTypeCountApplicationsArgs
    notes?: boolean | CandidateCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * CandidateCountOutputType without action
   */
  export type CandidateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateCountOutputType
     */
    select?: CandidateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CandidateCountOutputType without action
   */
  export type CandidateCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
  }

  /**
   * CandidateCountOutputType without action
   */
  export type CandidateCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateNoteWhereInput
  }


  /**
   * Count Type JobApplicationCountOutputType
   */

  export type JobApplicationCountOutputType = {
    history: number
  }

  export type JobApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | JobApplicationCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * JobApplicationCountOutputType without action
   */
  export type JobApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationCountOutputType
     */
    select?: JobApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobApplicationCountOutputType without action
   */
  export type JobApplicationCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationHistoryWhereInput
  }


  /**
   * Count Type PersonalInfoCountOutputType
   */

  export type PersonalInfoCountOutputType = {
    identificationDocuments: number
    addresses: number
    bankAccounts: number
    languageSkills: number
  }

  export type PersonalInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    identificationDocuments?: boolean | PersonalInfoCountOutputTypeCountIdentificationDocumentsArgs
    addresses?: boolean | PersonalInfoCountOutputTypeCountAddressesArgs
    bankAccounts?: boolean | PersonalInfoCountOutputTypeCountBankAccountsArgs
    languageSkills?: boolean | PersonalInfoCountOutputTypeCountLanguageSkillsArgs
  }

  // Custom InputTypes
  /**
   * PersonalInfoCountOutputType without action
   */
  export type PersonalInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfoCountOutputType
     */
    select?: PersonalInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonalInfoCountOutputType without action
   */
  export type PersonalInfoCountOutputTypeCountIdentificationDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentificationDocumentWhereInput
  }

  /**
   * PersonalInfoCountOutputType without action
   */
  export type PersonalInfoCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * PersonalInfoCountOutputType without action
   */
  export type PersonalInfoCountOutputTypeCountBankAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
  }

  /**
   * PersonalInfoCountOutputType without action
   */
  export type PersonalInfoCountOutputTypeCountLanguageSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageSkillWhereInput
  }


  /**
   * Count Type DependentMemberCountOutputType
   */

  export type DependentMemberCountOutputType = {
    Document: number
  }

  export type DependentMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Document?: boolean | DependentMemberCountOutputTypeCountDocumentArgs
  }

  // Custom InputTypes
  /**
   * DependentMemberCountOutputType without action
   */
  export type DependentMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMemberCountOutputType
     */
    select?: DependentMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DependentMemberCountOutputType without action
   */
  export type DependentMemberCountOutputTypeCountDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type LanguageSkillCountOutputType
   */

  export type LanguageSkillCountOutputType = {
    documents: number
  }

  export type LanguageSkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | LanguageSkillCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * LanguageSkillCountOutputType without action
   */
  export type LanguageSkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkillCountOutputType
     */
    select?: LanguageSkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageSkillCountOutputType without action
   */
  export type LanguageSkillCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type RequestCountOutputType
   */

  export type RequestCountOutputType = {
    attachments: number
    RequestStatusHistory: number
  }

  export type RequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | RequestCountOutputTypeCountAttachmentsArgs
    RequestStatusHistory?: boolean | RequestCountOutputTypeCountRequestStatusHistoryArgs
  }

  // Custom InputTypes
  /**
   * RequestCountOutputType without action
   */
  export type RequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCountOutputType
     */
    select?: RequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestCountOutputType without action
   */
  export type RequestCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestAttachmentWhereInput
  }

  /**
   * RequestCountOutputType without action
   */
  export type RequestCountOutputTypeCountRequestStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestStatusHistoryWhereInput
  }


  /**
   * Count Type RequestStatusHistoryCountOutputType
   */

  export type RequestStatusHistoryCountOutputType = {
    attachments: number
  }

  export type RequestStatusHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | RequestStatusHistoryCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * RequestStatusHistoryCountOutputType without action
   */
  export type RequestStatusHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistoryCountOutputType
     */
    select?: RequestStatusHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestStatusHistoryCountOutputType without action
   */
  export type RequestStatusHistoryCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusAttachmentWhereInput
  }


  /**
   * Count Type LeaveRequestCountOutputType
   */

  export type LeaveRequestCountOutputType = {
    attachments: number
    statusHistory: number
  }

  export type LeaveRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | LeaveRequestCountOutputTypeCountAttachmentsArgs
    statusHistory?: boolean | LeaveRequestCountOutputTypeCountStatusHistoryArgs
  }

  // Custom InputTypes
  /**
   * LeaveRequestCountOutputType without action
   */
  export type LeaveRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequestCountOutputType
     */
    select?: LeaveRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaveRequestCountOutputType without action
   */
  export type LeaveRequestCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveAttachmentWhereInput
  }

  /**
   * LeaveRequestCountOutputType without action
   */
  export type LeaveRequestCountOutputTypeCountStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveStatusHistoryWhereInput
  }


  /**
   * Count Type LeaveStatusHistoryCountOutputType
   */

  export type LeaveStatusHistoryCountOutputType = {
    attachments: number
  }

  export type LeaveStatusHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | LeaveStatusHistoryCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * LeaveStatusHistoryCountOutputType without action
   */
  export type LeaveStatusHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistoryCountOutputType
     */
    select?: LeaveStatusHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaveStatusHistoryCountOutputType without action
   */
  export type LeaveStatusHistoryCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveStatusAttachmentWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    users: number
    JobListing: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | DepartmentCountOutputTypeCountUsersArgs
    JobListing?: boolean | DepartmentCountOutputTypeCountJobListingArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountJobListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobListingWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    users: number
    JobListing: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | LocationCountOutputTypeCountUsersArgs
    JobListing?: boolean | LocationCountOutputTypeCountJobListingArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountJobListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobListingWhereInput
  }


  /**
   * Count Type PositionCountOutputType
   */

  export type PositionCountOutputType = {
    users: number
    jobListings: number
  }

  export type PositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | PositionCountOutputTypeCountUsersArgs
    jobListings?: boolean | PositionCountOutputTypeCountJobListingsArgs
  }

  // Custom InputTypes
  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountJobListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobListingWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    projects: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ClientCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
    timeEntries: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    timeEntries?: boolean | ProjectCountOutputTypeCountTimeEntriesArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTimeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
  }


  /**
   * Count Type TimeScheduleCountOutputType
   */

  export type TimeScheduleCountOutputType = {
    shifts: number
  }

  export type TimeScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | TimeScheduleCountOutputTypeCountShiftsArgs
  }

  // Custom InputTypes
  /**
   * TimeScheduleCountOutputType without action
   */
  export type TimeScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeScheduleCountOutputType
     */
    select?: TimeScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TimeScheduleCountOutputType without action
   */
  export type TimeScheduleCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftEntryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    status: $Enums.UserStatus | null
    role: $Enums.UserRole | null
    employmentType: $Enums.EmploymentType | null
    jobStartDate: Date | null
    jobEndDate: Date | null
    departmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
    positionId: string | null
    locationId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    status: $Enums.UserStatus | null
    role: $Enums.UserRole | null
    employmentType: $Enums.EmploymentType | null
    jobStartDate: Date | null
    jobEndDate: Date | null
    departmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    managerId: string | null
    positionId: string | null
    locationId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    firstName: number
    lastName: number
    email: number
    emailVerified: number
    image: number
    password: number
    status: number
    role: number
    employmentType: number
    jobStartDate: number
    jobEndDate: number
    departmentId: number
    createdAt: number
    updatedAt: number
    managerId: number
    positionId: number
    locationId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    status?: true
    role?: true
    employmentType?: true
    jobStartDate?: true
    jobEndDate?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    positionId?: true
    locationId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    status?: true
    role?: true
    employmentType?: true
    jobStartDate?: true
    jobEndDate?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    positionId?: true
    locationId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    status?: true
    role?: true
    employmentType?: true
    jobStartDate?: true
    jobEndDate?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    managerId?: true
    positionId?: true
    locationId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    firstName: string | null
    lastName: string | null
    email: string
    emailVerified: Date | null
    image: string | null
    password: string | null
    status: $Enums.UserStatus
    role: $Enums.UserRole
    employmentType: $Enums.EmploymentType
    jobStartDate: Date | null
    jobEndDate: Date | null
    departmentId: string | null
    createdAt: Date
    updatedAt: Date
    managerId: string | null
    positionId: string | null
    locationId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    status?: boolean
    role?: boolean
    employmentType?: boolean
    jobStartDate?: boolean
    jobEndDate?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    positionId?: boolean
    locationId?: boolean
    department?: boolean | User$departmentArgs<ExtArgs>
    candidateNotes?: boolean | User$candidateNotesArgs<ExtArgs>
    jobApplicationHistory?: boolean | User$jobApplicationHistoryArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    statusHistory?: boolean | User$statusHistoryArgs<ExtArgs>
    statusChangesBy?: boolean | User$statusChangesByArgs<ExtArgs>
    personalInfo?: boolean | User$personalInfoArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    documentReviews?: boolean | User$documentReviewsArgs<ExtArgs>
    DocumentVerification?: boolean | User$DocumentVerificationArgs<ExtArgs>
    OnboardingProgress?: boolean | User$OnboardingProgressArgs<ExtArgs>
    emergencyContacts?: boolean | User$emergencyContactsArgs<ExtArgs>
    dependentMembers?: boolean | User$dependentMembersArgs<ExtArgs>
    emails?: boolean | User$emailsArgs<ExtArgs>
    phones?: boolean | User$phonesArgs<ExtArgs>
    managedOnboardings?: boolean | User$managedOnboardingsArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    employees?: boolean | User$employeesArgs<ExtArgs>
    requestsMade?: boolean | User$requestsMadeArgs<ExtArgs>
    requestsToManage?: boolean | User$requestsToManageArgs<ExtArgs>
    requestHistory?: boolean | User$requestHistoryArgs<ExtArgs>
    leavesRequested?: boolean | User$leavesRequestedArgs<ExtArgs>
    leavesToApprove?: boolean | User$leavesToApproveArgs<ExtArgs>
    leaveStatusHistory?: boolean | User$leaveStatusHistoryArgs<ExtArgs>
    managedProjects?: boolean | User$managedProjectsArgs<ExtArgs>
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    timeEntries?: boolean | User$timeEntriesArgs<ExtArgs>
    shifts?: boolean | User$shiftsArgs<ExtArgs>
    announcementsChanged?: boolean | User$announcementsChangedArgs<ExtArgs>
    announcementsPublished?: boolean | User$announcementsPublishedArgs<ExtArgs>
    position?: boolean | User$positionArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    status?: boolean
    role?: boolean
    employmentType?: boolean
    jobStartDate?: boolean
    jobEndDate?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    positionId?: boolean
    locationId?: boolean
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    position?: boolean | User$positionArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    status?: boolean
    role?: boolean
    employmentType?: boolean
    jobStartDate?: boolean
    jobEndDate?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    positionId?: boolean
    locationId?: boolean
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    position?: boolean | User$positionArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    status?: boolean
    role?: boolean
    employmentType?: boolean
    jobStartDate?: boolean
    jobEndDate?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    managerId?: boolean
    positionId?: boolean
    locationId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "firstName" | "lastName" | "email" | "emailVerified" | "image" | "password" | "status" | "role" | "employmentType" | "jobStartDate" | "jobEndDate" | "departmentId" | "createdAt" | "updatedAt" | "managerId" | "positionId" | "locationId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | User$departmentArgs<ExtArgs>
    candidateNotes?: boolean | User$candidateNotesArgs<ExtArgs>
    jobApplicationHistory?: boolean | User$jobApplicationHistoryArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    statusHistory?: boolean | User$statusHistoryArgs<ExtArgs>
    statusChangesBy?: boolean | User$statusChangesByArgs<ExtArgs>
    personalInfo?: boolean | User$personalInfoArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    documentReviews?: boolean | User$documentReviewsArgs<ExtArgs>
    DocumentVerification?: boolean | User$DocumentVerificationArgs<ExtArgs>
    OnboardingProgress?: boolean | User$OnboardingProgressArgs<ExtArgs>
    emergencyContacts?: boolean | User$emergencyContactsArgs<ExtArgs>
    dependentMembers?: boolean | User$dependentMembersArgs<ExtArgs>
    emails?: boolean | User$emailsArgs<ExtArgs>
    phones?: boolean | User$phonesArgs<ExtArgs>
    managedOnboardings?: boolean | User$managedOnboardingsArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    employees?: boolean | User$employeesArgs<ExtArgs>
    requestsMade?: boolean | User$requestsMadeArgs<ExtArgs>
    requestsToManage?: boolean | User$requestsToManageArgs<ExtArgs>
    requestHistory?: boolean | User$requestHistoryArgs<ExtArgs>
    leavesRequested?: boolean | User$leavesRequestedArgs<ExtArgs>
    leavesToApprove?: boolean | User$leavesToApproveArgs<ExtArgs>
    leaveStatusHistory?: boolean | User$leaveStatusHistoryArgs<ExtArgs>
    managedProjects?: boolean | User$managedProjectsArgs<ExtArgs>
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    timeEntries?: boolean | User$timeEntriesArgs<ExtArgs>
    shifts?: boolean | User$shiftsArgs<ExtArgs>
    announcementsChanged?: boolean | User$announcementsChangedArgs<ExtArgs>
    announcementsPublished?: boolean | User$announcementsPublishedArgs<ExtArgs>
    position?: boolean | User$positionArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    position?: boolean | User$positionArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | User$departmentArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    position?: boolean | User$positionArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      candidateNotes: Prisma.$CandidateNotePayload<ExtArgs>[]
      jobApplicationHistory: Prisma.$JobApplicationHistoryPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      statusHistory: Prisma.$UserStatusHistoryPayload<ExtArgs>[]
      statusChangesBy: Prisma.$UserStatusHistoryPayload<ExtArgs>[]
      personalInfo: Prisma.$PersonalInfoPayload<ExtArgs> | null
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      documentReviews: Prisma.$DocumentVerificationPayload<ExtArgs>[]
      DocumentVerification: Prisma.$DocumentVerificationPayload<ExtArgs>[]
      OnboardingProgress: Prisma.$OnboardingProgressPayload<ExtArgs> | null
      emergencyContacts: Prisma.$EmergencyContactPayload<ExtArgs>[]
      dependentMembers: Prisma.$DependentMemberPayload<ExtArgs>[]
      emails: Prisma.$UserEmailPayload<ExtArgs>[]
      phones: Prisma.$UserPhonePayload<ExtArgs>[]
      managedOnboardings: Prisma.$OnboardingProgressPayload<ExtArgs>[]
      manager: Prisma.$UserPayload<ExtArgs> | null
      employees: Prisma.$UserPayload<ExtArgs>[]
      requestsMade: Prisma.$RequestPayload<ExtArgs>[]
      requestsToManage: Prisma.$RequestPayload<ExtArgs>[]
      requestHistory: Prisma.$RequestStatusHistoryPayload<ExtArgs>[]
      leavesRequested: Prisma.$LeaveRequestPayload<ExtArgs>[]
      leavesToApprove: Prisma.$LeaveRequestPayload<ExtArgs>[]
      leaveStatusHistory: Prisma.$LeaveStatusHistoryPayload<ExtArgs>[]
      managedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      projectMemberships: Prisma.$ProjectMemberPayload<ExtArgs>[]
      timeEntries: Prisma.$TimeEntryPayload<ExtArgs>[]
      shifts: Prisma.$ShiftEntryPayload<ExtArgs>[]
      announcementsChanged: Prisma.$AnnouncementPayload<ExtArgs>[]
      announcementsPublished: Prisma.$AnnouncementPayload<ExtArgs>[]
      position: Prisma.$PositionPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      firstName: string | null
      lastName: string | null
      email: string
      emailVerified: Date | null
      image: string | null
      password: string | null
      status: $Enums.UserStatus
      role: $Enums.UserRole
      employmentType: $Enums.EmploymentType
      jobStartDate: Date | null
      jobEndDate: Date | null
      departmentId: string | null
      createdAt: Date
      updatedAt: Date
      managerId: string | null
      positionId: string | null
      locationId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends User$departmentArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    candidateNotes<T extends User$candidateNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$candidateNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobApplicationHistory<T extends User$jobApplicationHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$jobApplicationHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusHistory<T extends User$statusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$statusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusChangesBy<T extends User$statusChangesByArgs<ExtArgs> = {}>(args?: Subset<T, User$statusChangesByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personalInfo<T extends User$personalInfoArgs<ExtArgs> = {}>(args?: Subset<T, User$personalInfoArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentReviews<T extends User$documentReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DocumentVerification<T extends User$DocumentVerificationArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentVerificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OnboardingProgress<T extends User$OnboardingProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$OnboardingProgressArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emergencyContacts<T extends User$emergencyContactsArgs<ExtArgs> = {}>(args?: Subset<T, User$emergencyContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dependentMembers<T extends User$dependentMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$dependentMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emails<T extends User$emailsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phones<T extends User$phonesArgs<ExtArgs> = {}>(args?: Subset<T, User$phonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    managedOnboardings<T extends User$managedOnboardingsArgs<ExtArgs> = {}>(args?: Subset<T, User$managedOnboardingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manager<T extends User$managerArgs<ExtArgs> = {}>(args?: Subset<T, User$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employees<T extends User$employeesArgs<ExtArgs> = {}>(args?: Subset<T, User$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requestsMade<T extends User$requestsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$requestsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requestsToManage<T extends User$requestsToManageArgs<ExtArgs> = {}>(args?: Subset<T, User$requestsToManageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requestHistory<T extends User$requestHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$requestHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leavesRequested<T extends User$leavesRequestedArgs<ExtArgs> = {}>(args?: Subset<T, User$leavesRequestedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leavesToApprove<T extends User$leavesToApproveArgs<ExtArgs> = {}>(args?: Subset<T, User$leavesToApproveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveStatusHistory<T extends User$leaveStatusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$leaveStatusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    managedProjects<T extends User$managedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$managedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectMemberships<T extends User$projectMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeEntries<T extends User$timeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$timeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shifts<T extends User$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, User$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcementsChanged<T extends User$announcementsChangedArgs<ExtArgs> = {}>(args?: Subset<T, User$announcementsChangedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcementsPublished<T extends User$announcementsPublishedArgs<ExtArgs> = {}>(args?: Subset<T, User$announcementsPublishedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    position<T extends User$positionArgs<ExtArgs> = {}>(args?: Subset<T, User$positionArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends User$locationArgs<ExtArgs> = {}>(args?: Subset<T, User$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly employmentType: FieldRef<"User", 'EmploymentType'>
    readonly jobStartDate: FieldRef<"User", 'DateTime'>
    readonly jobEndDate: FieldRef<"User", 'DateTime'>
    readonly departmentId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly managerId: FieldRef<"User", 'String'>
    readonly positionId: FieldRef<"User", 'String'>
    readonly locationId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.department
   */
  export type User$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * User.candidateNotes
   */
  export type User$candidateNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    where?: CandidateNoteWhereInput
    orderBy?: CandidateNoteOrderByWithRelationInput | CandidateNoteOrderByWithRelationInput[]
    cursor?: CandidateNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidateNoteScalarFieldEnum | CandidateNoteScalarFieldEnum[]
  }

  /**
   * User.jobApplicationHistory
   */
  export type User$jobApplicationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    where?: JobApplicationHistoryWhereInput
    orderBy?: JobApplicationHistoryOrderByWithRelationInput | JobApplicationHistoryOrderByWithRelationInput[]
    cursor?: JobApplicationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationHistoryScalarFieldEnum | JobApplicationHistoryScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.statusHistory
   */
  export type User$statusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    where?: UserStatusHistoryWhereInput
    orderBy?: UserStatusHistoryOrderByWithRelationInput | UserStatusHistoryOrderByWithRelationInput[]
    cursor?: UserStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserStatusHistoryScalarFieldEnum | UserStatusHistoryScalarFieldEnum[]
  }

  /**
   * User.statusChangesBy
   */
  export type User$statusChangesByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    where?: UserStatusHistoryWhereInput
    orderBy?: UserStatusHistoryOrderByWithRelationInput | UserStatusHistoryOrderByWithRelationInput[]
    cursor?: UserStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserStatusHistoryScalarFieldEnum | UserStatusHistoryScalarFieldEnum[]
  }

  /**
   * User.personalInfo
   */
  export type User$personalInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
    where?: PersonalInfoWhereInput
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.documentReviews
   */
  export type User$documentReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    where?: DocumentVerificationWhereInput
    orderBy?: DocumentVerificationOrderByWithRelationInput | DocumentVerificationOrderByWithRelationInput[]
    cursor?: DocumentVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentVerificationScalarFieldEnum | DocumentVerificationScalarFieldEnum[]
  }

  /**
   * User.DocumentVerification
   */
  export type User$DocumentVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    where?: DocumentVerificationWhereInput
    orderBy?: DocumentVerificationOrderByWithRelationInput | DocumentVerificationOrderByWithRelationInput[]
    cursor?: DocumentVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentVerificationScalarFieldEnum | DocumentVerificationScalarFieldEnum[]
  }

  /**
   * User.OnboardingProgress
   */
  export type User$OnboardingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    where?: OnboardingProgressWhereInput
  }

  /**
   * User.emergencyContacts
   */
  export type User$emergencyContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    cursor?: EmergencyContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * User.dependentMembers
   */
  export type User$dependentMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    where?: DependentMemberWhereInput
    orderBy?: DependentMemberOrderByWithRelationInput | DependentMemberOrderByWithRelationInput[]
    cursor?: DependentMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DependentMemberScalarFieldEnum | DependentMemberScalarFieldEnum[]
  }

  /**
   * User.emails
   */
  export type User$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    where?: UserEmailWhereInput
    orderBy?: UserEmailOrderByWithRelationInput | UserEmailOrderByWithRelationInput[]
    cursor?: UserEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserEmailScalarFieldEnum | UserEmailScalarFieldEnum[]
  }

  /**
   * User.phones
   */
  export type User$phonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    where?: UserPhoneWhereInput
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    cursor?: UserPhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * User.managedOnboardings
   */
  export type User$managedOnboardingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    where?: OnboardingProgressWhereInput
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    cursor?: OnboardingProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnboardingProgressScalarFieldEnum | OnboardingProgressScalarFieldEnum[]
  }

  /**
   * User.manager
   */
  export type User$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.employees
   */
  export type User$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.requestsMade
   */
  export type User$requestsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    cursor?: RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * User.requestsToManage
   */
  export type User$requestsToManageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    cursor?: RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * User.requestHistory
   */
  export type User$requestHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    where?: RequestStatusHistoryWhereInput
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    cursor?: RequestStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestStatusHistoryScalarFieldEnum | RequestStatusHistoryScalarFieldEnum[]
  }

  /**
   * User.leavesRequested
   */
  export type User$leavesRequestedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * User.leavesToApprove
   */
  export type User$leavesToApproveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * User.leaveStatusHistory
   */
  export type User$leaveStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    where?: LeaveStatusHistoryWhereInput
    orderBy?: LeaveStatusHistoryOrderByWithRelationInput | LeaveStatusHistoryOrderByWithRelationInput[]
    cursor?: LeaveStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveStatusHistoryScalarFieldEnum | LeaveStatusHistoryScalarFieldEnum[]
  }

  /**
   * User.managedProjects
   */
  export type User$managedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.projectMemberships
   */
  export type User$projectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User.timeEntries
   */
  export type User$timeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    cursor?: TimeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * User.shifts
   */
  export type User$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    where?: ShiftEntryWhereInput
    orderBy?: ShiftEntryOrderByWithRelationInput | ShiftEntryOrderByWithRelationInput[]
    cursor?: ShiftEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftEntryScalarFieldEnum | ShiftEntryScalarFieldEnum[]
  }

  /**
   * User.announcementsChanged
   */
  export type User$announcementsChangedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * User.announcementsPublished
   */
  export type User$announcementsPublishedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * User.position
   */
  export type User$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
  }

  /**
   * User.location
   */
  export type User$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserStatusHistory
   */

  export type AggregateUserStatusHistory = {
    _count: UserStatusHistoryCountAggregateOutputType | null
    _avg: UserStatusHistoryAvgAggregateOutputType | null
    _sum: UserStatusHistorySumAggregateOutputType | null
    _min: UserStatusHistoryMinAggregateOutputType | null
    _max: UserStatusHistoryMaxAggregateOutputType | null
  }

  export type UserStatusHistoryAvgAggregateOutputType = {
    id: number | null
  }

  export type UserStatusHistorySumAggregateOutputType = {
    id: number | null
  }

  export type UserStatusHistoryMinAggregateOutputType = {
    id: number | null
    userId: string | null
    status: $Enums.UserStatus | null
    comment: string | null
    createdAt: Date | null
    changedById: string | null
  }

  export type UserStatusHistoryMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    status: $Enums.UserStatus | null
    comment: string | null
    createdAt: Date | null
    changedById: string | null
  }

  export type UserStatusHistoryCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    comment: number
    createdAt: number
    changedById: number
    _all: number
  }


  export type UserStatusHistoryAvgAggregateInputType = {
    id?: true
  }

  export type UserStatusHistorySumAggregateInputType = {
    id?: true
  }

  export type UserStatusHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    comment?: true
    createdAt?: true
    changedById?: true
  }

  export type UserStatusHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    comment?: true
    createdAt?: true
    changedById?: true
  }

  export type UserStatusHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    comment?: true
    createdAt?: true
    changedById?: true
    _all?: true
  }

  export type UserStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStatusHistory to aggregate.
     */
    where?: UserStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStatusHistories to fetch.
     */
    orderBy?: UserStatusHistoryOrderByWithRelationInput | UserStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStatusHistories
    **/
    _count?: true | UserStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStatusHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStatusHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStatusHistoryMaxAggregateInputType
  }

  export type GetUserStatusHistoryAggregateType<T extends UserStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStatusHistory[P]>
      : GetScalarType<T[P], AggregateUserStatusHistory[P]>
  }




  export type UserStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStatusHistoryWhereInput
    orderBy?: UserStatusHistoryOrderByWithAggregationInput | UserStatusHistoryOrderByWithAggregationInput[]
    by: UserStatusHistoryScalarFieldEnum[] | UserStatusHistoryScalarFieldEnum
    having?: UserStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStatusHistoryCountAggregateInputType | true
    _avg?: UserStatusHistoryAvgAggregateInputType
    _sum?: UserStatusHistorySumAggregateInputType
    _min?: UserStatusHistoryMinAggregateInputType
    _max?: UserStatusHistoryMaxAggregateInputType
  }

  export type UserStatusHistoryGroupByOutputType = {
    id: number
    userId: string
    status: $Enums.UserStatus
    comment: string | null
    createdAt: Date
    changedById: string
    _count: UserStatusHistoryCountAggregateOutputType | null
    _avg: UserStatusHistoryAvgAggregateOutputType | null
    _sum: UserStatusHistorySumAggregateOutputType | null
    _min: UserStatusHistoryMinAggregateOutputType | null
    _max: UserStatusHistoryMaxAggregateOutputType | null
  }

  type GetUserStatusHistoryGroupByPayload<T extends UserStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UserStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    changedById?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStatusHistory"]>

  export type UserStatusHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    changedById?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStatusHistory"]>

  export type UserStatusHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    changedById?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStatusHistory"]>

  export type UserStatusHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    changedById?: boolean
  }

  export type UserStatusHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "comment" | "createdAt" | "changedById", ExtArgs["result"]["userStatusHistory"]>
  export type UserStatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStatusHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStatusHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStatusHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      changedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      status: $Enums.UserStatus
      comment: string | null
      createdAt: Date
      changedById: string
    }, ExtArgs["result"]["userStatusHistory"]>
    composites: {}
  }

  type UserStatusHistoryGetPayload<S extends boolean | null | undefined | UserStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$UserStatusHistoryPayload, S>

  type UserStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserStatusHistoryCountAggregateInputType | true
    }

  export interface UserStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStatusHistory'], meta: { name: 'UserStatusHistory' } }
    /**
     * Find zero or one UserStatusHistory that matches the filter.
     * @param {UserStatusHistoryFindUniqueArgs} args - Arguments to find a UserStatusHistory
     * @example
     * // Get one UserStatusHistory
     * const userStatusHistory = await prisma.userStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserStatusHistoryFindUniqueArgs>(args: SelectSubset<T, UserStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__UserStatusHistoryClient<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserStatusHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserStatusHistory
     * @example
     * // Get one UserStatusHistory
     * const userStatusHistory = await prisma.userStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserStatusHistoryClient<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatusHistoryFindFirstArgs} args - Arguments to find a UserStatusHistory
     * @example
     * // Get one UserStatusHistory
     * const userStatusHistory = await prisma.userStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserStatusHistoryFindFirstArgs>(args?: SelectSubset<T, UserStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__UserStatusHistoryClient<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a UserStatusHistory
     * @example
     * // Get one UserStatusHistory
     * const userStatusHistory = await prisma.userStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserStatusHistoryClient<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStatusHistories
     * const userStatusHistories = await prisma.userStatusHistory.findMany()
     * 
     * // Get first 10 UserStatusHistories
     * const userStatusHistories = await prisma.userStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userStatusHistoryWithIdOnly = await prisma.userStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserStatusHistoryFindManyArgs>(args?: SelectSubset<T, UserStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserStatusHistory.
     * @param {UserStatusHistoryCreateArgs} args - Arguments to create a UserStatusHistory.
     * @example
     * // Create one UserStatusHistory
     * const UserStatusHistory = await prisma.userStatusHistory.create({
     *   data: {
     *     // ... data to create a UserStatusHistory
     *   }
     * })
     * 
     */
    create<T extends UserStatusHistoryCreateArgs>(args: SelectSubset<T, UserStatusHistoryCreateArgs<ExtArgs>>): Prisma__UserStatusHistoryClient<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserStatusHistories.
     * @param {UserStatusHistoryCreateManyArgs} args - Arguments to create many UserStatusHistories.
     * @example
     * // Create many UserStatusHistories
     * const userStatusHistory = await prisma.userStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserStatusHistoryCreateManyArgs>(args?: SelectSubset<T, UserStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserStatusHistories and returns the data saved in the database.
     * @param {UserStatusHistoryCreateManyAndReturnArgs} args - Arguments to create many UserStatusHistories.
     * @example
     * // Create many UserStatusHistories
     * const userStatusHistory = await prisma.userStatusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserStatusHistories and only return the `id`
     * const userStatusHistoryWithIdOnly = await prisma.userStatusHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserStatusHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserStatusHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserStatusHistory.
     * @param {UserStatusHistoryDeleteArgs} args - Arguments to delete one UserStatusHistory.
     * @example
     * // Delete one UserStatusHistory
     * const UserStatusHistory = await prisma.userStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one UserStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends UserStatusHistoryDeleteArgs>(args: SelectSubset<T, UserStatusHistoryDeleteArgs<ExtArgs>>): Prisma__UserStatusHistoryClient<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserStatusHistory.
     * @param {UserStatusHistoryUpdateArgs} args - Arguments to update one UserStatusHistory.
     * @example
     * // Update one UserStatusHistory
     * const userStatusHistory = await prisma.userStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserStatusHistoryUpdateArgs>(args: SelectSubset<T, UserStatusHistoryUpdateArgs<ExtArgs>>): Prisma__UserStatusHistoryClient<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserStatusHistories.
     * @param {UserStatusHistoryDeleteManyArgs} args - Arguments to filter UserStatusHistories to delete.
     * @example
     * // Delete a few UserStatusHistories
     * const { count } = await prisma.userStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, UserStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStatusHistories
     * const userStatusHistory = await prisma.userStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserStatusHistoryUpdateManyArgs>(args: SelectSubset<T, UserStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStatusHistories and returns the data updated in the database.
     * @param {UserStatusHistoryUpdateManyAndReturnArgs} args - Arguments to update many UserStatusHistories.
     * @example
     * // Update many UserStatusHistories
     * const userStatusHistory = await prisma.userStatusHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserStatusHistories and only return the `id`
     * const userStatusHistoryWithIdOnly = await prisma.userStatusHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserStatusHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserStatusHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserStatusHistory.
     * @param {UserStatusHistoryUpsertArgs} args - Arguments to update or create a UserStatusHistory.
     * @example
     * // Update or create a UserStatusHistory
     * const userStatusHistory = await prisma.userStatusHistory.upsert({
     *   create: {
     *     // ... data to create a UserStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends UserStatusHistoryUpsertArgs>(args: SelectSubset<T, UserStatusHistoryUpsertArgs<ExtArgs>>): Prisma__UserStatusHistoryClient<$Result.GetResult<Prisma.$UserStatusHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatusHistoryCountArgs} args - Arguments to filter UserStatusHistories to count.
     * @example
     * // Count the number of UserStatusHistories
     * const count = await prisma.userStatusHistory.count({
     *   where: {
     *     // ... the filter for the UserStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends UserStatusHistoryCountArgs>(
      args?: Subset<T, UserStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStatusHistoryAggregateArgs>(args: Subset<T, UserStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserStatusHistoryAggregateType<T>>

    /**
     * Group by UserStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UserStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStatusHistory model
   */
  readonly fields: UserStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    changedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserStatusHistory model
   */ 
  interface UserStatusHistoryFieldRefs {
    readonly id: FieldRef<"UserStatusHistory", 'Int'>
    readonly userId: FieldRef<"UserStatusHistory", 'String'>
    readonly status: FieldRef<"UserStatusHistory", 'UserStatus'>
    readonly comment: FieldRef<"UserStatusHistory", 'String'>
    readonly createdAt: FieldRef<"UserStatusHistory", 'DateTime'>
    readonly changedById: FieldRef<"UserStatusHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserStatusHistory findUnique
   */
  export type UserStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserStatusHistory to fetch.
     */
    where: UserStatusHistoryWhereUniqueInput
  }

  /**
   * UserStatusHistory findUniqueOrThrow
   */
  export type UserStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserStatusHistory to fetch.
     */
    where: UserStatusHistoryWhereUniqueInput
  }

  /**
   * UserStatusHistory findFirst
   */
  export type UserStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserStatusHistory to fetch.
     */
    where?: UserStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStatusHistories to fetch.
     */
    orderBy?: UserStatusHistoryOrderByWithRelationInput | UserStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStatusHistories.
     */
    cursor?: UserStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStatusHistories.
     */
    distinct?: UserStatusHistoryScalarFieldEnum | UserStatusHistoryScalarFieldEnum[]
  }

  /**
   * UserStatusHistory findFirstOrThrow
   */
  export type UserStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserStatusHistory to fetch.
     */
    where?: UserStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStatusHistories to fetch.
     */
    orderBy?: UserStatusHistoryOrderByWithRelationInput | UserStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStatusHistories.
     */
    cursor?: UserStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStatusHistories.
     */
    distinct?: UserStatusHistoryScalarFieldEnum | UserStatusHistoryScalarFieldEnum[]
  }

  /**
   * UserStatusHistory findMany
   */
  export type UserStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UserStatusHistories to fetch.
     */
    where?: UserStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStatusHistories to fetch.
     */
    orderBy?: UserStatusHistoryOrderByWithRelationInput | UserStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStatusHistories.
     */
    cursor?: UserStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStatusHistories.
     */
    skip?: number
    distinct?: UserStatusHistoryScalarFieldEnum | UserStatusHistoryScalarFieldEnum[]
  }

  /**
   * UserStatusHistory create
   */
  export type UserStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserStatusHistory.
     */
    data: XOR<UserStatusHistoryCreateInput, UserStatusHistoryUncheckedCreateInput>
  }

  /**
   * UserStatusHistory createMany
   */
  export type UserStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStatusHistories.
     */
    data: UserStatusHistoryCreateManyInput | UserStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserStatusHistory createManyAndReturn
   */
  export type UserStatusHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many UserStatusHistories.
     */
    data: UserStatusHistoryCreateManyInput | UserStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStatusHistory update
   */
  export type UserStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserStatusHistory.
     */
    data: XOR<UserStatusHistoryUpdateInput, UserStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which UserStatusHistory to update.
     */
    where: UserStatusHistoryWhereUniqueInput
  }

  /**
   * UserStatusHistory updateMany
   */
  export type UserStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStatusHistories.
     */
    data: XOR<UserStatusHistoryUpdateManyMutationInput, UserStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserStatusHistories to update
     */
    where?: UserStatusHistoryWhereInput
    /**
     * Limit how many UserStatusHistories to update.
     */
    limit?: number
  }

  /**
   * UserStatusHistory updateManyAndReturn
   */
  export type UserStatusHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to update UserStatusHistories.
     */
    data: XOR<UserStatusHistoryUpdateManyMutationInput, UserStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UserStatusHistories to update
     */
    where?: UserStatusHistoryWhereInput
    /**
     * Limit how many UserStatusHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStatusHistory upsert
   */
  export type UserStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserStatusHistory to update in case it exists.
     */
    where: UserStatusHistoryWhereUniqueInput
    /**
     * In case the UserStatusHistory found by the `where` argument doesn't exist, create a new UserStatusHistory with this data.
     */
    create: XOR<UserStatusHistoryCreateInput, UserStatusHistoryUncheckedCreateInput>
    /**
     * In case the UserStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStatusHistoryUpdateInput, UserStatusHistoryUncheckedUpdateInput>
  }

  /**
   * UserStatusHistory delete
   */
  export type UserStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which UserStatusHistory to delete.
     */
    where: UserStatusHistoryWhereUniqueInput
  }

  /**
   * UserStatusHistory deleteMany
   */
  export type UserStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStatusHistories to delete
     */
    where?: UserStatusHistoryWhereInput
    /**
     * Limit how many UserStatusHistories to delete.
     */
    limit?: number
  }

  /**
   * UserStatusHistory without action
   */
  export type UserStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStatusHistory
     */
    select?: UserStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStatusHistory
     */
    omit?: UserStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model CandidateNote
   */

  export type AggregateCandidateNote = {
    _count: CandidateNoteCountAggregateOutputType | null
    _avg: CandidateNoteAvgAggregateOutputType | null
    _sum: CandidateNoteSumAggregateOutputType | null
    _min: CandidateNoteMinAggregateOutputType | null
    _max: CandidateNoteMaxAggregateOutputType | null
  }

  export type CandidateNoteAvgAggregateOutputType = {
    id: number | null
  }

  export type CandidateNoteSumAggregateOutputType = {
    id: number | null
  }

  export type CandidateNoteMinAggregateOutputType = {
    id: number | null
    candidateId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type CandidateNoteMaxAggregateOutputType = {
    id: number | null
    candidateId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type CandidateNoteCountAggregateOutputType = {
    id: number
    candidateId: number
    content: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type CandidateNoteAvgAggregateInputType = {
    id?: true
  }

  export type CandidateNoteSumAggregateInputType = {
    id?: true
  }

  export type CandidateNoteMinAggregateInputType = {
    id?: true
    candidateId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type CandidateNoteMaxAggregateInputType = {
    id?: true
    candidateId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type CandidateNoteCountAggregateInputType = {
    id?: true
    candidateId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type CandidateNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CandidateNote to aggregate.
     */
    where?: CandidateNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateNotes to fetch.
     */
    orderBy?: CandidateNoteOrderByWithRelationInput | CandidateNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandidateNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CandidateNotes
    **/
    _count?: true | CandidateNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CandidateNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CandidateNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandidateNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandidateNoteMaxAggregateInputType
  }

  export type GetCandidateNoteAggregateType<T extends CandidateNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateCandidateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandidateNote[P]>
      : GetScalarType<T[P], AggregateCandidateNote[P]>
  }




  export type CandidateNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateNoteWhereInput
    orderBy?: CandidateNoteOrderByWithAggregationInput | CandidateNoteOrderByWithAggregationInput[]
    by: CandidateNoteScalarFieldEnum[] | CandidateNoteScalarFieldEnum
    having?: CandidateNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandidateNoteCountAggregateInputType | true
    _avg?: CandidateNoteAvgAggregateInputType
    _sum?: CandidateNoteSumAggregateInputType
    _min?: CandidateNoteMinAggregateInputType
    _max?: CandidateNoteMaxAggregateInputType
  }

  export type CandidateNoteGroupByOutputType = {
    id: number
    candidateId: string
    content: string
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: CandidateNoteCountAggregateOutputType | null
    _avg: CandidateNoteAvgAggregateOutputType | null
    _sum: CandidateNoteSumAggregateOutputType | null
    _min: CandidateNoteMinAggregateOutputType | null
    _max: CandidateNoteMaxAggregateOutputType | null
  }

  type GetCandidateNoteGroupByPayload<T extends CandidateNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandidateNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandidateNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandidateNoteGroupByOutputType[P]>
            : GetScalarType<T[P], CandidateNoteGroupByOutputType[P]>
        }
      >
    >


  export type CandidateNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    candidateId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidateNote"]>

  export type CandidateNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    candidateId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidateNote"]>

  export type CandidateNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    candidateId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidateNote"]>

  export type CandidateNoteSelectScalar = {
    id?: boolean
    candidateId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type CandidateNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "candidateId" | "content" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["candidateNote"]>
  export type CandidateNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CandidateNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CandidateNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CandidateNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CandidateNote"
    objects: {
      candidate: Prisma.$CandidatePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      candidateId: string
      content: string
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["candidateNote"]>
    composites: {}
  }

  type CandidateNoteGetPayload<S extends boolean | null | undefined | CandidateNoteDefaultArgs> = $Result.GetResult<Prisma.$CandidateNotePayload, S>

  type CandidateNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CandidateNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CandidateNoteCountAggregateInputType | true
    }

  export interface CandidateNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CandidateNote'], meta: { name: 'CandidateNote' } }
    /**
     * Find zero or one CandidateNote that matches the filter.
     * @param {CandidateNoteFindUniqueArgs} args - Arguments to find a CandidateNote
     * @example
     * // Get one CandidateNote
     * const candidateNote = await prisma.candidateNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CandidateNoteFindUniqueArgs>(args: SelectSubset<T, CandidateNoteFindUniqueArgs<ExtArgs>>): Prisma__CandidateNoteClient<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CandidateNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CandidateNoteFindUniqueOrThrowArgs} args - Arguments to find a CandidateNote
     * @example
     * // Get one CandidateNote
     * const candidateNote = await prisma.candidateNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CandidateNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, CandidateNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CandidateNoteClient<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CandidateNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateNoteFindFirstArgs} args - Arguments to find a CandidateNote
     * @example
     * // Get one CandidateNote
     * const candidateNote = await prisma.candidateNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CandidateNoteFindFirstArgs>(args?: SelectSubset<T, CandidateNoteFindFirstArgs<ExtArgs>>): Prisma__CandidateNoteClient<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CandidateNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateNoteFindFirstOrThrowArgs} args - Arguments to find a CandidateNote
     * @example
     * // Get one CandidateNote
     * const candidateNote = await prisma.candidateNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CandidateNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, CandidateNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CandidateNoteClient<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CandidateNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CandidateNotes
     * const candidateNotes = await prisma.candidateNote.findMany()
     * 
     * // Get first 10 CandidateNotes
     * const candidateNotes = await prisma.candidateNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const candidateNoteWithIdOnly = await prisma.candidateNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CandidateNoteFindManyArgs>(args?: SelectSubset<T, CandidateNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CandidateNote.
     * @param {CandidateNoteCreateArgs} args - Arguments to create a CandidateNote.
     * @example
     * // Create one CandidateNote
     * const CandidateNote = await prisma.candidateNote.create({
     *   data: {
     *     // ... data to create a CandidateNote
     *   }
     * })
     * 
     */
    create<T extends CandidateNoteCreateArgs>(args: SelectSubset<T, CandidateNoteCreateArgs<ExtArgs>>): Prisma__CandidateNoteClient<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CandidateNotes.
     * @param {CandidateNoteCreateManyArgs} args - Arguments to create many CandidateNotes.
     * @example
     * // Create many CandidateNotes
     * const candidateNote = await prisma.candidateNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CandidateNoteCreateManyArgs>(args?: SelectSubset<T, CandidateNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CandidateNotes and returns the data saved in the database.
     * @param {CandidateNoteCreateManyAndReturnArgs} args - Arguments to create many CandidateNotes.
     * @example
     * // Create many CandidateNotes
     * const candidateNote = await prisma.candidateNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CandidateNotes and only return the `id`
     * const candidateNoteWithIdOnly = await prisma.candidateNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CandidateNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, CandidateNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CandidateNote.
     * @param {CandidateNoteDeleteArgs} args - Arguments to delete one CandidateNote.
     * @example
     * // Delete one CandidateNote
     * const CandidateNote = await prisma.candidateNote.delete({
     *   where: {
     *     // ... filter to delete one CandidateNote
     *   }
     * })
     * 
     */
    delete<T extends CandidateNoteDeleteArgs>(args: SelectSubset<T, CandidateNoteDeleteArgs<ExtArgs>>): Prisma__CandidateNoteClient<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CandidateNote.
     * @param {CandidateNoteUpdateArgs} args - Arguments to update one CandidateNote.
     * @example
     * // Update one CandidateNote
     * const candidateNote = await prisma.candidateNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CandidateNoteUpdateArgs>(args: SelectSubset<T, CandidateNoteUpdateArgs<ExtArgs>>): Prisma__CandidateNoteClient<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CandidateNotes.
     * @param {CandidateNoteDeleteManyArgs} args - Arguments to filter CandidateNotes to delete.
     * @example
     * // Delete a few CandidateNotes
     * const { count } = await prisma.candidateNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CandidateNoteDeleteManyArgs>(args?: SelectSubset<T, CandidateNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CandidateNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CandidateNotes
     * const candidateNote = await prisma.candidateNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CandidateNoteUpdateManyArgs>(args: SelectSubset<T, CandidateNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CandidateNotes and returns the data updated in the database.
     * @param {CandidateNoteUpdateManyAndReturnArgs} args - Arguments to update many CandidateNotes.
     * @example
     * // Update many CandidateNotes
     * const candidateNote = await prisma.candidateNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CandidateNotes and only return the `id`
     * const candidateNoteWithIdOnly = await prisma.candidateNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CandidateNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, CandidateNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CandidateNote.
     * @param {CandidateNoteUpsertArgs} args - Arguments to update or create a CandidateNote.
     * @example
     * // Update or create a CandidateNote
     * const candidateNote = await prisma.candidateNote.upsert({
     *   create: {
     *     // ... data to create a CandidateNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CandidateNote we want to update
     *   }
     * })
     */
    upsert<T extends CandidateNoteUpsertArgs>(args: SelectSubset<T, CandidateNoteUpsertArgs<ExtArgs>>): Prisma__CandidateNoteClient<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CandidateNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateNoteCountArgs} args - Arguments to filter CandidateNotes to count.
     * @example
     * // Count the number of CandidateNotes
     * const count = await prisma.candidateNote.count({
     *   where: {
     *     // ... the filter for the CandidateNotes we want to count
     *   }
     * })
    **/
    count<T extends CandidateNoteCountArgs>(
      args?: Subset<T, CandidateNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandidateNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CandidateNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandidateNoteAggregateArgs>(args: Subset<T, CandidateNoteAggregateArgs>): Prisma.PrismaPromise<GetCandidateNoteAggregateType<T>>

    /**
     * Group by CandidateNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandidateNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandidateNoteGroupByArgs['orderBy'] }
        : { orderBy?: CandidateNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandidateNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandidateNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CandidateNote model
   */
  readonly fields: CandidateNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CandidateNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandidateNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    candidate<T extends CandidateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidateDefaultArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CandidateNote model
   */ 
  interface CandidateNoteFieldRefs {
    readonly id: FieldRef<"CandidateNote", 'Int'>
    readonly candidateId: FieldRef<"CandidateNote", 'String'>
    readonly content: FieldRef<"CandidateNote", 'String'>
    readonly createdAt: FieldRef<"CandidateNote", 'DateTime'>
    readonly updatedAt: FieldRef<"CandidateNote", 'DateTime'>
    readonly userId: FieldRef<"CandidateNote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CandidateNote findUnique
   */
  export type CandidateNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    /**
     * Filter, which CandidateNote to fetch.
     */
    where: CandidateNoteWhereUniqueInput
  }

  /**
   * CandidateNote findUniqueOrThrow
   */
  export type CandidateNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    /**
     * Filter, which CandidateNote to fetch.
     */
    where: CandidateNoteWhereUniqueInput
  }

  /**
   * CandidateNote findFirst
   */
  export type CandidateNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    /**
     * Filter, which CandidateNote to fetch.
     */
    where?: CandidateNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateNotes to fetch.
     */
    orderBy?: CandidateNoteOrderByWithRelationInput | CandidateNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CandidateNotes.
     */
    cursor?: CandidateNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CandidateNotes.
     */
    distinct?: CandidateNoteScalarFieldEnum | CandidateNoteScalarFieldEnum[]
  }

  /**
   * CandidateNote findFirstOrThrow
   */
  export type CandidateNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    /**
     * Filter, which CandidateNote to fetch.
     */
    where?: CandidateNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateNotes to fetch.
     */
    orderBy?: CandidateNoteOrderByWithRelationInput | CandidateNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CandidateNotes.
     */
    cursor?: CandidateNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CandidateNotes.
     */
    distinct?: CandidateNoteScalarFieldEnum | CandidateNoteScalarFieldEnum[]
  }

  /**
   * CandidateNote findMany
   */
  export type CandidateNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    /**
     * Filter, which CandidateNotes to fetch.
     */
    where?: CandidateNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateNotes to fetch.
     */
    orderBy?: CandidateNoteOrderByWithRelationInput | CandidateNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CandidateNotes.
     */
    cursor?: CandidateNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateNotes.
     */
    skip?: number
    distinct?: CandidateNoteScalarFieldEnum | CandidateNoteScalarFieldEnum[]
  }

  /**
   * CandidateNote create
   */
  export type CandidateNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a CandidateNote.
     */
    data: XOR<CandidateNoteCreateInput, CandidateNoteUncheckedCreateInput>
  }

  /**
   * CandidateNote createMany
   */
  export type CandidateNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CandidateNotes.
     */
    data: CandidateNoteCreateManyInput | CandidateNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CandidateNote createManyAndReturn
   */
  export type CandidateNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * The data used to create many CandidateNotes.
     */
    data: CandidateNoteCreateManyInput | CandidateNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CandidateNote update
   */
  export type CandidateNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a CandidateNote.
     */
    data: XOR<CandidateNoteUpdateInput, CandidateNoteUncheckedUpdateInput>
    /**
     * Choose, which CandidateNote to update.
     */
    where: CandidateNoteWhereUniqueInput
  }

  /**
   * CandidateNote updateMany
   */
  export type CandidateNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CandidateNotes.
     */
    data: XOR<CandidateNoteUpdateManyMutationInput, CandidateNoteUncheckedUpdateManyInput>
    /**
     * Filter which CandidateNotes to update
     */
    where?: CandidateNoteWhereInput
    /**
     * Limit how many CandidateNotes to update.
     */
    limit?: number
  }

  /**
   * CandidateNote updateManyAndReturn
   */
  export type CandidateNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * The data used to update CandidateNotes.
     */
    data: XOR<CandidateNoteUpdateManyMutationInput, CandidateNoteUncheckedUpdateManyInput>
    /**
     * Filter which CandidateNotes to update
     */
    where?: CandidateNoteWhereInput
    /**
     * Limit how many CandidateNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CandidateNote upsert
   */
  export type CandidateNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the CandidateNote to update in case it exists.
     */
    where: CandidateNoteWhereUniqueInput
    /**
     * In case the CandidateNote found by the `where` argument doesn't exist, create a new CandidateNote with this data.
     */
    create: XOR<CandidateNoteCreateInput, CandidateNoteUncheckedCreateInput>
    /**
     * In case the CandidateNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandidateNoteUpdateInput, CandidateNoteUncheckedUpdateInput>
  }

  /**
   * CandidateNote delete
   */
  export type CandidateNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    /**
     * Filter which CandidateNote to delete.
     */
    where: CandidateNoteWhereUniqueInput
  }

  /**
   * CandidateNote deleteMany
   */
  export type CandidateNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CandidateNotes to delete
     */
    where?: CandidateNoteWhereInput
    /**
     * Limit how many CandidateNotes to delete.
     */
    limit?: number
  }

  /**
   * CandidateNote without action
   */
  export type CandidateNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
  }


  /**
   * Model JobListing
   */

  export type AggregateJobListing = {
    _count: JobListingCountAggregateOutputType | null
    _avg: JobListingAvgAggregateOutputType | null
    _sum: JobListingSumAggregateOutputType | null
    _min: JobListingMinAggregateOutputType | null
    _max: JobListingMaxAggregateOutputType | null
  }

  export type JobListingAvgAggregateOutputType = {
    id: number | null
  }

  export type JobListingSumAggregateOutputType = {
    id: number | null
  }

  export type JobListingMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    employmentType: $Enums.EmploymentType | null
    workplaceType: $Enums.WorkplaceType | null
    referralSource: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.JobStatus | null
    departmentId: string | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    positionId: string | null
  }

  export type JobListingMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    employmentType: $Enums.EmploymentType | null
    workplaceType: $Enums.WorkplaceType | null
    referralSource: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.JobStatus | null
    departmentId: string | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    positionId: string | null
  }

  export type JobListingCountAggregateOutputType = {
    id: number
    title: number
    description: number
    employmentType: number
    workplaceType: number
    referralSource: number
    startDate: number
    endDate: number
    status: number
    departmentId: number
    locationId: number
    keywords: number
    createdAt: number
    updatedAt: number
    positionId: number
    _all: number
  }


  export type JobListingAvgAggregateInputType = {
    id?: true
  }

  export type JobListingSumAggregateInputType = {
    id?: true
  }

  export type JobListingMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    employmentType?: true
    workplaceType?: true
    referralSource?: true
    startDate?: true
    endDate?: true
    status?: true
    departmentId?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    positionId?: true
  }

  export type JobListingMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    employmentType?: true
    workplaceType?: true
    referralSource?: true
    startDate?: true
    endDate?: true
    status?: true
    departmentId?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    positionId?: true
  }

  export type JobListingCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    employmentType?: true
    workplaceType?: true
    referralSource?: true
    startDate?: true
    endDate?: true
    status?: true
    departmentId?: true
    locationId?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
    positionId?: true
    _all?: true
  }

  export type JobListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobListing to aggregate.
     */
    where?: JobListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobListings to fetch.
     */
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobListings
    **/
    _count?: true | JobListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobListingMaxAggregateInputType
  }

  export type GetJobListingAggregateType<T extends JobListingAggregateArgs> = {
        [P in keyof T & keyof AggregateJobListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobListing[P]>
      : GetScalarType<T[P], AggregateJobListing[P]>
  }




  export type JobListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobListingWhereInput
    orderBy?: JobListingOrderByWithAggregationInput | JobListingOrderByWithAggregationInput[]
    by: JobListingScalarFieldEnum[] | JobListingScalarFieldEnum
    having?: JobListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobListingCountAggregateInputType | true
    _avg?: JobListingAvgAggregateInputType
    _sum?: JobListingSumAggregateInputType
    _min?: JobListingMinAggregateInputType
    _max?: JobListingMaxAggregateInputType
  }

  export type JobListingGroupByOutputType = {
    id: number
    title: string
    description: string
    employmentType: $Enums.EmploymentType
    workplaceType: $Enums.WorkplaceType
    referralSource: string | null
    startDate: Date
    endDate: Date | null
    status: $Enums.JobStatus
    departmentId: string | null
    locationId: string | null
    keywords: string[]
    createdAt: Date
    updatedAt: Date
    positionId: string | null
    _count: JobListingCountAggregateOutputType | null
    _avg: JobListingAvgAggregateOutputType | null
    _sum: JobListingSumAggregateOutputType | null
    _min: JobListingMinAggregateOutputType | null
    _max: JobListingMaxAggregateOutputType | null
  }

  type GetJobListingGroupByPayload<T extends JobListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobListingGroupByOutputType[P]>
            : GetScalarType<T[P], JobListingGroupByOutputType[P]>
        }
      >
    >


  export type JobListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    employmentType?: boolean
    workplaceType?: boolean
    referralSource?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    departmentId?: boolean
    locationId?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    positionId?: boolean
    department?: boolean | JobListing$departmentArgs<ExtArgs>
    location?: boolean | JobListing$locationArgs<ExtArgs>
    applications?: boolean | JobListing$applicationsArgs<ExtArgs>
    position?: boolean | JobListing$positionArgs<ExtArgs>
    _count?: boolean | JobListingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobListing"]>

  export type JobListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    employmentType?: boolean
    workplaceType?: boolean
    referralSource?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    departmentId?: boolean
    locationId?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    positionId?: boolean
    department?: boolean | JobListing$departmentArgs<ExtArgs>
    location?: boolean | JobListing$locationArgs<ExtArgs>
    position?: boolean | JobListing$positionArgs<ExtArgs>
  }, ExtArgs["result"]["jobListing"]>

  export type JobListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    employmentType?: boolean
    workplaceType?: boolean
    referralSource?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    departmentId?: boolean
    locationId?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    positionId?: boolean
    department?: boolean | JobListing$departmentArgs<ExtArgs>
    location?: boolean | JobListing$locationArgs<ExtArgs>
    position?: boolean | JobListing$positionArgs<ExtArgs>
  }, ExtArgs["result"]["jobListing"]>

  export type JobListingSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    employmentType?: boolean
    workplaceType?: boolean
    referralSource?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    departmentId?: boolean
    locationId?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    positionId?: boolean
  }

  export type JobListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "employmentType" | "workplaceType" | "referralSource" | "startDate" | "endDate" | "status" | "departmentId" | "locationId" | "keywords" | "createdAt" | "updatedAt" | "positionId", ExtArgs["result"]["jobListing"]>
  export type JobListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | JobListing$departmentArgs<ExtArgs>
    location?: boolean | JobListing$locationArgs<ExtArgs>
    applications?: boolean | JobListing$applicationsArgs<ExtArgs>
    position?: boolean | JobListing$positionArgs<ExtArgs>
    _count?: boolean | JobListingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | JobListing$departmentArgs<ExtArgs>
    location?: boolean | JobListing$locationArgs<ExtArgs>
    position?: boolean | JobListing$positionArgs<ExtArgs>
  }
  export type JobListingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | JobListing$departmentArgs<ExtArgs>
    location?: boolean | JobListing$locationArgs<ExtArgs>
    position?: boolean | JobListing$positionArgs<ExtArgs>
  }

  export type $JobListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobListing"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
      applications: Prisma.$JobApplicationPayload<ExtArgs>[]
      position: Prisma.$PositionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      employmentType: $Enums.EmploymentType
      workplaceType: $Enums.WorkplaceType
      referralSource: string | null
      startDate: Date
      endDate: Date | null
      status: $Enums.JobStatus
      departmentId: string | null
      locationId: string | null
      keywords: string[]
      createdAt: Date
      updatedAt: Date
      positionId: string | null
    }, ExtArgs["result"]["jobListing"]>
    composites: {}
  }

  type JobListingGetPayload<S extends boolean | null | undefined | JobListingDefaultArgs> = $Result.GetResult<Prisma.$JobListingPayload, S>

  type JobListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobListingCountAggregateInputType | true
    }

  export interface JobListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobListing'], meta: { name: 'JobListing' } }
    /**
     * Find zero or one JobListing that matches the filter.
     * @param {JobListingFindUniqueArgs} args - Arguments to find a JobListing
     * @example
     * // Get one JobListing
     * const jobListing = await prisma.jobListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobListingFindUniqueArgs>(args: SelectSubset<T, JobListingFindUniqueArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobListing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobListingFindUniqueOrThrowArgs} args - Arguments to find a JobListing
     * @example
     * // Get one JobListing
     * const jobListing = await prisma.jobListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobListingFindUniqueOrThrowArgs>(args: SelectSubset<T, JobListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingFindFirstArgs} args - Arguments to find a JobListing
     * @example
     * // Get one JobListing
     * const jobListing = await prisma.jobListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobListingFindFirstArgs>(args?: SelectSubset<T, JobListingFindFirstArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingFindFirstOrThrowArgs} args - Arguments to find a JobListing
     * @example
     * // Get one JobListing
     * const jobListing = await prisma.jobListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobListingFindFirstOrThrowArgs>(args?: SelectSubset<T, JobListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobListings
     * const jobListings = await prisma.jobListing.findMany()
     * 
     * // Get first 10 JobListings
     * const jobListings = await prisma.jobListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobListingWithIdOnly = await prisma.jobListing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobListingFindManyArgs>(args?: SelectSubset<T, JobListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobListing.
     * @param {JobListingCreateArgs} args - Arguments to create a JobListing.
     * @example
     * // Create one JobListing
     * const JobListing = await prisma.jobListing.create({
     *   data: {
     *     // ... data to create a JobListing
     *   }
     * })
     * 
     */
    create<T extends JobListingCreateArgs>(args: SelectSubset<T, JobListingCreateArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobListings.
     * @param {JobListingCreateManyArgs} args - Arguments to create many JobListings.
     * @example
     * // Create many JobListings
     * const jobListing = await prisma.jobListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobListingCreateManyArgs>(args?: SelectSubset<T, JobListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobListings and returns the data saved in the database.
     * @param {JobListingCreateManyAndReturnArgs} args - Arguments to create many JobListings.
     * @example
     * // Create many JobListings
     * const jobListing = await prisma.jobListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobListings and only return the `id`
     * const jobListingWithIdOnly = await prisma.jobListing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobListingCreateManyAndReturnArgs>(args?: SelectSubset<T, JobListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobListing.
     * @param {JobListingDeleteArgs} args - Arguments to delete one JobListing.
     * @example
     * // Delete one JobListing
     * const JobListing = await prisma.jobListing.delete({
     *   where: {
     *     // ... filter to delete one JobListing
     *   }
     * })
     * 
     */
    delete<T extends JobListingDeleteArgs>(args: SelectSubset<T, JobListingDeleteArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobListing.
     * @param {JobListingUpdateArgs} args - Arguments to update one JobListing.
     * @example
     * // Update one JobListing
     * const jobListing = await prisma.jobListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobListingUpdateArgs>(args: SelectSubset<T, JobListingUpdateArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobListings.
     * @param {JobListingDeleteManyArgs} args - Arguments to filter JobListings to delete.
     * @example
     * // Delete a few JobListings
     * const { count } = await prisma.jobListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobListingDeleteManyArgs>(args?: SelectSubset<T, JobListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobListings
     * const jobListing = await prisma.jobListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobListingUpdateManyArgs>(args: SelectSubset<T, JobListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobListings and returns the data updated in the database.
     * @param {JobListingUpdateManyAndReturnArgs} args - Arguments to update many JobListings.
     * @example
     * // Update many JobListings
     * const jobListing = await prisma.jobListing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobListings and only return the `id`
     * const jobListingWithIdOnly = await prisma.jobListing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobListingUpdateManyAndReturnArgs>(args: SelectSubset<T, JobListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobListing.
     * @param {JobListingUpsertArgs} args - Arguments to update or create a JobListing.
     * @example
     * // Update or create a JobListing
     * const jobListing = await prisma.jobListing.upsert({
     *   create: {
     *     // ... data to create a JobListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobListing we want to update
     *   }
     * })
     */
    upsert<T extends JobListingUpsertArgs>(args: SelectSubset<T, JobListingUpsertArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingCountArgs} args - Arguments to filter JobListings to count.
     * @example
     * // Count the number of JobListings
     * const count = await prisma.jobListing.count({
     *   where: {
     *     // ... the filter for the JobListings we want to count
     *   }
     * })
    **/
    count<T extends JobListingCountArgs>(
      args?: Subset<T, JobListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobListingAggregateArgs>(args: Subset<T, JobListingAggregateArgs>): Prisma.PrismaPromise<GetJobListingAggregateType<T>>

    /**
     * Group by JobListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobListingGroupByArgs['orderBy'] }
        : { orderBy?: JobListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobListing model
   */
  readonly fields: JobListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends JobListing$departmentArgs<ExtArgs> = {}>(args?: Subset<T, JobListing$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends JobListing$locationArgs<ExtArgs> = {}>(args?: Subset<T, JobListing$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    applications<T extends JobListing$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, JobListing$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    position<T extends JobListing$positionArgs<ExtArgs> = {}>(args?: Subset<T, JobListing$positionArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobListing model
   */ 
  interface JobListingFieldRefs {
    readonly id: FieldRef<"JobListing", 'Int'>
    readonly title: FieldRef<"JobListing", 'String'>
    readonly description: FieldRef<"JobListing", 'String'>
    readonly employmentType: FieldRef<"JobListing", 'EmploymentType'>
    readonly workplaceType: FieldRef<"JobListing", 'WorkplaceType'>
    readonly referralSource: FieldRef<"JobListing", 'String'>
    readonly startDate: FieldRef<"JobListing", 'DateTime'>
    readonly endDate: FieldRef<"JobListing", 'DateTime'>
    readonly status: FieldRef<"JobListing", 'JobStatus'>
    readonly departmentId: FieldRef<"JobListing", 'String'>
    readonly locationId: FieldRef<"JobListing", 'String'>
    readonly keywords: FieldRef<"JobListing", 'String[]'>
    readonly createdAt: FieldRef<"JobListing", 'DateTime'>
    readonly updatedAt: FieldRef<"JobListing", 'DateTime'>
    readonly positionId: FieldRef<"JobListing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobListing findUnique
   */
  export type JobListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    /**
     * Filter, which JobListing to fetch.
     */
    where: JobListingWhereUniqueInput
  }

  /**
   * JobListing findUniqueOrThrow
   */
  export type JobListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    /**
     * Filter, which JobListing to fetch.
     */
    where: JobListingWhereUniqueInput
  }

  /**
   * JobListing findFirst
   */
  export type JobListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    /**
     * Filter, which JobListing to fetch.
     */
    where?: JobListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobListings to fetch.
     */
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobListings.
     */
    cursor?: JobListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobListings.
     */
    distinct?: JobListingScalarFieldEnum | JobListingScalarFieldEnum[]
  }

  /**
   * JobListing findFirstOrThrow
   */
  export type JobListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    /**
     * Filter, which JobListing to fetch.
     */
    where?: JobListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobListings to fetch.
     */
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobListings.
     */
    cursor?: JobListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobListings.
     */
    distinct?: JobListingScalarFieldEnum | JobListingScalarFieldEnum[]
  }

  /**
   * JobListing findMany
   */
  export type JobListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    /**
     * Filter, which JobListings to fetch.
     */
    where?: JobListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobListings to fetch.
     */
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobListings.
     */
    cursor?: JobListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobListings.
     */
    skip?: number
    distinct?: JobListingScalarFieldEnum | JobListingScalarFieldEnum[]
  }

  /**
   * JobListing create
   */
  export type JobListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    /**
     * The data needed to create a JobListing.
     */
    data: XOR<JobListingCreateInput, JobListingUncheckedCreateInput>
  }

  /**
   * JobListing createMany
   */
  export type JobListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobListings.
     */
    data: JobListingCreateManyInput | JobListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobListing createManyAndReturn
   */
  export type JobListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * The data used to create many JobListings.
     */
    data: JobListingCreateManyInput | JobListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobListing update
   */
  export type JobListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    /**
     * The data needed to update a JobListing.
     */
    data: XOR<JobListingUpdateInput, JobListingUncheckedUpdateInput>
    /**
     * Choose, which JobListing to update.
     */
    where: JobListingWhereUniqueInput
  }

  /**
   * JobListing updateMany
   */
  export type JobListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobListings.
     */
    data: XOR<JobListingUpdateManyMutationInput, JobListingUncheckedUpdateManyInput>
    /**
     * Filter which JobListings to update
     */
    where?: JobListingWhereInput
    /**
     * Limit how many JobListings to update.
     */
    limit?: number
  }

  /**
   * JobListing updateManyAndReturn
   */
  export type JobListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * The data used to update JobListings.
     */
    data: XOR<JobListingUpdateManyMutationInput, JobListingUncheckedUpdateManyInput>
    /**
     * Filter which JobListings to update
     */
    where?: JobListingWhereInput
    /**
     * Limit how many JobListings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobListing upsert
   */
  export type JobListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    /**
     * The filter to search for the JobListing to update in case it exists.
     */
    where: JobListingWhereUniqueInput
    /**
     * In case the JobListing found by the `where` argument doesn't exist, create a new JobListing with this data.
     */
    create: XOR<JobListingCreateInput, JobListingUncheckedCreateInput>
    /**
     * In case the JobListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobListingUpdateInput, JobListingUncheckedUpdateInput>
  }

  /**
   * JobListing delete
   */
  export type JobListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    /**
     * Filter which JobListing to delete.
     */
    where: JobListingWhereUniqueInput
  }

  /**
   * JobListing deleteMany
   */
  export type JobListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobListings to delete
     */
    where?: JobListingWhereInput
    /**
     * Limit how many JobListings to delete.
     */
    limit?: number
  }

  /**
   * JobListing.department
   */
  export type JobListing$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * JobListing.location
   */
  export type JobListing$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * JobListing.applications
   */
  export type JobListing$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    cursor?: JobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * JobListing.position
   */
  export type JobListing$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
  }

  /**
   * JobListing without action
   */
  export type JobListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
  }


  /**
   * Model Candidate
   */

  export type AggregateCandidate = {
    _count: CandidateCountAggregateOutputType | null
    _min: CandidateMinAggregateOutputType | null
    _max: CandidateMaxAggregateOutputType | null
  }

  export type CandidateMinAggregateOutputType = {
    id: string | null
    name: string | null
    surname: string | null
    email: string | null
    phone: string | null
    linkedin: string | null
    github: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CandidateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    surname: string | null
    email: string | null
    phone: string | null
    linkedin: string | null
    github: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CandidateCountAggregateOutputType = {
    id: number
    name: number
    surname: number
    email: number
    phone: number
    linkedin: number
    github: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CandidateMinAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    phone?: true
    linkedin?: true
    github?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CandidateMaxAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    phone?: true
    linkedin?: true
    github?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CandidateCountAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    email?: true
    phone?: true
    linkedin?: true
    github?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CandidateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candidate to aggregate.
     */
    where?: CandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidates to fetch.
     */
    orderBy?: CandidateOrderByWithRelationInput | CandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Candidates
    **/
    _count?: true | CandidateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandidateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandidateMaxAggregateInputType
  }

  export type GetCandidateAggregateType<T extends CandidateAggregateArgs> = {
        [P in keyof T & keyof AggregateCandidate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandidate[P]>
      : GetScalarType<T[P], AggregateCandidate[P]>
  }




  export type CandidateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateWhereInput
    orderBy?: CandidateOrderByWithAggregationInput | CandidateOrderByWithAggregationInput[]
    by: CandidateScalarFieldEnum[] | CandidateScalarFieldEnum
    having?: CandidateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandidateCountAggregateInputType | true
    _min?: CandidateMinAggregateInputType
    _max?: CandidateMaxAggregateInputType
  }

  export type CandidateGroupByOutputType = {
    id: string
    name: string
    surname: string
    email: string
    phone: string
    linkedin: string | null
    github: string | null
    createdAt: Date
    updatedAt: Date
    _count: CandidateCountAggregateOutputType | null
    _min: CandidateMinAggregateOutputType | null
    _max: CandidateMaxAggregateOutputType | null
  }

  type GetCandidateGroupByPayload<T extends CandidateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandidateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandidateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandidateGroupByOutputType[P]>
            : GetScalarType<T[P], CandidateGroupByOutputType[P]>
        }
      >
    >


  export type CandidateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phone?: boolean
    linkedin?: boolean
    github?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applications?: boolean | Candidate$applicationsArgs<ExtArgs>
    notes?: boolean | Candidate$notesArgs<ExtArgs>
    _count?: boolean | CandidateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidate"]>

  export type CandidateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phone?: boolean
    linkedin?: boolean
    github?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["candidate"]>

  export type CandidateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phone?: boolean
    linkedin?: boolean
    github?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["candidate"]>

  export type CandidateSelectScalar = {
    id?: boolean
    name?: boolean
    surname?: boolean
    email?: boolean
    phone?: boolean
    linkedin?: boolean
    github?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CandidateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "surname" | "email" | "phone" | "linkedin" | "github" | "createdAt" | "updatedAt", ExtArgs["result"]["candidate"]>
  export type CandidateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | Candidate$applicationsArgs<ExtArgs>
    notes?: boolean | Candidate$notesArgs<ExtArgs>
    _count?: boolean | CandidateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CandidateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CandidateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CandidatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Candidate"
    objects: {
      applications: Prisma.$JobApplicationPayload<ExtArgs>[]
      notes: Prisma.$CandidateNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      surname: string
      email: string
      phone: string
      linkedin: string | null
      github: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["candidate"]>
    composites: {}
  }

  type CandidateGetPayload<S extends boolean | null | undefined | CandidateDefaultArgs> = $Result.GetResult<Prisma.$CandidatePayload, S>

  type CandidateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CandidateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CandidateCountAggregateInputType | true
    }

  export interface CandidateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Candidate'], meta: { name: 'Candidate' } }
    /**
     * Find zero or one Candidate that matches the filter.
     * @param {CandidateFindUniqueArgs} args - Arguments to find a Candidate
     * @example
     * // Get one Candidate
     * const candidate = await prisma.candidate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CandidateFindUniqueArgs>(args: SelectSubset<T, CandidateFindUniqueArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Candidate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CandidateFindUniqueOrThrowArgs} args - Arguments to find a Candidate
     * @example
     * // Get one Candidate
     * const candidate = await prisma.candidate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CandidateFindUniqueOrThrowArgs>(args: SelectSubset<T, CandidateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Candidate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateFindFirstArgs} args - Arguments to find a Candidate
     * @example
     * // Get one Candidate
     * const candidate = await prisma.candidate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CandidateFindFirstArgs>(args?: SelectSubset<T, CandidateFindFirstArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Candidate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateFindFirstOrThrowArgs} args - Arguments to find a Candidate
     * @example
     * // Get one Candidate
     * const candidate = await prisma.candidate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CandidateFindFirstOrThrowArgs>(args?: SelectSubset<T, CandidateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Candidates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Candidates
     * const candidates = await prisma.candidate.findMany()
     * 
     * // Get first 10 Candidates
     * const candidates = await prisma.candidate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const candidateWithIdOnly = await prisma.candidate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CandidateFindManyArgs>(args?: SelectSubset<T, CandidateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Candidate.
     * @param {CandidateCreateArgs} args - Arguments to create a Candidate.
     * @example
     * // Create one Candidate
     * const Candidate = await prisma.candidate.create({
     *   data: {
     *     // ... data to create a Candidate
     *   }
     * })
     * 
     */
    create<T extends CandidateCreateArgs>(args: SelectSubset<T, CandidateCreateArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Candidates.
     * @param {CandidateCreateManyArgs} args - Arguments to create many Candidates.
     * @example
     * // Create many Candidates
     * const candidate = await prisma.candidate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CandidateCreateManyArgs>(args?: SelectSubset<T, CandidateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Candidates and returns the data saved in the database.
     * @param {CandidateCreateManyAndReturnArgs} args - Arguments to create many Candidates.
     * @example
     * // Create many Candidates
     * const candidate = await prisma.candidate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Candidates and only return the `id`
     * const candidateWithIdOnly = await prisma.candidate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CandidateCreateManyAndReturnArgs>(args?: SelectSubset<T, CandidateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Candidate.
     * @param {CandidateDeleteArgs} args - Arguments to delete one Candidate.
     * @example
     * // Delete one Candidate
     * const Candidate = await prisma.candidate.delete({
     *   where: {
     *     // ... filter to delete one Candidate
     *   }
     * })
     * 
     */
    delete<T extends CandidateDeleteArgs>(args: SelectSubset<T, CandidateDeleteArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Candidate.
     * @param {CandidateUpdateArgs} args - Arguments to update one Candidate.
     * @example
     * // Update one Candidate
     * const candidate = await prisma.candidate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CandidateUpdateArgs>(args: SelectSubset<T, CandidateUpdateArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Candidates.
     * @param {CandidateDeleteManyArgs} args - Arguments to filter Candidates to delete.
     * @example
     * // Delete a few Candidates
     * const { count } = await prisma.candidate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CandidateDeleteManyArgs>(args?: SelectSubset<T, CandidateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Candidates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Candidates
     * const candidate = await prisma.candidate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CandidateUpdateManyArgs>(args: SelectSubset<T, CandidateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Candidates and returns the data updated in the database.
     * @param {CandidateUpdateManyAndReturnArgs} args - Arguments to update many Candidates.
     * @example
     * // Update many Candidates
     * const candidate = await prisma.candidate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Candidates and only return the `id`
     * const candidateWithIdOnly = await prisma.candidate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CandidateUpdateManyAndReturnArgs>(args: SelectSubset<T, CandidateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Candidate.
     * @param {CandidateUpsertArgs} args - Arguments to update or create a Candidate.
     * @example
     * // Update or create a Candidate
     * const candidate = await prisma.candidate.upsert({
     *   create: {
     *     // ... data to create a Candidate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Candidate we want to update
     *   }
     * })
     */
    upsert<T extends CandidateUpsertArgs>(args: SelectSubset<T, CandidateUpsertArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Candidates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateCountArgs} args - Arguments to filter Candidates to count.
     * @example
     * // Count the number of Candidates
     * const count = await prisma.candidate.count({
     *   where: {
     *     // ... the filter for the Candidates we want to count
     *   }
     * })
    **/
    count<T extends CandidateCountArgs>(
      args?: Subset<T, CandidateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandidateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Candidate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandidateAggregateArgs>(args: Subset<T, CandidateAggregateArgs>): Prisma.PrismaPromise<GetCandidateAggregateType<T>>

    /**
     * Group by Candidate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandidateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandidateGroupByArgs['orderBy'] }
        : { orderBy?: CandidateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandidateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandidateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Candidate model
   */
  readonly fields: CandidateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Candidate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandidateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applications<T extends Candidate$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Candidate$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends Candidate$notesArgs<ExtArgs> = {}>(args?: Subset<T, Candidate$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Candidate model
   */ 
  interface CandidateFieldRefs {
    readonly id: FieldRef<"Candidate", 'String'>
    readonly name: FieldRef<"Candidate", 'String'>
    readonly surname: FieldRef<"Candidate", 'String'>
    readonly email: FieldRef<"Candidate", 'String'>
    readonly phone: FieldRef<"Candidate", 'String'>
    readonly linkedin: FieldRef<"Candidate", 'String'>
    readonly github: FieldRef<"Candidate", 'String'>
    readonly createdAt: FieldRef<"Candidate", 'DateTime'>
    readonly updatedAt: FieldRef<"Candidate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Candidate findUnique
   */
  export type CandidateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter, which Candidate to fetch.
     */
    where: CandidateWhereUniqueInput
  }

  /**
   * Candidate findUniqueOrThrow
   */
  export type CandidateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter, which Candidate to fetch.
     */
    where: CandidateWhereUniqueInput
  }

  /**
   * Candidate findFirst
   */
  export type CandidateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter, which Candidate to fetch.
     */
    where?: CandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidates to fetch.
     */
    orderBy?: CandidateOrderByWithRelationInput | CandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candidates.
     */
    cursor?: CandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candidates.
     */
    distinct?: CandidateScalarFieldEnum | CandidateScalarFieldEnum[]
  }

  /**
   * Candidate findFirstOrThrow
   */
  export type CandidateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter, which Candidate to fetch.
     */
    where?: CandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidates to fetch.
     */
    orderBy?: CandidateOrderByWithRelationInput | CandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candidates.
     */
    cursor?: CandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candidates.
     */
    distinct?: CandidateScalarFieldEnum | CandidateScalarFieldEnum[]
  }

  /**
   * Candidate findMany
   */
  export type CandidateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter, which Candidates to fetch.
     */
    where?: CandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidates to fetch.
     */
    orderBy?: CandidateOrderByWithRelationInput | CandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Candidates.
     */
    cursor?: CandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidates.
     */
    skip?: number
    distinct?: CandidateScalarFieldEnum | CandidateScalarFieldEnum[]
  }

  /**
   * Candidate create
   */
  export type CandidateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * The data needed to create a Candidate.
     */
    data: XOR<CandidateCreateInput, CandidateUncheckedCreateInput>
  }

  /**
   * Candidate createMany
   */
  export type CandidateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Candidates.
     */
    data: CandidateCreateManyInput | CandidateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Candidate createManyAndReturn
   */
  export type CandidateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * The data used to create many Candidates.
     */
    data: CandidateCreateManyInput | CandidateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Candidate update
   */
  export type CandidateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * The data needed to update a Candidate.
     */
    data: XOR<CandidateUpdateInput, CandidateUncheckedUpdateInput>
    /**
     * Choose, which Candidate to update.
     */
    where: CandidateWhereUniqueInput
  }

  /**
   * Candidate updateMany
   */
  export type CandidateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Candidates.
     */
    data: XOR<CandidateUpdateManyMutationInput, CandidateUncheckedUpdateManyInput>
    /**
     * Filter which Candidates to update
     */
    where?: CandidateWhereInput
    /**
     * Limit how many Candidates to update.
     */
    limit?: number
  }

  /**
   * Candidate updateManyAndReturn
   */
  export type CandidateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * The data used to update Candidates.
     */
    data: XOR<CandidateUpdateManyMutationInput, CandidateUncheckedUpdateManyInput>
    /**
     * Filter which Candidates to update
     */
    where?: CandidateWhereInput
    /**
     * Limit how many Candidates to update.
     */
    limit?: number
  }

  /**
   * Candidate upsert
   */
  export type CandidateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * The filter to search for the Candidate to update in case it exists.
     */
    where: CandidateWhereUniqueInput
    /**
     * In case the Candidate found by the `where` argument doesn't exist, create a new Candidate with this data.
     */
    create: XOR<CandidateCreateInput, CandidateUncheckedCreateInput>
    /**
     * In case the Candidate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandidateUpdateInput, CandidateUncheckedUpdateInput>
  }

  /**
   * Candidate delete
   */
  export type CandidateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
    /**
     * Filter which Candidate to delete.
     */
    where: CandidateWhereUniqueInput
  }

  /**
   * Candidate deleteMany
   */
  export type CandidateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candidates to delete
     */
    where?: CandidateWhereInput
    /**
     * Limit how many Candidates to delete.
     */
    limit?: number
  }

  /**
   * Candidate.applications
   */
  export type Candidate$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    cursor?: JobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * Candidate.notes
   */
  export type Candidate$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateNote
     */
    select?: CandidateNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateNote
     */
    omit?: CandidateNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateNoteInclude<ExtArgs> | null
    where?: CandidateNoteWhereInput
    orderBy?: CandidateNoteOrderByWithRelationInput | CandidateNoteOrderByWithRelationInput[]
    cursor?: CandidateNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidateNoteScalarFieldEnum | CandidateNoteScalarFieldEnum[]
  }

  /**
   * Candidate without action
   */
  export type CandidateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidate
     */
    select?: CandidateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidate
     */
    omit?: CandidateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateInclude<ExtArgs> | null
  }


  /**
   * Model JobApplication
   */

  export type AggregateJobApplication = {
    _count: JobApplicationCountAggregateOutputType | null
    _avg: JobApplicationAvgAggregateOutputType | null
    _sum: JobApplicationSumAggregateOutputType | null
    _min: JobApplicationMinAggregateOutputType | null
    _max: JobApplicationMaxAggregateOutputType | null
  }

  export type JobApplicationAvgAggregateOutputType = {
    id: number | null
    jobListingId: number | null
  }

  export type JobApplicationSumAggregateOutputType = {
    id: number | null
    jobListingId: number | null
  }

  export type JobApplicationMinAggregateOutputType = {
    id: number | null
    candidateId: string | null
    resumeKey: string | null
    additionalNotes: string | null
    referralSource: string | null
    status: $Enums.ApplicationStatus | null
    jobListingId: number | null
    createdAt: Date | null
  }

  export type JobApplicationMaxAggregateOutputType = {
    id: number | null
    candidateId: string | null
    resumeKey: string | null
    additionalNotes: string | null
    referralSource: string | null
    status: $Enums.ApplicationStatus | null
    jobListingId: number | null
    createdAt: Date | null
  }

  export type JobApplicationCountAggregateOutputType = {
    id: number
    candidateId: number
    resumeKey: number
    additionalNotes: number
    referralSource: number
    status: number
    jobListingId: number
    createdAt: number
    _all: number
  }


  export type JobApplicationAvgAggregateInputType = {
    id?: true
    jobListingId?: true
  }

  export type JobApplicationSumAggregateInputType = {
    id?: true
    jobListingId?: true
  }

  export type JobApplicationMinAggregateInputType = {
    id?: true
    candidateId?: true
    resumeKey?: true
    additionalNotes?: true
    referralSource?: true
    status?: true
    jobListingId?: true
    createdAt?: true
  }

  export type JobApplicationMaxAggregateInputType = {
    id?: true
    candidateId?: true
    resumeKey?: true
    additionalNotes?: true
    referralSource?: true
    status?: true
    jobListingId?: true
    createdAt?: true
  }

  export type JobApplicationCountAggregateInputType = {
    id?: true
    candidateId?: true
    resumeKey?: true
    additionalNotes?: true
    referralSource?: true
    status?: true
    jobListingId?: true
    createdAt?: true
    _all?: true
  }

  export type JobApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplication to aggregate.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobApplications
    **/
    _count?: true | JobApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobApplicationMaxAggregateInputType
  }

  export type GetJobApplicationAggregateType<T extends JobApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateJobApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobApplication[P]>
      : GetScalarType<T[P], AggregateJobApplication[P]>
  }




  export type JobApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithAggregationInput | JobApplicationOrderByWithAggregationInput[]
    by: JobApplicationScalarFieldEnum[] | JobApplicationScalarFieldEnum
    having?: JobApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobApplicationCountAggregateInputType | true
    _avg?: JobApplicationAvgAggregateInputType
    _sum?: JobApplicationSumAggregateInputType
    _min?: JobApplicationMinAggregateInputType
    _max?: JobApplicationMaxAggregateInputType
  }

  export type JobApplicationGroupByOutputType = {
    id: number
    candidateId: string
    resumeKey: string | null
    additionalNotes: string | null
    referralSource: string | null
    status: $Enums.ApplicationStatus
    jobListingId: number
    createdAt: Date
    _count: JobApplicationCountAggregateOutputType | null
    _avg: JobApplicationAvgAggregateOutputType | null
    _sum: JobApplicationSumAggregateOutputType | null
    _min: JobApplicationMinAggregateOutputType | null
    _max: JobApplicationMaxAggregateOutputType | null
  }

  type GetJobApplicationGroupByPayload<T extends JobApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], JobApplicationGroupByOutputType[P]>
        }
      >
    >


  export type JobApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    candidateId?: boolean
    resumeKey?: boolean
    additionalNotes?: boolean
    referralSource?: boolean
    status?: boolean
    jobListingId?: boolean
    createdAt?: boolean
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    jobListing?: boolean | JobListingDefaultArgs<ExtArgs>
    history?: boolean | JobApplication$historyArgs<ExtArgs>
    cvAnalysis?: boolean | JobApplication$cvAnalysisArgs<ExtArgs>
    OnboardingProgress?: boolean | JobApplication$OnboardingProgressArgs<ExtArgs>
    OnboardingInvitation?: boolean | JobApplication$OnboardingInvitationArgs<ExtArgs>
    _count?: boolean | JobApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    candidateId?: boolean
    resumeKey?: boolean
    additionalNotes?: boolean
    referralSource?: boolean
    status?: boolean
    jobListingId?: boolean
    createdAt?: boolean
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    jobListing?: boolean | JobListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    candidateId?: boolean
    resumeKey?: boolean
    additionalNotes?: boolean
    referralSource?: boolean
    status?: boolean
    jobListingId?: boolean
    createdAt?: boolean
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    jobListing?: boolean | JobListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectScalar = {
    id?: boolean
    candidateId?: boolean
    resumeKey?: boolean
    additionalNotes?: boolean
    referralSource?: boolean
    status?: boolean
    jobListingId?: boolean
    createdAt?: boolean
  }

  export type JobApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "candidateId" | "resumeKey" | "additionalNotes" | "referralSource" | "status" | "jobListingId" | "createdAt", ExtArgs["result"]["jobApplication"]>
  export type JobApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    jobListing?: boolean | JobListingDefaultArgs<ExtArgs>
    history?: boolean | JobApplication$historyArgs<ExtArgs>
    cvAnalysis?: boolean | JobApplication$cvAnalysisArgs<ExtArgs>
    OnboardingProgress?: boolean | JobApplication$OnboardingProgressArgs<ExtArgs>
    OnboardingInvitation?: boolean | JobApplication$OnboardingInvitationArgs<ExtArgs>
    _count?: boolean | JobApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    jobListing?: boolean | JobListingDefaultArgs<ExtArgs>
  }
  export type JobApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateDefaultArgs<ExtArgs>
    jobListing?: boolean | JobListingDefaultArgs<ExtArgs>
  }

  export type $JobApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobApplication"
    objects: {
      candidate: Prisma.$CandidatePayload<ExtArgs>
      jobListing: Prisma.$JobListingPayload<ExtArgs>
      history: Prisma.$JobApplicationHistoryPayload<ExtArgs>[]
      cvAnalysis: Prisma.$CvAnalysisPayload<ExtArgs> | null
      OnboardingProgress: Prisma.$OnboardingProgressPayload<ExtArgs> | null
      OnboardingInvitation: Prisma.$OnboardingInvitationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      candidateId: string
      resumeKey: string | null
      additionalNotes: string | null
      referralSource: string | null
      status: $Enums.ApplicationStatus
      jobListingId: number
      createdAt: Date
    }, ExtArgs["result"]["jobApplication"]>
    composites: {}
  }

  type JobApplicationGetPayload<S extends boolean | null | undefined | JobApplicationDefaultArgs> = $Result.GetResult<Prisma.$JobApplicationPayload, S>

  type JobApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobApplicationCountAggregateInputType | true
    }

  export interface JobApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobApplication'], meta: { name: 'JobApplication' } }
    /**
     * Find zero or one JobApplication that matches the filter.
     * @param {JobApplicationFindUniqueArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobApplicationFindUniqueArgs>(args: SelectSubset<T, JobApplicationFindUniqueArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobApplicationFindUniqueOrThrowArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, JobApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindFirstArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobApplicationFindFirstArgs>(args?: SelectSubset<T, JobApplicationFindFirstArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindFirstOrThrowArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, JobApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobApplications
     * const jobApplications = await prisma.jobApplication.findMany()
     * 
     * // Get first 10 JobApplications
     * const jobApplications = await prisma.jobApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobApplicationWithIdOnly = await prisma.jobApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobApplicationFindManyArgs>(args?: SelectSubset<T, JobApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobApplication.
     * @param {JobApplicationCreateArgs} args - Arguments to create a JobApplication.
     * @example
     * // Create one JobApplication
     * const JobApplication = await prisma.jobApplication.create({
     *   data: {
     *     // ... data to create a JobApplication
     *   }
     * })
     * 
     */
    create<T extends JobApplicationCreateArgs>(args: SelectSubset<T, JobApplicationCreateArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobApplications.
     * @param {JobApplicationCreateManyArgs} args - Arguments to create many JobApplications.
     * @example
     * // Create many JobApplications
     * const jobApplication = await prisma.jobApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobApplicationCreateManyArgs>(args?: SelectSubset<T, JobApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobApplications and returns the data saved in the database.
     * @param {JobApplicationCreateManyAndReturnArgs} args - Arguments to create many JobApplications.
     * @example
     * // Create many JobApplications
     * const jobApplication = await prisma.jobApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobApplications and only return the `id`
     * const jobApplicationWithIdOnly = await prisma.jobApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, JobApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobApplication.
     * @param {JobApplicationDeleteArgs} args - Arguments to delete one JobApplication.
     * @example
     * // Delete one JobApplication
     * const JobApplication = await prisma.jobApplication.delete({
     *   where: {
     *     // ... filter to delete one JobApplication
     *   }
     * })
     * 
     */
    delete<T extends JobApplicationDeleteArgs>(args: SelectSubset<T, JobApplicationDeleteArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobApplication.
     * @param {JobApplicationUpdateArgs} args - Arguments to update one JobApplication.
     * @example
     * // Update one JobApplication
     * const jobApplication = await prisma.jobApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobApplicationUpdateArgs>(args: SelectSubset<T, JobApplicationUpdateArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobApplications.
     * @param {JobApplicationDeleteManyArgs} args - Arguments to filter JobApplications to delete.
     * @example
     * // Delete a few JobApplications
     * const { count } = await prisma.jobApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobApplicationDeleteManyArgs>(args?: SelectSubset<T, JobApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobApplications
     * const jobApplication = await prisma.jobApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobApplicationUpdateManyArgs>(args: SelectSubset<T, JobApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplications and returns the data updated in the database.
     * @param {JobApplicationUpdateManyAndReturnArgs} args - Arguments to update many JobApplications.
     * @example
     * // Update many JobApplications
     * const jobApplication = await prisma.jobApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobApplications and only return the `id`
     * const jobApplicationWithIdOnly = await prisma.jobApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, JobApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobApplication.
     * @param {JobApplicationUpsertArgs} args - Arguments to update or create a JobApplication.
     * @example
     * // Update or create a JobApplication
     * const jobApplication = await prisma.jobApplication.upsert({
     *   create: {
     *     // ... data to create a JobApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobApplication we want to update
     *   }
     * })
     */
    upsert<T extends JobApplicationUpsertArgs>(args: SelectSubset<T, JobApplicationUpsertArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationCountArgs} args - Arguments to filter JobApplications to count.
     * @example
     * // Count the number of JobApplications
     * const count = await prisma.jobApplication.count({
     *   where: {
     *     // ... the filter for the JobApplications we want to count
     *   }
     * })
    **/
    count<T extends JobApplicationCountArgs>(
      args?: Subset<T, JobApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobApplicationAggregateArgs>(args: Subset<T, JobApplicationAggregateArgs>): Prisma.PrismaPromise<GetJobApplicationAggregateType<T>>

    /**
     * Group by JobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobApplicationGroupByArgs['orderBy'] }
        : { orderBy?: JobApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobApplication model
   */
  readonly fields: JobApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    candidate<T extends CandidateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidateDefaultArgs<ExtArgs>>): Prisma__CandidateClient<$Result.GetResult<Prisma.$CandidatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobListing<T extends JobListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobListingDefaultArgs<ExtArgs>>): Prisma__JobListingClient<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    history<T extends JobApplication$historyArgs<ExtArgs> = {}>(args?: Subset<T, JobApplication$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cvAnalysis<T extends JobApplication$cvAnalysisArgs<ExtArgs> = {}>(args?: Subset<T, JobApplication$cvAnalysisArgs<ExtArgs>>): Prisma__CvAnalysisClient<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    OnboardingProgress<T extends JobApplication$OnboardingProgressArgs<ExtArgs> = {}>(args?: Subset<T, JobApplication$OnboardingProgressArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    OnboardingInvitation<T extends JobApplication$OnboardingInvitationArgs<ExtArgs> = {}>(args?: Subset<T, JobApplication$OnboardingInvitationArgs<ExtArgs>>): Prisma__OnboardingInvitationClient<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobApplication model
   */ 
  interface JobApplicationFieldRefs {
    readonly id: FieldRef<"JobApplication", 'Int'>
    readonly candidateId: FieldRef<"JobApplication", 'String'>
    readonly resumeKey: FieldRef<"JobApplication", 'String'>
    readonly additionalNotes: FieldRef<"JobApplication", 'String'>
    readonly referralSource: FieldRef<"JobApplication", 'String'>
    readonly status: FieldRef<"JobApplication", 'ApplicationStatus'>
    readonly jobListingId: FieldRef<"JobApplication", 'Int'>
    readonly createdAt: FieldRef<"JobApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobApplication findUnique
   */
  export type JobApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication findUniqueOrThrow
   */
  export type JobApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication findFirst
   */
  export type JobApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplications.
     */
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * JobApplication findFirstOrThrow
   */
  export type JobApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplications.
     */
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * JobApplication findMany
   */
  export type JobApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplications to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * JobApplication create
   */
  export type JobApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a JobApplication.
     */
    data: XOR<JobApplicationCreateInput, JobApplicationUncheckedCreateInput>
  }

  /**
   * JobApplication createMany
   */
  export type JobApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobApplications.
     */
    data: JobApplicationCreateManyInput | JobApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobApplication createManyAndReturn
   */
  export type JobApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many JobApplications.
     */
    data: JobApplicationCreateManyInput | JobApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobApplication update
   */
  export type JobApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a JobApplication.
     */
    data: XOR<JobApplicationUpdateInput, JobApplicationUncheckedUpdateInput>
    /**
     * Choose, which JobApplication to update.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication updateMany
   */
  export type JobApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobApplications.
     */
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyInput>
    /**
     * Filter which JobApplications to update
     */
    where?: JobApplicationWhereInput
    /**
     * Limit how many JobApplications to update.
     */
    limit?: number
  }

  /**
   * JobApplication updateManyAndReturn
   */
  export type JobApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * The data used to update JobApplications.
     */
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyInput>
    /**
     * Filter which JobApplications to update
     */
    where?: JobApplicationWhereInput
    /**
     * Limit how many JobApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobApplication upsert
   */
  export type JobApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the JobApplication to update in case it exists.
     */
    where: JobApplicationWhereUniqueInput
    /**
     * In case the JobApplication found by the `where` argument doesn't exist, create a new JobApplication with this data.
     */
    create: XOR<JobApplicationCreateInput, JobApplicationUncheckedCreateInput>
    /**
     * In case the JobApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobApplicationUpdateInput, JobApplicationUncheckedUpdateInput>
  }

  /**
   * JobApplication delete
   */
  export type JobApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter which JobApplication to delete.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication deleteMany
   */
  export type JobApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplications to delete
     */
    where?: JobApplicationWhereInput
    /**
     * Limit how many JobApplications to delete.
     */
    limit?: number
  }

  /**
   * JobApplication.history
   */
  export type JobApplication$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    where?: JobApplicationHistoryWhereInput
    orderBy?: JobApplicationHistoryOrderByWithRelationInput | JobApplicationHistoryOrderByWithRelationInput[]
    cursor?: JobApplicationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationHistoryScalarFieldEnum | JobApplicationHistoryScalarFieldEnum[]
  }

  /**
   * JobApplication.cvAnalysis
   */
  export type JobApplication$cvAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
    where?: CvAnalysisWhereInput
  }

  /**
   * JobApplication.OnboardingProgress
   */
  export type JobApplication$OnboardingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    where?: OnboardingProgressWhereInput
  }

  /**
   * JobApplication.OnboardingInvitation
   */
  export type JobApplication$OnboardingInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
    where?: OnboardingInvitationWhereInput
  }

  /**
   * JobApplication without action
   */
  export type JobApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
  }


  /**
   * Model CvAnalysis
   */

  export type AggregateCvAnalysis = {
    _count: CvAnalysisCountAggregateOutputType | null
    _avg: CvAnalysisAvgAggregateOutputType | null
    _sum: CvAnalysisSumAggregateOutputType | null
    _min: CvAnalysisMinAggregateOutputType | null
    _max: CvAnalysisMaxAggregateOutputType | null
  }

  export type CvAnalysisAvgAggregateOutputType = {
    id: number | null
    applicationId: number | null
    totalScore: number | null
    technicalScore: number | null
    experienceScore: number | null
    educationScore: number | null
    cvQualityScore: number | null
    softSkillsScore: number | null
  }

  export type CvAnalysisSumAggregateOutputType = {
    id: number | null
    applicationId: number | null
    totalScore: number | null
    technicalScore: number | null
    experienceScore: number | null
    educationScore: number | null
    cvQualityScore: number | null
    softSkillsScore: number | null
  }

  export type CvAnalysisMinAggregateOutputType = {
    id: number | null
    applicationId: number | null
    totalScore: number | null
    technicalScore: number | null
    experienceScore: number | null
    educationScore: number | null
    cvQualityScore: number | null
    softSkillsScore: number | null
    analysis: string | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CvAnalysisMaxAggregateOutputType = {
    id: number | null
    applicationId: number | null
    totalScore: number | null
    technicalScore: number | null
    experienceScore: number | null
    educationScore: number | null
    cvQualityScore: number | null
    softSkillsScore: number | null
    analysis: string | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CvAnalysisCountAggregateOutputType = {
    id: number
    applicationId: number
    totalScore: number
    technicalScore: number
    experienceScore: number
    educationScore: number
    cvQualityScore: number
    softSkillsScore: number
    analysis: number
    parsedContent: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CvAnalysisAvgAggregateInputType = {
    id?: true
    applicationId?: true
    totalScore?: true
    technicalScore?: true
    experienceScore?: true
    educationScore?: true
    cvQualityScore?: true
    softSkillsScore?: true
  }

  export type CvAnalysisSumAggregateInputType = {
    id?: true
    applicationId?: true
    totalScore?: true
    technicalScore?: true
    experienceScore?: true
    educationScore?: true
    cvQualityScore?: true
    softSkillsScore?: true
  }

  export type CvAnalysisMinAggregateInputType = {
    id?: true
    applicationId?: true
    totalScore?: true
    technicalScore?: true
    experienceScore?: true
    educationScore?: true
    cvQualityScore?: true
    softSkillsScore?: true
    analysis?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CvAnalysisMaxAggregateInputType = {
    id?: true
    applicationId?: true
    totalScore?: true
    technicalScore?: true
    experienceScore?: true
    educationScore?: true
    cvQualityScore?: true
    softSkillsScore?: true
    analysis?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CvAnalysisCountAggregateInputType = {
    id?: true
    applicationId?: true
    totalScore?: true
    technicalScore?: true
    experienceScore?: true
    educationScore?: true
    cvQualityScore?: true
    softSkillsScore?: true
    analysis?: true
    parsedContent?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CvAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CvAnalysis to aggregate.
     */
    where?: CvAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CvAnalyses to fetch.
     */
    orderBy?: CvAnalysisOrderByWithRelationInput | CvAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CvAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CvAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CvAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CvAnalyses
    **/
    _count?: true | CvAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CvAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CvAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CvAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CvAnalysisMaxAggregateInputType
  }

  export type GetCvAnalysisAggregateType<T extends CvAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateCvAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCvAnalysis[P]>
      : GetScalarType<T[P], AggregateCvAnalysis[P]>
  }




  export type CvAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CvAnalysisWhereInput
    orderBy?: CvAnalysisOrderByWithAggregationInput | CvAnalysisOrderByWithAggregationInput[]
    by: CvAnalysisScalarFieldEnum[] | CvAnalysisScalarFieldEnum
    having?: CvAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CvAnalysisCountAggregateInputType | true
    _avg?: CvAnalysisAvgAggregateInputType
    _sum?: CvAnalysisSumAggregateInputType
    _min?: CvAnalysisMinAggregateInputType
    _max?: CvAnalysisMaxAggregateInputType
  }

  export type CvAnalysisGroupByOutputType = {
    id: number
    applicationId: number
    totalScore: number | null
    technicalScore: number | null
    experienceScore: number | null
    educationScore: number | null
    cvQualityScore: number | null
    softSkillsScore: number | null
    analysis: string | null
    parsedContent: JsonValue | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: CvAnalysisCountAggregateOutputType | null
    _avg: CvAnalysisAvgAggregateOutputType | null
    _sum: CvAnalysisSumAggregateOutputType | null
    _min: CvAnalysisMinAggregateOutputType | null
    _max: CvAnalysisMaxAggregateOutputType | null
  }

  type GetCvAnalysisGroupByPayload<T extends CvAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CvAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CvAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CvAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], CvAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type CvAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    totalScore?: boolean
    technicalScore?: boolean
    experienceScore?: boolean
    educationScore?: boolean
    cvQualityScore?: boolean
    softSkillsScore?: boolean
    analysis?: boolean
    parsedContent?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cvAnalysis"]>

  export type CvAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    totalScore?: boolean
    technicalScore?: boolean
    experienceScore?: boolean
    educationScore?: boolean
    cvQualityScore?: boolean
    softSkillsScore?: boolean
    analysis?: boolean
    parsedContent?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cvAnalysis"]>

  export type CvAnalysisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    totalScore?: boolean
    technicalScore?: boolean
    experienceScore?: boolean
    educationScore?: boolean
    cvQualityScore?: boolean
    softSkillsScore?: boolean
    analysis?: boolean
    parsedContent?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cvAnalysis"]>

  export type CvAnalysisSelectScalar = {
    id?: boolean
    applicationId?: boolean
    totalScore?: boolean
    technicalScore?: boolean
    experienceScore?: boolean
    educationScore?: boolean
    cvQualityScore?: boolean
    softSkillsScore?: boolean
    analysis?: boolean
    parsedContent?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CvAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "totalScore" | "technicalScore" | "experienceScore" | "educationScore" | "cvQualityScore" | "softSkillsScore" | "analysis" | "parsedContent" | "error" | "createdAt" | "updatedAt", ExtArgs["result"]["cvAnalysis"]>
  export type CvAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }
  export type CvAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }
  export type CvAnalysisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }

  export type $CvAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CvAnalysis"
    objects: {
      application: Prisma.$JobApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicationId: number
      totalScore: number | null
      technicalScore: number | null
      experienceScore: number | null
      educationScore: number | null
      cvQualityScore: number | null
      softSkillsScore: number | null
      analysis: string | null
      parsedContent: Prisma.JsonValue | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cvAnalysis"]>
    composites: {}
  }

  type CvAnalysisGetPayload<S extends boolean | null | undefined | CvAnalysisDefaultArgs> = $Result.GetResult<Prisma.$CvAnalysisPayload, S>

  type CvAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CvAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CvAnalysisCountAggregateInputType | true
    }

  export interface CvAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CvAnalysis'], meta: { name: 'CvAnalysis' } }
    /**
     * Find zero or one CvAnalysis that matches the filter.
     * @param {CvAnalysisFindUniqueArgs} args - Arguments to find a CvAnalysis
     * @example
     * // Get one CvAnalysis
     * const cvAnalysis = await prisma.cvAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CvAnalysisFindUniqueArgs>(args: SelectSubset<T, CvAnalysisFindUniqueArgs<ExtArgs>>): Prisma__CvAnalysisClient<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CvAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CvAnalysisFindUniqueOrThrowArgs} args - Arguments to find a CvAnalysis
     * @example
     * // Get one CvAnalysis
     * const cvAnalysis = await prisma.cvAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CvAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, CvAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CvAnalysisClient<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CvAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CvAnalysisFindFirstArgs} args - Arguments to find a CvAnalysis
     * @example
     * // Get one CvAnalysis
     * const cvAnalysis = await prisma.cvAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CvAnalysisFindFirstArgs>(args?: SelectSubset<T, CvAnalysisFindFirstArgs<ExtArgs>>): Prisma__CvAnalysisClient<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CvAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CvAnalysisFindFirstOrThrowArgs} args - Arguments to find a CvAnalysis
     * @example
     * // Get one CvAnalysis
     * const cvAnalysis = await prisma.cvAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CvAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, CvAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__CvAnalysisClient<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CvAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CvAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CvAnalyses
     * const cvAnalyses = await prisma.cvAnalysis.findMany()
     * 
     * // Get first 10 CvAnalyses
     * const cvAnalyses = await prisma.cvAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cvAnalysisWithIdOnly = await prisma.cvAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CvAnalysisFindManyArgs>(args?: SelectSubset<T, CvAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CvAnalysis.
     * @param {CvAnalysisCreateArgs} args - Arguments to create a CvAnalysis.
     * @example
     * // Create one CvAnalysis
     * const CvAnalysis = await prisma.cvAnalysis.create({
     *   data: {
     *     // ... data to create a CvAnalysis
     *   }
     * })
     * 
     */
    create<T extends CvAnalysisCreateArgs>(args: SelectSubset<T, CvAnalysisCreateArgs<ExtArgs>>): Prisma__CvAnalysisClient<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CvAnalyses.
     * @param {CvAnalysisCreateManyArgs} args - Arguments to create many CvAnalyses.
     * @example
     * // Create many CvAnalyses
     * const cvAnalysis = await prisma.cvAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CvAnalysisCreateManyArgs>(args?: SelectSubset<T, CvAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CvAnalyses and returns the data saved in the database.
     * @param {CvAnalysisCreateManyAndReturnArgs} args - Arguments to create many CvAnalyses.
     * @example
     * // Create many CvAnalyses
     * const cvAnalysis = await prisma.cvAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CvAnalyses and only return the `id`
     * const cvAnalysisWithIdOnly = await prisma.cvAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CvAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, CvAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CvAnalysis.
     * @param {CvAnalysisDeleteArgs} args - Arguments to delete one CvAnalysis.
     * @example
     * // Delete one CvAnalysis
     * const CvAnalysis = await prisma.cvAnalysis.delete({
     *   where: {
     *     // ... filter to delete one CvAnalysis
     *   }
     * })
     * 
     */
    delete<T extends CvAnalysisDeleteArgs>(args: SelectSubset<T, CvAnalysisDeleteArgs<ExtArgs>>): Prisma__CvAnalysisClient<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CvAnalysis.
     * @param {CvAnalysisUpdateArgs} args - Arguments to update one CvAnalysis.
     * @example
     * // Update one CvAnalysis
     * const cvAnalysis = await prisma.cvAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CvAnalysisUpdateArgs>(args: SelectSubset<T, CvAnalysisUpdateArgs<ExtArgs>>): Prisma__CvAnalysisClient<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CvAnalyses.
     * @param {CvAnalysisDeleteManyArgs} args - Arguments to filter CvAnalyses to delete.
     * @example
     * // Delete a few CvAnalyses
     * const { count } = await prisma.cvAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CvAnalysisDeleteManyArgs>(args?: SelectSubset<T, CvAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CvAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CvAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CvAnalyses
     * const cvAnalysis = await prisma.cvAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CvAnalysisUpdateManyArgs>(args: SelectSubset<T, CvAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CvAnalyses and returns the data updated in the database.
     * @param {CvAnalysisUpdateManyAndReturnArgs} args - Arguments to update many CvAnalyses.
     * @example
     * // Update many CvAnalyses
     * const cvAnalysis = await prisma.cvAnalysis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CvAnalyses and only return the `id`
     * const cvAnalysisWithIdOnly = await prisma.cvAnalysis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CvAnalysisUpdateManyAndReturnArgs>(args: SelectSubset<T, CvAnalysisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CvAnalysis.
     * @param {CvAnalysisUpsertArgs} args - Arguments to update or create a CvAnalysis.
     * @example
     * // Update or create a CvAnalysis
     * const cvAnalysis = await prisma.cvAnalysis.upsert({
     *   create: {
     *     // ... data to create a CvAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CvAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends CvAnalysisUpsertArgs>(args: SelectSubset<T, CvAnalysisUpsertArgs<ExtArgs>>): Prisma__CvAnalysisClient<$Result.GetResult<Prisma.$CvAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CvAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CvAnalysisCountArgs} args - Arguments to filter CvAnalyses to count.
     * @example
     * // Count the number of CvAnalyses
     * const count = await prisma.cvAnalysis.count({
     *   where: {
     *     // ... the filter for the CvAnalyses we want to count
     *   }
     * })
    **/
    count<T extends CvAnalysisCountArgs>(
      args?: Subset<T, CvAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CvAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CvAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CvAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CvAnalysisAggregateArgs>(args: Subset<T, CvAnalysisAggregateArgs>): Prisma.PrismaPromise<GetCvAnalysisAggregateType<T>>

    /**
     * Group by CvAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CvAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CvAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CvAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: CvAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CvAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCvAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CvAnalysis model
   */
  readonly fields: CvAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CvAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CvAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends JobApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobApplicationDefaultArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CvAnalysis model
   */ 
  interface CvAnalysisFieldRefs {
    readonly id: FieldRef<"CvAnalysis", 'Int'>
    readonly applicationId: FieldRef<"CvAnalysis", 'Int'>
    readonly totalScore: FieldRef<"CvAnalysis", 'Float'>
    readonly technicalScore: FieldRef<"CvAnalysis", 'Float'>
    readonly experienceScore: FieldRef<"CvAnalysis", 'Float'>
    readonly educationScore: FieldRef<"CvAnalysis", 'Float'>
    readonly cvQualityScore: FieldRef<"CvAnalysis", 'Float'>
    readonly softSkillsScore: FieldRef<"CvAnalysis", 'Float'>
    readonly analysis: FieldRef<"CvAnalysis", 'String'>
    readonly parsedContent: FieldRef<"CvAnalysis", 'Json'>
    readonly error: FieldRef<"CvAnalysis", 'String'>
    readonly createdAt: FieldRef<"CvAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"CvAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CvAnalysis findUnique
   */
  export type CvAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which CvAnalysis to fetch.
     */
    where: CvAnalysisWhereUniqueInput
  }

  /**
   * CvAnalysis findUniqueOrThrow
   */
  export type CvAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which CvAnalysis to fetch.
     */
    where: CvAnalysisWhereUniqueInput
  }

  /**
   * CvAnalysis findFirst
   */
  export type CvAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which CvAnalysis to fetch.
     */
    where?: CvAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CvAnalyses to fetch.
     */
    orderBy?: CvAnalysisOrderByWithRelationInput | CvAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CvAnalyses.
     */
    cursor?: CvAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CvAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CvAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CvAnalyses.
     */
    distinct?: CvAnalysisScalarFieldEnum | CvAnalysisScalarFieldEnum[]
  }

  /**
   * CvAnalysis findFirstOrThrow
   */
  export type CvAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which CvAnalysis to fetch.
     */
    where?: CvAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CvAnalyses to fetch.
     */
    orderBy?: CvAnalysisOrderByWithRelationInput | CvAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CvAnalyses.
     */
    cursor?: CvAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CvAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CvAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CvAnalyses.
     */
    distinct?: CvAnalysisScalarFieldEnum | CvAnalysisScalarFieldEnum[]
  }

  /**
   * CvAnalysis findMany
   */
  export type CvAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which CvAnalyses to fetch.
     */
    where?: CvAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CvAnalyses to fetch.
     */
    orderBy?: CvAnalysisOrderByWithRelationInput | CvAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CvAnalyses.
     */
    cursor?: CvAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CvAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CvAnalyses.
     */
    skip?: number
    distinct?: CvAnalysisScalarFieldEnum | CvAnalysisScalarFieldEnum[]
  }

  /**
   * CvAnalysis create
   */
  export type CvAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a CvAnalysis.
     */
    data: XOR<CvAnalysisCreateInput, CvAnalysisUncheckedCreateInput>
  }

  /**
   * CvAnalysis createMany
   */
  export type CvAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CvAnalyses.
     */
    data: CvAnalysisCreateManyInput | CvAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CvAnalysis createManyAndReturn
   */
  export type CvAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many CvAnalyses.
     */
    data: CvAnalysisCreateManyInput | CvAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CvAnalysis update
   */
  export type CvAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a CvAnalysis.
     */
    data: XOR<CvAnalysisUpdateInput, CvAnalysisUncheckedUpdateInput>
    /**
     * Choose, which CvAnalysis to update.
     */
    where: CvAnalysisWhereUniqueInput
  }

  /**
   * CvAnalysis updateMany
   */
  export type CvAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CvAnalyses.
     */
    data: XOR<CvAnalysisUpdateManyMutationInput, CvAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which CvAnalyses to update
     */
    where?: CvAnalysisWhereInput
    /**
     * Limit how many CvAnalyses to update.
     */
    limit?: number
  }

  /**
   * CvAnalysis updateManyAndReturn
   */
  export type CvAnalysisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * The data used to update CvAnalyses.
     */
    data: XOR<CvAnalysisUpdateManyMutationInput, CvAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which CvAnalyses to update
     */
    where?: CvAnalysisWhereInput
    /**
     * Limit how many CvAnalyses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CvAnalysis upsert
   */
  export type CvAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the CvAnalysis to update in case it exists.
     */
    where: CvAnalysisWhereUniqueInput
    /**
     * In case the CvAnalysis found by the `where` argument doesn't exist, create a new CvAnalysis with this data.
     */
    create: XOR<CvAnalysisCreateInput, CvAnalysisUncheckedCreateInput>
    /**
     * In case the CvAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CvAnalysisUpdateInput, CvAnalysisUncheckedUpdateInput>
  }

  /**
   * CvAnalysis delete
   */
  export type CvAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
    /**
     * Filter which CvAnalysis to delete.
     */
    where: CvAnalysisWhereUniqueInput
  }

  /**
   * CvAnalysis deleteMany
   */
  export type CvAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CvAnalyses to delete
     */
    where?: CvAnalysisWhereInput
    /**
     * Limit how many CvAnalyses to delete.
     */
    limit?: number
  }

  /**
   * CvAnalysis without action
   */
  export type CvAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvAnalysis
     */
    select?: CvAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CvAnalysis
     */
    omit?: CvAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CvAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model JobApplicationHistory
   */

  export type AggregateJobApplicationHistory = {
    _count: JobApplicationHistoryCountAggregateOutputType | null
    _avg: JobApplicationHistoryAvgAggregateOutputType | null
    _sum: JobApplicationHistorySumAggregateOutputType | null
    _min: JobApplicationHistoryMinAggregateOutputType | null
    _max: JobApplicationHistoryMaxAggregateOutputType | null
  }

  export type JobApplicationHistoryAvgAggregateOutputType = {
    id: number | null
    applicationId: number | null
  }

  export type JobApplicationHistorySumAggregateOutputType = {
    id: number | null
    applicationId: number | null
  }

  export type JobApplicationHistoryMinAggregateOutputType = {
    id: number | null
    applicationId: number | null
    status: $Enums.ApplicationStatus | null
    comment: string | null
    createdAt: Date | null
    changedByUserId: string | null
  }

  export type JobApplicationHistoryMaxAggregateOutputType = {
    id: number | null
    applicationId: number | null
    status: $Enums.ApplicationStatus | null
    comment: string | null
    createdAt: Date | null
    changedByUserId: string | null
  }

  export type JobApplicationHistoryCountAggregateOutputType = {
    id: number
    applicationId: number
    status: number
    comment: number
    createdAt: number
    changedByUserId: number
    _all: number
  }


  export type JobApplicationHistoryAvgAggregateInputType = {
    id?: true
    applicationId?: true
  }

  export type JobApplicationHistorySumAggregateInputType = {
    id?: true
    applicationId?: true
  }

  export type JobApplicationHistoryMinAggregateInputType = {
    id?: true
    applicationId?: true
    status?: true
    comment?: true
    createdAt?: true
    changedByUserId?: true
  }

  export type JobApplicationHistoryMaxAggregateInputType = {
    id?: true
    applicationId?: true
    status?: true
    comment?: true
    createdAt?: true
    changedByUserId?: true
  }

  export type JobApplicationHistoryCountAggregateInputType = {
    id?: true
    applicationId?: true
    status?: true
    comment?: true
    createdAt?: true
    changedByUserId?: true
    _all?: true
  }

  export type JobApplicationHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplicationHistory to aggregate.
     */
    where?: JobApplicationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplicationHistories to fetch.
     */
    orderBy?: JobApplicationHistoryOrderByWithRelationInput | JobApplicationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobApplicationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplicationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplicationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobApplicationHistories
    **/
    _count?: true | JobApplicationHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobApplicationHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobApplicationHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobApplicationHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobApplicationHistoryMaxAggregateInputType
  }

  export type GetJobApplicationHistoryAggregateType<T extends JobApplicationHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateJobApplicationHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobApplicationHistory[P]>
      : GetScalarType<T[P], AggregateJobApplicationHistory[P]>
  }




  export type JobApplicationHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationHistoryWhereInput
    orderBy?: JobApplicationHistoryOrderByWithAggregationInput | JobApplicationHistoryOrderByWithAggregationInput[]
    by: JobApplicationHistoryScalarFieldEnum[] | JobApplicationHistoryScalarFieldEnum
    having?: JobApplicationHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobApplicationHistoryCountAggregateInputType | true
    _avg?: JobApplicationHistoryAvgAggregateInputType
    _sum?: JobApplicationHistorySumAggregateInputType
    _min?: JobApplicationHistoryMinAggregateInputType
    _max?: JobApplicationHistoryMaxAggregateInputType
  }

  export type JobApplicationHistoryGroupByOutputType = {
    id: number
    applicationId: number
    status: $Enums.ApplicationStatus
    comment: string | null
    createdAt: Date
    changedByUserId: string | null
    _count: JobApplicationHistoryCountAggregateOutputType | null
    _avg: JobApplicationHistoryAvgAggregateOutputType | null
    _sum: JobApplicationHistorySumAggregateOutputType | null
    _min: JobApplicationHistoryMinAggregateOutputType | null
    _max: JobApplicationHistoryMaxAggregateOutputType | null
  }

  type GetJobApplicationHistoryGroupByPayload<T extends JobApplicationHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobApplicationHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobApplicationHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobApplicationHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], JobApplicationHistoryGroupByOutputType[P]>
        }
      >
    >


  export type JobApplicationHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    changedByUserId?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    changedBy?: boolean | JobApplicationHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplicationHistory"]>

  export type JobApplicationHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    changedByUserId?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    changedBy?: boolean | JobApplicationHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplicationHistory"]>

  export type JobApplicationHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    changedByUserId?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    changedBy?: boolean | JobApplicationHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplicationHistory"]>

  export type JobApplicationHistorySelectScalar = {
    id?: boolean
    applicationId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    changedByUserId?: boolean
  }

  export type JobApplicationHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "status" | "comment" | "createdAt" | "changedByUserId", ExtArgs["result"]["jobApplicationHistory"]>
  export type JobApplicationHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    changedBy?: boolean | JobApplicationHistory$changedByArgs<ExtArgs>
  }
  export type JobApplicationHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    changedBy?: boolean | JobApplicationHistory$changedByArgs<ExtArgs>
  }
  export type JobApplicationHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    changedBy?: boolean | JobApplicationHistory$changedByArgs<ExtArgs>
  }

  export type $JobApplicationHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobApplicationHistory"
    objects: {
      application: Prisma.$JobApplicationPayload<ExtArgs>
      changedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicationId: number
      status: $Enums.ApplicationStatus
      comment: string | null
      createdAt: Date
      changedByUserId: string | null
    }, ExtArgs["result"]["jobApplicationHistory"]>
    composites: {}
  }

  type JobApplicationHistoryGetPayload<S extends boolean | null | undefined | JobApplicationHistoryDefaultArgs> = $Result.GetResult<Prisma.$JobApplicationHistoryPayload, S>

  type JobApplicationHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobApplicationHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobApplicationHistoryCountAggregateInputType | true
    }

  export interface JobApplicationHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobApplicationHistory'], meta: { name: 'JobApplicationHistory' } }
    /**
     * Find zero or one JobApplicationHistory that matches the filter.
     * @param {JobApplicationHistoryFindUniqueArgs} args - Arguments to find a JobApplicationHistory
     * @example
     * // Get one JobApplicationHistory
     * const jobApplicationHistory = await prisma.jobApplicationHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobApplicationHistoryFindUniqueArgs>(args: SelectSubset<T, JobApplicationHistoryFindUniqueArgs<ExtArgs>>): Prisma__JobApplicationHistoryClient<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobApplicationHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobApplicationHistoryFindUniqueOrThrowArgs} args - Arguments to find a JobApplicationHistory
     * @example
     * // Get one JobApplicationHistory
     * const jobApplicationHistory = await prisma.jobApplicationHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobApplicationHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, JobApplicationHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobApplicationHistoryClient<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobApplicationHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationHistoryFindFirstArgs} args - Arguments to find a JobApplicationHistory
     * @example
     * // Get one JobApplicationHistory
     * const jobApplicationHistory = await prisma.jobApplicationHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobApplicationHistoryFindFirstArgs>(args?: SelectSubset<T, JobApplicationHistoryFindFirstArgs<ExtArgs>>): Prisma__JobApplicationHistoryClient<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobApplicationHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationHistoryFindFirstOrThrowArgs} args - Arguments to find a JobApplicationHistory
     * @example
     * // Get one JobApplicationHistory
     * const jobApplicationHistory = await prisma.jobApplicationHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobApplicationHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, JobApplicationHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobApplicationHistoryClient<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobApplicationHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobApplicationHistories
     * const jobApplicationHistories = await prisma.jobApplicationHistory.findMany()
     * 
     * // Get first 10 JobApplicationHistories
     * const jobApplicationHistories = await prisma.jobApplicationHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobApplicationHistoryWithIdOnly = await prisma.jobApplicationHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobApplicationHistoryFindManyArgs>(args?: SelectSubset<T, JobApplicationHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobApplicationHistory.
     * @param {JobApplicationHistoryCreateArgs} args - Arguments to create a JobApplicationHistory.
     * @example
     * // Create one JobApplicationHistory
     * const JobApplicationHistory = await prisma.jobApplicationHistory.create({
     *   data: {
     *     // ... data to create a JobApplicationHistory
     *   }
     * })
     * 
     */
    create<T extends JobApplicationHistoryCreateArgs>(args: SelectSubset<T, JobApplicationHistoryCreateArgs<ExtArgs>>): Prisma__JobApplicationHistoryClient<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobApplicationHistories.
     * @param {JobApplicationHistoryCreateManyArgs} args - Arguments to create many JobApplicationHistories.
     * @example
     * // Create many JobApplicationHistories
     * const jobApplicationHistory = await prisma.jobApplicationHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobApplicationHistoryCreateManyArgs>(args?: SelectSubset<T, JobApplicationHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobApplicationHistories and returns the data saved in the database.
     * @param {JobApplicationHistoryCreateManyAndReturnArgs} args - Arguments to create many JobApplicationHistories.
     * @example
     * // Create many JobApplicationHistories
     * const jobApplicationHistory = await prisma.jobApplicationHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobApplicationHistories and only return the `id`
     * const jobApplicationHistoryWithIdOnly = await prisma.jobApplicationHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobApplicationHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, JobApplicationHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobApplicationHistory.
     * @param {JobApplicationHistoryDeleteArgs} args - Arguments to delete one JobApplicationHistory.
     * @example
     * // Delete one JobApplicationHistory
     * const JobApplicationHistory = await prisma.jobApplicationHistory.delete({
     *   where: {
     *     // ... filter to delete one JobApplicationHistory
     *   }
     * })
     * 
     */
    delete<T extends JobApplicationHistoryDeleteArgs>(args: SelectSubset<T, JobApplicationHistoryDeleteArgs<ExtArgs>>): Prisma__JobApplicationHistoryClient<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobApplicationHistory.
     * @param {JobApplicationHistoryUpdateArgs} args - Arguments to update one JobApplicationHistory.
     * @example
     * // Update one JobApplicationHistory
     * const jobApplicationHistory = await prisma.jobApplicationHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobApplicationHistoryUpdateArgs>(args: SelectSubset<T, JobApplicationHistoryUpdateArgs<ExtArgs>>): Prisma__JobApplicationHistoryClient<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobApplicationHistories.
     * @param {JobApplicationHistoryDeleteManyArgs} args - Arguments to filter JobApplicationHistories to delete.
     * @example
     * // Delete a few JobApplicationHistories
     * const { count } = await prisma.jobApplicationHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobApplicationHistoryDeleteManyArgs>(args?: SelectSubset<T, JobApplicationHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplicationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobApplicationHistories
     * const jobApplicationHistory = await prisma.jobApplicationHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobApplicationHistoryUpdateManyArgs>(args: SelectSubset<T, JobApplicationHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplicationHistories and returns the data updated in the database.
     * @param {JobApplicationHistoryUpdateManyAndReturnArgs} args - Arguments to update many JobApplicationHistories.
     * @example
     * // Update many JobApplicationHistories
     * const jobApplicationHistory = await prisma.jobApplicationHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobApplicationHistories and only return the `id`
     * const jobApplicationHistoryWithIdOnly = await prisma.jobApplicationHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobApplicationHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, JobApplicationHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobApplicationHistory.
     * @param {JobApplicationHistoryUpsertArgs} args - Arguments to update or create a JobApplicationHistory.
     * @example
     * // Update or create a JobApplicationHistory
     * const jobApplicationHistory = await prisma.jobApplicationHistory.upsert({
     *   create: {
     *     // ... data to create a JobApplicationHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobApplicationHistory we want to update
     *   }
     * })
     */
    upsert<T extends JobApplicationHistoryUpsertArgs>(args: SelectSubset<T, JobApplicationHistoryUpsertArgs<ExtArgs>>): Prisma__JobApplicationHistoryClient<$Result.GetResult<Prisma.$JobApplicationHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobApplicationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationHistoryCountArgs} args - Arguments to filter JobApplicationHistories to count.
     * @example
     * // Count the number of JobApplicationHistories
     * const count = await prisma.jobApplicationHistory.count({
     *   where: {
     *     // ... the filter for the JobApplicationHistories we want to count
     *   }
     * })
    **/
    count<T extends JobApplicationHistoryCountArgs>(
      args?: Subset<T, JobApplicationHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobApplicationHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobApplicationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobApplicationHistoryAggregateArgs>(args: Subset<T, JobApplicationHistoryAggregateArgs>): Prisma.PrismaPromise<GetJobApplicationHistoryAggregateType<T>>

    /**
     * Group by JobApplicationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobApplicationHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobApplicationHistoryGroupByArgs['orderBy'] }
        : { orderBy?: JobApplicationHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobApplicationHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobApplicationHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobApplicationHistory model
   */
  readonly fields: JobApplicationHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobApplicationHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobApplicationHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends JobApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobApplicationDefaultArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    changedBy<T extends JobApplicationHistory$changedByArgs<ExtArgs> = {}>(args?: Subset<T, JobApplicationHistory$changedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobApplicationHistory model
   */ 
  interface JobApplicationHistoryFieldRefs {
    readonly id: FieldRef<"JobApplicationHistory", 'Int'>
    readonly applicationId: FieldRef<"JobApplicationHistory", 'Int'>
    readonly status: FieldRef<"JobApplicationHistory", 'ApplicationStatus'>
    readonly comment: FieldRef<"JobApplicationHistory", 'String'>
    readonly createdAt: FieldRef<"JobApplicationHistory", 'DateTime'>
    readonly changedByUserId: FieldRef<"JobApplicationHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobApplicationHistory findUnique
   */
  export type JobApplicationHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which JobApplicationHistory to fetch.
     */
    where: JobApplicationHistoryWhereUniqueInput
  }

  /**
   * JobApplicationHistory findUniqueOrThrow
   */
  export type JobApplicationHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which JobApplicationHistory to fetch.
     */
    where: JobApplicationHistoryWhereUniqueInput
  }

  /**
   * JobApplicationHistory findFirst
   */
  export type JobApplicationHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which JobApplicationHistory to fetch.
     */
    where?: JobApplicationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplicationHistories to fetch.
     */
    orderBy?: JobApplicationHistoryOrderByWithRelationInput | JobApplicationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplicationHistories.
     */
    cursor?: JobApplicationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplicationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplicationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplicationHistories.
     */
    distinct?: JobApplicationHistoryScalarFieldEnum | JobApplicationHistoryScalarFieldEnum[]
  }

  /**
   * JobApplicationHistory findFirstOrThrow
   */
  export type JobApplicationHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which JobApplicationHistory to fetch.
     */
    where?: JobApplicationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplicationHistories to fetch.
     */
    orderBy?: JobApplicationHistoryOrderByWithRelationInput | JobApplicationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplicationHistories.
     */
    cursor?: JobApplicationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplicationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplicationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplicationHistories.
     */
    distinct?: JobApplicationHistoryScalarFieldEnum | JobApplicationHistoryScalarFieldEnum[]
  }

  /**
   * JobApplicationHistory findMany
   */
  export type JobApplicationHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which JobApplicationHistories to fetch.
     */
    where?: JobApplicationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplicationHistories to fetch.
     */
    orderBy?: JobApplicationHistoryOrderByWithRelationInput | JobApplicationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobApplicationHistories.
     */
    cursor?: JobApplicationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplicationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplicationHistories.
     */
    skip?: number
    distinct?: JobApplicationHistoryScalarFieldEnum | JobApplicationHistoryScalarFieldEnum[]
  }

  /**
   * JobApplicationHistory create
   */
  export type JobApplicationHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a JobApplicationHistory.
     */
    data: XOR<JobApplicationHistoryCreateInput, JobApplicationHistoryUncheckedCreateInput>
  }

  /**
   * JobApplicationHistory createMany
   */
  export type JobApplicationHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobApplicationHistories.
     */
    data: JobApplicationHistoryCreateManyInput | JobApplicationHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobApplicationHistory createManyAndReturn
   */
  export type JobApplicationHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many JobApplicationHistories.
     */
    data: JobApplicationHistoryCreateManyInput | JobApplicationHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobApplicationHistory update
   */
  export type JobApplicationHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a JobApplicationHistory.
     */
    data: XOR<JobApplicationHistoryUpdateInput, JobApplicationHistoryUncheckedUpdateInput>
    /**
     * Choose, which JobApplicationHistory to update.
     */
    where: JobApplicationHistoryWhereUniqueInput
  }

  /**
   * JobApplicationHistory updateMany
   */
  export type JobApplicationHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobApplicationHistories.
     */
    data: XOR<JobApplicationHistoryUpdateManyMutationInput, JobApplicationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which JobApplicationHistories to update
     */
    where?: JobApplicationHistoryWhereInput
    /**
     * Limit how many JobApplicationHistories to update.
     */
    limit?: number
  }

  /**
   * JobApplicationHistory updateManyAndReturn
   */
  export type JobApplicationHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * The data used to update JobApplicationHistories.
     */
    data: XOR<JobApplicationHistoryUpdateManyMutationInput, JobApplicationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which JobApplicationHistories to update
     */
    where?: JobApplicationHistoryWhereInput
    /**
     * Limit how many JobApplicationHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobApplicationHistory upsert
   */
  export type JobApplicationHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the JobApplicationHistory to update in case it exists.
     */
    where: JobApplicationHistoryWhereUniqueInput
    /**
     * In case the JobApplicationHistory found by the `where` argument doesn't exist, create a new JobApplicationHistory with this data.
     */
    create: XOR<JobApplicationHistoryCreateInput, JobApplicationHistoryUncheckedCreateInput>
    /**
     * In case the JobApplicationHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobApplicationHistoryUpdateInput, JobApplicationHistoryUncheckedUpdateInput>
  }

  /**
   * JobApplicationHistory delete
   */
  export type JobApplicationHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
    /**
     * Filter which JobApplicationHistory to delete.
     */
    where: JobApplicationHistoryWhereUniqueInput
  }

  /**
   * JobApplicationHistory deleteMany
   */
  export type JobApplicationHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplicationHistories to delete
     */
    where?: JobApplicationHistoryWhereInput
    /**
     * Limit how many JobApplicationHistories to delete.
     */
    limit?: number
  }

  /**
   * JobApplicationHistory.changedBy
   */
  export type JobApplicationHistory$changedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * JobApplicationHistory without action
   */
  export type JobApplicationHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationHistory
     */
    select?: JobApplicationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplicationHistory
     */
    omit?: JobApplicationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PersonalInfo
   */

  export type AggregatePersonalInfo = {
    _count: PersonalInfoCountAggregateOutputType | null
    _avg: PersonalInfoAvgAggregateOutputType | null
    _sum: PersonalInfoSumAggregateOutputType | null
    _min: PersonalInfoMinAggregateOutputType | null
    _max: PersonalInfoMaxAggregateOutputType | null
  }

  export type PersonalInfoAvgAggregateOutputType = {
    id: number | null
    numberOfChildren: number | null
    graduationYear: number | null
  }

  export type PersonalInfoSumAggregateOutputType = {
    id: number | null
    numberOfChildren: number | null
    graduationYear: number | null
  }

  export type PersonalInfoMinAggregateOutputType = {
    id: number | null
    userId: string | null
    amka: string | null
    afm: string | null
    doy: string | null
    middleName: string | null
    birthDate: Date | null
    birthPlace: string | null
    maritalStatus: $Enums.MaritalStatus | null
    numberOfChildren: number | null
    citizenship: string | null
    nationality: string | null
    gender: $Enums.Gender | null
    createdAt: Date | null
    updatedAt: Date | null
    educationLevel: $Enums.EducationLevel | null
    educationTitle: string | null
    educationInstitution: string | null
    graduationYear: number | null
  }

  export type PersonalInfoMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    amka: string | null
    afm: string | null
    doy: string | null
    middleName: string | null
    birthDate: Date | null
    birthPlace: string | null
    maritalStatus: $Enums.MaritalStatus | null
    numberOfChildren: number | null
    citizenship: string | null
    nationality: string | null
    gender: $Enums.Gender | null
    createdAt: Date | null
    updatedAt: Date | null
    educationLevel: $Enums.EducationLevel | null
    educationTitle: string | null
    educationInstitution: string | null
    graduationYear: number | null
  }

  export type PersonalInfoCountAggregateOutputType = {
    id: number
    userId: number
    amka: number
    afm: number
    doy: number
    middleName: number
    birthDate: number
    birthPlace: number
    maritalStatus: number
    numberOfChildren: number
    citizenship: number
    nationality: number
    gender: number
    createdAt: number
    updatedAt: number
    educationLevel: number
    educationTitle: number
    educationInstitution: number
    graduationYear: number
    _all: number
  }


  export type PersonalInfoAvgAggregateInputType = {
    id?: true
    numberOfChildren?: true
    graduationYear?: true
  }

  export type PersonalInfoSumAggregateInputType = {
    id?: true
    numberOfChildren?: true
    graduationYear?: true
  }

  export type PersonalInfoMinAggregateInputType = {
    id?: true
    userId?: true
    amka?: true
    afm?: true
    doy?: true
    middleName?: true
    birthDate?: true
    birthPlace?: true
    maritalStatus?: true
    numberOfChildren?: true
    citizenship?: true
    nationality?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    educationLevel?: true
    educationTitle?: true
    educationInstitution?: true
    graduationYear?: true
  }

  export type PersonalInfoMaxAggregateInputType = {
    id?: true
    userId?: true
    amka?: true
    afm?: true
    doy?: true
    middleName?: true
    birthDate?: true
    birthPlace?: true
    maritalStatus?: true
    numberOfChildren?: true
    citizenship?: true
    nationality?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    educationLevel?: true
    educationTitle?: true
    educationInstitution?: true
    graduationYear?: true
  }

  export type PersonalInfoCountAggregateInputType = {
    id?: true
    userId?: true
    amka?: true
    afm?: true
    doy?: true
    middleName?: true
    birthDate?: true
    birthPlace?: true
    maritalStatus?: true
    numberOfChildren?: true
    citizenship?: true
    nationality?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    educationLevel?: true
    educationTitle?: true
    educationInstitution?: true
    graduationYear?: true
    _all?: true
  }

  export type PersonalInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalInfo to aggregate.
     */
    where?: PersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalInfos to fetch.
     */
    orderBy?: PersonalInfoOrderByWithRelationInput | PersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalInfos
    **/
    _count?: true | PersonalInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonalInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonalInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalInfoMaxAggregateInputType
  }

  export type GetPersonalInfoAggregateType<T extends PersonalInfoAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalInfo[P]>
      : GetScalarType<T[P], AggregatePersonalInfo[P]>
  }




  export type PersonalInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalInfoWhereInput
    orderBy?: PersonalInfoOrderByWithAggregationInput | PersonalInfoOrderByWithAggregationInput[]
    by: PersonalInfoScalarFieldEnum[] | PersonalInfoScalarFieldEnum
    having?: PersonalInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalInfoCountAggregateInputType | true
    _avg?: PersonalInfoAvgAggregateInputType
    _sum?: PersonalInfoSumAggregateInputType
    _min?: PersonalInfoMinAggregateInputType
    _max?: PersonalInfoMaxAggregateInputType
  }

  export type PersonalInfoGroupByOutputType = {
    id: number
    userId: string
    amka: string | null
    afm: string | null
    doy: string | null
    middleName: string | null
    birthDate: Date
    birthPlace: string
    maritalStatus: $Enums.MaritalStatus
    numberOfChildren: number
    citizenship: string | null
    nationality: string | null
    gender: $Enums.Gender | null
    createdAt: Date
    updatedAt: Date
    educationLevel: $Enums.EducationLevel | null
    educationTitle: string | null
    educationInstitution: string | null
    graduationYear: number | null
    _count: PersonalInfoCountAggregateOutputType | null
    _avg: PersonalInfoAvgAggregateOutputType | null
    _sum: PersonalInfoSumAggregateOutputType | null
    _min: PersonalInfoMinAggregateOutputType | null
    _max: PersonalInfoMaxAggregateOutputType | null
  }

  type GetPersonalInfoGroupByPayload<T extends PersonalInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalInfoGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalInfoGroupByOutputType[P]>
        }
      >
    >


  export type PersonalInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amka?: boolean
    afm?: boolean
    doy?: boolean
    middleName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    maritalStatus?: boolean
    numberOfChildren?: boolean
    citizenship?: boolean
    nationality?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    educationLevel?: boolean
    educationTitle?: boolean
    educationInstitution?: boolean
    graduationYear?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    identificationDocuments?: boolean | PersonalInfo$identificationDocumentsArgs<ExtArgs>
    addresses?: boolean | PersonalInfo$addressesArgs<ExtArgs>
    bankAccounts?: boolean | PersonalInfo$bankAccountsArgs<ExtArgs>
    languageSkills?: boolean | PersonalInfo$languageSkillsArgs<ExtArgs>
    _count?: boolean | PersonalInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalInfo"]>

  export type PersonalInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amka?: boolean
    afm?: boolean
    doy?: boolean
    middleName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    maritalStatus?: boolean
    numberOfChildren?: boolean
    citizenship?: boolean
    nationality?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    educationLevel?: boolean
    educationTitle?: boolean
    educationInstitution?: boolean
    graduationYear?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalInfo"]>

  export type PersonalInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amka?: boolean
    afm?: boolean
    doy?: boolean
    middleName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    maritalStatus?: boolean
    numberOfChildren?: boolean
    citizenship?: boolean
    nationality?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    educationLevel?: boolean
    educationTitle?: boolean
    educationInstitution?: boolean
    graduationYear?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalInfo"]>

  export type PersonalInfoSelectScalar = {
    id?: boolean
    userId?: boolean
    amka?: boolean
    afm?: boolean
    doy?: boolean
    middleName?: boolean
    birthDate?: boolean
    birthPlace?: boolean
    maritalStatus?: boolean
    numberOfChildren?: boolean
    citizenship?: boolean
    nationality?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    educationLevel?: boolean
    educationTitle?: boolean
    educationInstitution?: boolean
    graduationYear?: boolean
  }

  export type PersonalInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amka" | "afm" | "doy" | "middleName" | "birthDate" | "birthPlace" | "maritalStatus" | "numberOfChildren" | "citizenship" | "nationality" | "gender" | "createdAt" | "updatedAt" | "educationLevel" | "educationTitle" | "educationInstitution" | "graduationYear", ExtArgs["result"]["personalInfo"]>
  export type PersonalInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    identificationDocuments?: boolean | PersonalInfo$identificationDocumentsArgs<ExtArgs>
    addresses?: boolean | PersonalInfo$addressesArgs<ExtArgs>
    bankAccounts?: boolean | PersonalInfo$bankAccountsArgs<ExtArgs>
    languageSkills?: boolean | PersonalInfo$languageSkillsArgs<ExtArgs>
    _count?: boolean | PersonalInfoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonalInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PersonalInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PersonalInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalInfo"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      identificationDocuments: Prisma.$IdentificationDocumentPayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      bankAccounts: Prisma.$BankAccountPayload<ExtArgs>[]
      languageSkills: Prisma.$LanguageSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      amka: string | null
      afm: string | null
      doy: string | null
      middleName: string | null
      birthDate: Date
      birthPlace: string
      maritalStatus: $Enums.MaritalStatus
      numberOfChildren: number
      citizenship: string | null
      nationality: string | null
      gender: $Enums.Gender | null
      createdAt: Date
      updatedAt: Date
      educationLevel: $Enums.EducationLevel | null
      educationTitle: string | null
      educationInstitution: string | null
      graduationYear: number | null
    }, ExtArgs["result"]["personalInfo"]>
    composites: {}
  }

  type PersonalInfoGetPayload<S extends boolean | null | undefined | PersonalInfoDefaultArgs> = $Result.GetResult<Prisma.$PersonalInfoPayload, S>

  type PersonalInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonalInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonalInfoCountAggregateInputType | true
    }

  export interface PersonalInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalInfo'], meta: { name: 'PersonalInfo' } }
    /**
     * Find zero or one PersonalInfo that matches the filter.
     * @param {PersonalInfoFindUniqueArgs} args - Arguments to find a PersonalInfo
     * @example
     * // Get one PersonalInfo
     * const personalInfo = await prisma.personalInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalInfoFindUniqueArgs>(args: SelectSubset<T, PersonalInfoFindUniqueArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonalInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonalInfoFindUniqueOrThrowArgs} args - Arguments to find a PersonalInfo
     * @example
     * // Get one PersonalInfo
     * const personalInfo = await prisma.personalInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalInfoFindFirstArgs} args - Arguments to find a PersonalInfo
     * @example
     * // Get one PersonalInfo
     * const personalInfo = await prisma.personalInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalInfoFindFirstArgs>(args?: SelectSubset<T, PersonalInfoFindFirstArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalInfoFindFirstOrThrowArgs} args - Arguments to find a PersonalInfo
     * @example
     * // Get one PersonalInfo
     * const personalInfo = await prisma.personalInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonalInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalInfos
     * const personalInfos = await prisma.personalInfo.findMany()
     * 
     * // Get first 10 PersonalInfos
     * const personalInfos = await prisma.personalInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalInfoWithIdOnly = await prisma.personalInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalInfoFindManyArgs>(args?: SelectSubset<T, PersonalInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonalInfo.
     * @param {PersonalInfoCreateArgs} args - Arguments to create a PersonalInfo.
     * @example
     * // Create one PersonalInfo
     * const PersonalInfo = await prisma.personalInfo.create({
     *   data: {
     *     // ... data to create a PersonalInfo
     *   }
     * })
     * 
     */
    create<T extends PersonalInfoCreateArgs>(args: SelectSubset<T, PersonalInfoCreateArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonalInfos.
     * @param {PersonalInfoCreateManyArgs} args - Arguments to create many PersonalInfos.
     * @example
     * // Create many PersonalInfos
     * const personalInfo = await prisma.personalInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalInfoCreateManyArgs>(args?: SelectSubset<T, PersonalInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalInfos and returns the data saved in the database.
     * @param {PersonalInfoCreateManyAndReturnArgs} args - Arguments to create many PersonalInfos.
     * @example
     * // Create many PersonalInfos
     * const personalInfo = await prisma.personalInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalInfos and only return the `id`
     * const personalInfoWithIdOnly = await prisma.personalInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonalInfo.
     * @param {PersonalInfoDeleteArgs} args - Arguments to delete one PersonalInfo.
     * @example
     * // Delete one PersonalInfo
     * const PersonalInfo = await prisma.personalInfo.delete({
     *   where: {
     *     // ... filter to delete one PersonalInfo
     *   }
     * })
     * 
     */
    delete<T extends PersonalInfoDeleteArgs>(args: SelectSubset<T, PersonalInfoDeleteArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonalInfo.
     * @param {PersonalInfoUpdateArgs} args - Arguments to update one PersonalInfo.
     * @example
     * // Update one PersonalInfo
     * const personalInfo = await prisma.personalInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalInfoUpdateArgs>(args: SelectSubset<T, PersonalInfoUpdateArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonalInfos.
     * @param {PersonalInfoDeleteManyArgs} args - Arguments to filter PersonalInfos to delete.
     * @example
     * // Delete a few PersonalInfos
     * const { count } = await prisma.personalInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalInfoDeleteManyArgs>(args?: SelectSubset<T, PersonalInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalInfos
     * const personalInfo = await prisma.personalInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalInfoUpdateManyArgs>(args: SelectSubset<T, PersonalInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalInfos and returns the data updated in the database.
     * @param {PersonalInfoUpdateManyAndReturnArgs} args - Arguments to update many PersonalInfos.
     * @example
     * // Update many PersonalInfos
     * const personalInfo = await prisma.personalInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonalInfos and only return the `id`
     * const personalInfoWithIdOnly = await prisma.personalInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonalInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonalInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonalInfo.
     * @param {PersonalInfoUpsertArgs} args - Arguments to update or create a PersonalInfo.
     * @example
     * // Update or create a PersonalInfo
     * const personalInfo = await prisma.personalInfo.upsert({
     *   create: {
     *     // ... data to create a PersonalInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalInfo we want to update
     *   }
     * })
     */
    upsert<T extends PersonalInfoUpsertArgs>(args: SelectSubset<T, PersonalInfoUpsertArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalInfoCountArgs} args - Arguments to filter PersonalInfos to count.
     * @example
     * // Count the number of PersonalInfos
     * const count = await prisma.personalInfo.count({
     *   where: {
     *     // ... the filter for the PersonalInfos we want to count
     *   }
     * })
    **/
    count<T extends PersonalInfoCountArgs>(
      args?: Subset<T, PersonalInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalInfoAggregateArgs>(args: Subset<T, PersonalInfoAggregateArgs>): Prisma.PrismaPromise<GetPersonalInfoAggregateType<T>>

    /**
     * Group by PersonalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalInfoGroupByArgs['orderBy'] }
        : { orderBy?: PersonalInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalInfo model
   */
  readonly fields: PersonalInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    identificationDocuments<T extends PersonalInfo$identificationDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalInfo$identificationDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends PersonalInfo$addressesArgs<ExtArgs> = {}>(args?: Subset<T, PersonalInfo$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bankAccounts<T extends PersonalInfo$bankAccountsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalInfo$bankAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    languageSkills<T extends PersonalInfo$languageSkillsArgs<ExtArgs> = {}>(args?: Subset<T, PersonalInfo$languageSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalInfo model
   */ 
  interface PersonalInfoFieldRefs {
    readonly id: FieldRef<"PersonalInfo", 'Int'>
    readonly userId: FieldRef<"PersonalInfo", 'String'>
    readonly amka: FieldRef<"PersonalInfo", 'String'>
    readonly afm: FieldRef<"PersonalInfo", 'String'>
    readonly doy: FieldRef<"PersonalInfo", 'String'>
    readonly middleName: FieldRef<"PersonalInfo", 'String'>
    readonly birthDate: FieldRef<"PersonalInfo", 'DateTime'>
    readonly birthPlace: FieldRef<"PersonalInfo", 'String'>
    readonly maritalStatus: FieldRef<"PersonalInfo", 'MaritalStatus'>
    readonly numberOfChildren: FieldRef<"PersonalInfo", 'Int'>
    readonly citizenship: FieldRef<"PersonalInfo", 'String'>
    readonly nationality: FieldRef<"PersonalInfo", 'String'>
    readonly gender: FieldRef<"PersonalInfo", 'Gender'>
    readonly createdAt: FieldRef<"PersonalInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"PersonalInfo", 'DateTime'>
    readonly educationLevel: FieldRef<"PersonalInfo", 'EducationLevel'>
    readonly educationTitle: FieldRef<"PersonalInfo", 'String'>
    readonly educationInstitution: FieldRef<"PersonalInfo", 'String'>
    readonly graduationYear: FieldRef<"PersonalInfo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PersonalInfo findUnique
   */
  export type PersonalInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which PersonalInfo to fetch.
     */
    where: PersonalInfoWhereUniqueInput
  }

  /**
   * PersonalInfo findUniqueOrThrow
   */
  export type PersonalInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which PersonalInfo to fetch.
     */
    where: PersonalInfoWhereUniqueInput
  }

  /**
   * PersonalInfo findFirst
   */
  export type PersonalInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which PersonalInfo to fetch.
     */
    where?: PersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalInfos to fetch.
     */
    orderBy?: PersonalInfoOrderByWithRelationInput | PersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalInfos.
     */
    cursor?: PersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalInfos.
     */
    distinct?: PersonalInfoScalarFieldEnum | PersonalInfoScalarFieldEnum[]
  }

  /**
   * PersonalInfo findFirstOrThrow
   */
  export type PersonalInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which PersonalInfo to fetch.
     */
    where?: PersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalInfos to fetch.
     */
    orderBy?: PersonalInfoOrderByWithRelationInput | PersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalInfos.
     */
    cursor?: PersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalInfos.
     */
    distinct?: PersonalInfoScalarFieldEnum | PersonalInfoScalarFieldEnum[]
  }

  /**
   * PersonalInfo findMany
   */
  export type PersonalInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which PersonalInfos to fetch.
     */
    where?: PersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalInfos to fetch.
     */
    orderBy?: PersonalInfoOrderByWithRelationInput | PersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalInfos.
     */
    cursor?: PersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalInfos.
     */
    skip?: number
    distinct?: PersonalInfoScalarFieldEnum | PersonalInfoScalarFieldEnum[]
  }

  /**
   * PersonalInfo create
   */
  export type PersonalInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalInfo.
     */
    data: XOR<PersonalInfoCreateInput, PersonalInfoUncheckedCreateInput>
  }

  /**
   * PersonalInfo createMany
   */
  export type PersonalInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalInfos.
     */
    data: PersonalInfoCreateManyInput | PersonalInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalInfo createManyAndReturn
   */
  export type PersonalInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * The data used to create many PersonalInfos.
     */
    data: PersonalInfoCreateManyInput | PersonalInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalInfo update
   */
  export type PersonalInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalInfo.
     */
    data: XOR<PersonalInfoUpdateInput, PersonalInfoUncheckedUpdateInput>
    /**
     * Choose, which PersonalInfo to update.
     */
    where: PersonalInfoWhereUniqueInput
  }

  /**
   * PersonalInfo updateMany
   */
  export type PersonalInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalInfos.
     */
    data: XOR<PersonalInfoUpdateManyMutationInput, PersonalInfoUncheckedUpdateManyInput>
    /**
     * Filter which PersonalInfos to update
     */
    where?: PersonalInfoWhereInput
    /**
     * Limit how many PersonalInfos to update.
     */
    limit?: number
  }

  /**
   * PersonalInfo updateManyAndReturn
   */
  export type PersonalInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * The data used to update PersonalInfos.
     */
    data: XOR<PersonalInfoUpdateManyMutationInput, PersonalInfoUncheckedUpdateManyInput>
    /**
     * Filter which PersonalInfos to update
     */
    where?: PersonalInfoWhereInput
    /**
     * Limit how many PersonalInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalInfo upsert
   */
  export type PersonalInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalInfo to update in case it exists.
     */
    where: PersonalInfoWhereUniqueInput
    /**
     * In case the PersonalInfo found by the `where` argument doesn't exist, create a new PersonalInfo with this data.
     */
    create: XOR<PersonalInfoCreateInput, PersonalInfoUncheckedCreateInput>
    /**
     * In case the PersonalInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalInfoUpdateInput, PersonalInfoUncheckedUpdateInput>
  }

  /**
   * PersonalInfo delete
   */
  export type PersonalInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
    /**
     * Filter which PersonalInfo to delete.
     */
    where: PersonalInfoWhereUniqueInput
  }

  /**
   * PersonalInfo deleteMany
   */
  export type PersonalInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalInfos to delete
     */
    where?: PersonalInfoWhereInput
    /**
     * Limit how many PersonalInfos to delete.
     */
    limit?: number
  }

  /**
   * PersonalInfo.identificationDocuments
   */
  export type PersonalInfo$identificationDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
    where?: IdentificationDocumentWhereInput
    orderBy?: IdentificationDocumentOrderByWithRelationInput | IdentificationDocumentOrderByWithRelationInput[]
    cursor?: IdentificationDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdentificationDocumentScalarFieldEnum | IdentificationDocumentScalarFieldEnum[]
  }

  /**
   * PersonalInfo.addresses
   */
  export type PersonalInfo$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * PersonalInfo.bankAccounts
   */
  export type PersonalInfo$bankAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    cursor?: BankAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * PersonalInfo.languageSkills
   */
  export type PersonalInfo$languageSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    where?: LanguageSkillWhereInput
    orderBy?: LanguageSkillOrderByWithRelationInput | LanguageSkillOrderByWithRelationInput[]
    cursor?: LanguageSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LanguageSkillScalarFieldEnum | LanguageSkillScalarFieldEnum[]
  }

  /**
   * PersonalInfo without action
   */
  export type PersonalInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalInfo
     */
    select?: PersonalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalInfo
     */
    omit?: PersonalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalInfoInclude<ExtArgs> | null
  }


  /**
   * Model IdentificationDocument
   */

  export type AggregateIdentificationDocument = {
    _count: IdentificationDocumentCountAggregateOutputType | null
    _avg: IdentificationDocumentAvgAggregateOutputType | null
    _sum: IdentificationDocumentSumAggregateOutputType | null
    _min: IdentificationDocumentMinAggregateOutputType | null
    _max: IdentificationDocumentMaxAggregateOutputType | null
  }

  export type IdentificationDocumentAvgAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
  }

  export type IdentificationDocumentSumAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
  }

  export type IdentificationDocumentMinAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
    type: $Enums.IdentificationDocumentType | null
    documentNumber: string | null
    issueDate: Date | null
    expiryDate: Date | null
    issuingAuthority: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdentificationDocumentMaxAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
    type: $Enums.IdentificationDocumentType | null
    documentNumber: string | null
    issueDate: Date | null
    expiryDate: Date | null
    issuingAuthority: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdentificationDocumentCountAggregateOutputType = {
    id: number
    personalInfoId: number
    type: number
    documentNumber: number
    issueDate: number
    expiryDate: number
    issuingAuthority: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IdentificationDocumentAvgAggregateInputType = {
    id?: true
    personalInfoId?: true
  }

  export type IdentificationDocumentSumAggregateInputType = {
    id?: true
    personalInfoId?: true
  }

  export type IdentificationDocumentMinAggregateInputType = {
    id?: true
    personalInfoId?: true
    type?: true
    documentNumber?: true
    issueDate?: true
    expiryDate?: true
    issuingAuthority?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdentificationDocumentMaxAggregateInputType = {
    id?: true
    personalInfoId?: true
    type?: true
    documentNumber?: true
    issueDate?: true
    expiryDate?: true
    issuingAuthority?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdentificationDocumentCountAggregateInputType = {
    id?: true
    personalInfoId?: true
    type?: true
    documentNumber?: true
    issueDate?: true
    expiryDate?: true
    issuingAuthority?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IdentificationDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdentificationDocument to aggregate.
     */
    where?: IdentificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentificationDocuments to fetch.
     */
    orderBy?: IdentificationDocumentOrderByWithRelationInput | IdentificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdentificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentificationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IdentificationDocuments
    **/
    _count?: true | IdentificationDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IdentificationDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IdentificationDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdentificationDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdentificationDocumentMaxAggregateInputType
  }

  export type GetIdentificationDocumentAggregateType<T extends IdentificationDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateIdentificationDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdentificationDocument[P]>
      : GetScalarType<T[P], AggregateIdentificationDocument[P]>
  }




  export type IdentificationDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentificationDocumentWhereInput
    orderBy?: IdentificationDocumentOrderByWithAggregationInput | IdentificationDocumentOrderByWithAggregationInput[]
    by: IdentificationDocumentScalarFieldEnum[] | IdentificationDocumentScalarFieldEnum
    having?: IdentificationDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdentificationDocumentCountAggregateInputType | true
    _avg?: IdentificationDocumentAvgAggregateInputType
    _sum?: IdentificationDocumentSumAggregateInputType
    _min?: IdentificationDocumentMinAggregateInputType
    _max?: IdentificationDocumentMaxAggregateInputType
  }

  export type IdentificationDocumentGroupByOutputType = {
    id: number
    personalInfoId: number
    type: $Enums.IdentificationDocumentType
    documentNumber: string
    issueDate: Date
    expiryDate: Date | null
    issuingAuthority: string
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    _count: IdentificationDocumentCountAggregateOutputType | null
    _avg: IdentificationDocumentAvgAggregateOutputType | null
    _sum: IdentificationDocumentSumAggregateOutputType | null
    _min: IdentificationDocumentMinAggregateOutputType | null
    _max: IdentificationDocumentMaxAggregateOutputType | null
  }

  type GetIdentificationDocumentGroupByPayload<T extends IdentificationDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdentificationDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdentificationDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdentificationDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], IdentificationDocumentGroupByOutputType[P]>
        }
      >
    >


  export type IdentificationDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    type?: boolean
    documentNumber?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    issuingAuthority?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identificationDocument"]>

  export type IdentificationDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    type?: boolean
    documentNumber?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    issuingAuthority?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identificationDocument"]>

  export type IdentificationDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    type?: boolean
    documentNumber?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    issuingAuthority?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identificationDocument"]>

  export type IdentificationDocumentSelectScalar = {
    id?: boolean
    personalInfoId?: boolean
    type?: boolean
    documentNumber?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    issuingAuthority?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IdentificationDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personalInfoId" | "type" | "documentNumber" | "issueDate" | "expiryDate" | "issuingAuthority" | "isPrimary" | "createdAt" | "updatedAt", ExtArgs["result"]["identificationDocument"]>
  export type IdentificationDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }
  export type IdentificationDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }
  export type IdentificationDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }

  export type $IdentificationDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IdentificationDocument"
    objects: {
      personalInfo: Prisma.$PersonalInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      personalInfoId: number
      type: $Enums.IdentificationDocumentType
      documentNumber: string
      issueDate: Date
      expiryDate: Date | null
      issuingAuthority: string
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["identificationDocument"]>
    composites: {}
  }

  type IdentificationDocumentGetPayload<S extends boolean | null | undefined | IdentificationDocumentDefaultArgs> = $Result.GetResult<Prisma.$IdentificationDocumentPayload, S>

  type IdentificationDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdentificationDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdentificationDocumentCountAggregateInputType | true
    }

  export interface IdentificationDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IdentificationDocument'], meta: { name: 'IdentificationDocument' } }
    /**
     * Find zero or one IdentificationDocument that matches the filter.
     * @param {IdentificationDocumentFindUniqueArgs} args - Arguments to find a IdentificationDocument
     * @example
     * // Get one IdentificationDocument
     * const identificationDocument = await prisma.identificationDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdentificationDocumentFindUniqueArgs>(args: SelectSubset<T, IdentificationDocumentFindUniqueArgs<ExtArgs>>): Prisma__IdentificationDocumentClient<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IdentificationDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdentificationDocumentFindUniqueOrThrowArgs} args - Arguments to find a IdentificationDocument
     * @example
     * // Get one IdentificationDocument
     * const identificationDocument = await prisma.identificationDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdentificationDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, IdentificationDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdentificationDocumentClient<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdentificationDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentificationDocumentFindFirstArgs} args - Arguments to find a IdentificationDocument
     * @example
     * // Get one IdentificationDocument
     * const identificationDocument = await prisma.identificationDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdentificationDocumentFindFirstArgs>(args?: SelectSubset<T, IdentificationDocumentFindFirstArgs<ExtArgs>>): Prisma__IdentificationDocumentClient<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdentificationDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentificationDocumentFindFirstOrThrowArgs} args - Arguments to find a IdentificationDocument
     * @example
     * // Get one IdentificationDocument
     * const identificationDocument = await prisma.identificationDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdentificationDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, IdentificationDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdentificationDocumentClient<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IdentificationDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentificationDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IdentificationDocuments
     * const identificationDocuments = await prisma.identificationDocument.findMany()
     * 
     * // Get first 10 IdentificationDocuments
     * const identificationDocuments = await prisma.identificationDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const identificationDocumentWithIdOnly = await prisma.identificationDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdentificationDocumentFindManyArgs>(args?: SelectSubset<T, IdentificationDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IdentificationDocument.
     * @param {IdentificationDocumentCreateArgs} args - Arguments to create a IdentificationDocument.
     * @example
     * // Create one IdentificationDocument
     * const IdentificationDocument = await prisma.identificationDocument.create({
     *   data: {
     *     // ... data to create a IdentificationDocument
     *   }
     * })
     * 
     */
    create<T extends IdentificationDocumentCreateArgs>(args: SelectSubset<T, IdentificationDocumentCreateArgs<ExtArgs>>): Prisma__IdentificationDocumentClient<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IdentificationDocuments.
     * @param {IdentificationDocumentCreateManyArgs} args - Arguments to create many IdentificationDocuments.
     * @example
     * // Create many IdentificationDocuments
     * const identificationDocument = await prisma.identificationDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdentificationDocumentCreateManyArgs>(args?: SelectSubset<T, IdentificationDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IdentificationDocuments and returns the data saved in the database.
     * @param {IdentificationDocumentCreateManyAndReturnArgs} args - Arguments to create many IdentificationDocuments.
     * @example
     * // Create many IdentificationDocuments
     * const identificationDocument = await prisma.identificationDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IdentificationDocuments and only return the `id`
     * const identificationDocumentWithIdOnly = await prisma.identificationDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdentificationDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, IdentificationDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IdentificationDocument.
     * @param {IdentificationDocumentDeleteArgs} args - Arguments to delete one IdentificationDocument.
     * @example
     * // Delete one IdentificationDocument
     * const IdentificationDocument = await prisma.identificationDocument.delete({
     *   where: {
     *     // ... filter to delete one IdentificationDocument
     *   }
     * })
     * 
     */
    delete<T extends IdentificationDocumentDeleteArgs>(args: SelectSubset<T, IdentificationDocumentDeleteArgs<ExtArgs>>): Prisma__IdentificationDocumentClient<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IdentificationDocument.
     * @param {IdentificationDocumentUpdateArgs} args - Arguments to update one IdentificationDocument.
     * @example
     * // Update one IdentificationDocument
     * const identificationDocument = await prisma.identificationDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdentificationDocumentUpdateArgs>(args: SelectSubset<T, IdentificationDocumentUpdateArgs<ExtArgs>>): Prisma__IdentificationDocumentClient<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IdentificationDocuments.
     * @param {IdentificationDocumentDeleteManyArgs} args - Arguments to filter IdentificationDocuments to delete.
     * @example
     * // Delete a few IdentificationDocuments
     * const { count } = await prisma.identificationDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdentificationDocumentDeleteManyArgs>(args?: SelectSubset<T, IdentificationDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdentificationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentificationDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IdentificationDocuments
     * const identificationDocument = await prisma.identificationDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdentificationDocumentUpdateManyArgs>(args: SelectSubset<T, IdentificationDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdentificationDocuments and returns the data updated in the database.
     * @param {IdentificationDocumentUpdateManyAndReturnArgs} args - Arguments to update many IdentificationDocuments.
     * @example
     * // Update many IdentificationDocuments
     * const identificationDocument = await prisma.identificationDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IdentificationDocuments and only return the `id`
     * const identificationDocumentWithIdOnly = await prisma.identificationDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdentificationDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, IdentificationDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IdentificationDocument.
     * @param {IdentificationDocumentUpsertArgs} args - Arguments to update or create a IdentificationDocument.
     * @example
     * // Update or create a IdentificationDocument
     * const identificationDocument = await prisma.identificationDocument.upsert({
     *   create: {
     *     // ... data to create a IdentificationDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IdentificationDocument we want to update
     *   }
     * })
     */
    upsert<T extends IdentificationDocumentUpsertArgs>(args: SelectSubset<T, IdentificationDocumentUpsertArgs<ExtArgs>>): Prisma__IdentificationDocumentClient<$Result.GetResult<Prisma.$IdentificationDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IdentificationDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentificationDocumentCountArgs} args - Arguments to filter IdentificationDocuments to count.
     * @example
     * // Count the number of IdentificationDocuments
     * const count = await prisma.identificationDocument.count({
     *   where: {
     *     // ... the filter for the IdentificationDocuments we want to count
     *   }
     * })
    **/
    count<T extends IdentificationDocumentCountArgs>(
      args?: Subset<T, IdentificationDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdentificationDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IdentificationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentificationDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdentificationDocumentAggregateArgs>(args: Subset<T, IdentificationDocumentAggregateArgs>): Prisma.PrismaPromise<GetIdentificationDocumentAggregateType<T>>

    /**
     * Group by IdentificationDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentificationDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdentificationDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdentificationDocumentGroupByArgs['orderBy'] }
        : { orderBy?: IdentificationDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdentificationDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdentificationDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IdentificationDocument model
   */
  readonly fields: IdentificationDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IdentificationDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdentificationDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalInfo<T extends PersonalInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalInfoDefaultArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IdentificationDocument model
   */ 
  interface IdentificationDocumentFieldRefs {
    readonly id: FieldRef<"IdentificationDocument", 'Int'>
    readonly personalInfoId: FieldRef<"IdentificationDocument", 'Int'>
    readonly type: FieldRef<"IdentificationDocument", 'IdentificationDocumentType'>
    readonly documentNumber: FieldRef<"IdentificationDocument", 'String'>
    readonly issueDate: FieldRef<"IdentificationDocument", 'DateTime'>
    readonly expiryDate: FieldRef<"IdentificationDocument", 'DateTime'>
    readonly issuingAuthority: FieldRef<"IdentificationDocument", 'String'>
    readonly isPrimary: FieldRef<"IdentificationDocument", 'Boolean'>
    readonly createdAt: FieldRef<"IdentificationDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"IdentificationDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IdentificationDocument findUnique
   */
  export type IdentificationDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which IdentificationDocument to fetch.
     */
    where: IdentificationDocumentWhereUniqueInput
  }

  /**
   * IdentificationDocument findUniqueOrThrow
   */
  export type IdentificationDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which IdentificationDocument to fetch.
     */
    where: IdentificationDocumentWhereUniqueInput
  }

  /**
   * IdentificationDocument findFirst
   */
  export type IdentificationDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which IdentificationDocument to fetch.
     */
    where?: IdentificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentificationDocuments to fetch.
     */
    orderBy?: IdentificationDocumentOrderByWithRelationInput | IdentificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdentificationDocuments.
     */
    cursor?: IdentificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentificationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdentificationDocuments.
     */
    distinct?: IdentificationDocumentScalarFieldEnum | IdentificationDocumentScalarFieldEnum[]
  }

  /**
   * IdentificationDocument findFirstOrThrow
   */
  export type IdentificationDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which IdentificationDocument to fetch.
     */
    where?: IdentificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentificationDocuments to fetch.
     */
    orderBy?: IdentificationDocumentOrderByWithRelationInput | IdentificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdentificationDocuments.
     */
    cursor?: IdentificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentificationDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdentificationDocuments.
     */
    distinct?: IdentificationDocumentScalarFieldEnum | IdentificationDocumentScalarFieldEnum[]
  }

  /**
   * IdentificationDocument findMany
   */
  export type IdentificationDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
    /**
     * Filter, which IdentificationDocuments to fetch.
     */
    where?: IdentificationDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentificationDocuments to fetch.
     */
    orderBy?: IdentificationDocumentOrderByWithRelationInput | IdentificationDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IdentificationDocuments.
     */
    cursor?: IdentificationDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentificationDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentificationDocuments.
     */
    skip?: number
    distinct?: IdentificationDocumentScalarFieldEnum | IdentificationDocumentScalarFieldEnum[]
  }

  /**
   * IdentificationDocument create
   */
  export type IdentificationDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a IdentificationDocument.
     */
    data: XOR<IdentificationDocumentCreateInput, IdentificationDocumentUncheckedCreateInput>
  }

  /**
   * IdentificationDocument createMany
   */
  export type IdentificationDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IdentificationDocuments.
     */
    data: IdentificationDocumentCreateManyInput | IdentificationDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IdentificationDocument createManyAndReturn
   */
  export type IdentificationDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many IdentificationDocuments.
     */
    data: IdentificationDocumentCreateManyInput | IdentificationDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdentificationDocument update
   */
  export type IdentificationDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a IdentificationDocument.
     */
    data: XOR<IdentificationDocumentUpdateInput, IdentificationDocumentUncheckedUpdateInput>
    /**
     * Choose, which IdentificationDocument to update.
     */
    where: IdentificationDocumentWhereUniqueInput
  }

  /**
   * IdentificationDocument updateMany
   */
  export type IdentificationDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IdentificationDocuments.
     */
    data: XOR<IdentificationDocumentUpdateManyMutationInput, IdentificationDocumentUncheckedUpdateManyInput>
    /**
     * Filter which IdentificationDocuments to update
     */
    where?: IdentificationDocumentWhereInput
    /**
     * Limit how many IdentificationDocuments to update.
     */
    limit?: number
  }

  /**
   * IdentificationDocument updateManyAndReturn
   */
  export type IdentificationDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * The data used to update IdentificationDocuments.
     */
    data: XOR<IdentificationDocumentUpdateManyMutationInput, IdentificationDocumentUncheckedUpdateManyInput>
    /**
     * Filter which IdentificationDocuments to update
     */
    where?: IdentificationDocumentWhereInput
    /**
     * Limit how many IdentificationDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdentificationDocument upsert
   */
  export type IdentificationDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the IdentificationDocument to update in case it exists.
     */
    where: IdentificationDocumentWhereUniqueInput
    /**
     * In case the IdentificationDocument found by the `where` argument doesn't exist, create a new IdentificationDocument with this data.
     */
    create: XOR<IdentificationDocumentCreateInput, IdentificationDocumentUncheckedCreateInput>
    /**
     * In case the IdentificationDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdentificationDocumentUpdateInput, IdentificationDocumentUncheckedUpdateInput>
  }

  /**
   * IdentificationDocument delete
   */
  export type IdentificationDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
    /**
     * Filter which IdentificationDocument to delete.
     */
    where: IdentificationDocumentWhereUniqueInput
  }

  /**
   * IdentificationDocument deleteMany
   */
  export type IdentificationDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdentificationDocuments to delete
     */
    where?: IdentificationDocumentWhereInput
    /**
     * Limit how many IdentificationDocuments to delete.
     */
    limit?: number
  }

  /**
   * IdentificationDocument without action
   */
  export type IdentificationDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentificationDocument
     */
    select?: IdentificationDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentificationDocument
     */
    omit?: IdentificationDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentificationDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
    type: $Enums.AddressType | null
    street: string | null
    streetNumber: string | null
    city: string | null
    region: string | null
    postalCode: string | null
    country: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
    type: $Enums.AddressType | null
    street: string | null
    streetNumber: string | null
    city: string | null
    region: string | null
    postalCode: string | null
    country: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    personalInfoId: number
    type: number
    street: number
    streetNumber: number
    city: number
    region: number
    postalCode: number
    country: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    personalInfoId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    personalInfoId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    personalInfoId?: true
    type?: true
    street?: true
    streetNumber?: true
    city?: true
    region?: true
    postalCode?: true
    country?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    personalInfoId?: true
    type?: true
    street?: true
    streetNumber?: true
    city?: true
    region?: true
    postalCode?: true
    country?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    personalInfoId?: true
    type?: true
    street?: true
    streetNumber?: true
    city?: true
    region?: true
    postalCode?: true
    country?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    personalInfoId: number
    type: $Enums.AddressType
    street: string
    streetNumber: string
    city: string
    region: string
    postalCode: string
    country: string
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    type?: boolean
    street?: boolean
    streetNumber?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    type?: boolean
    street?: boolean
    streetNumber?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    type?: boolean
    street?: boolean
    streetNumber?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    personalInfoId?: boolean
    type?: boolean
    street?: boolean
    streetNumber?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personalInfoId" | "type" | "street" | "streetNumber" | "city" | "region" | "postalCode" | "country" | "isPrimary" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      personalInfo: Prisma.$PersonalInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      personalInfoId: number
      type: $Enums.AddressType
      street: string
      streetNumber: string
      city: string
      region: string
      postalCode: string
      country: string
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalInfo<T extends PersonalInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalInfoDefaultArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */ 
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Int'>
    readonly personalInfoId: FieldRef<"Address", 'Int'>
    readonly type: FieldRef<"Address", 'AddressType'>
    readonly street: FieldRef<"Address", 'String'>
    readonly streetNumber: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly region: FieldRef<"Address", 'String'>
    readonly postalCode: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly isPrimary: FieldRef<"Address", 'Boolean'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    id: number | null
    dependentMemberId: number | null
    languageSkillId: number | null
  }

  export type DocumentSumAggregateOutputType = {
    id: number | null
    dependentMemberId: number | null
    languageSkillId: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: number | null
    userId: string | null
    type: $Enums.DocumentType | null
    key: string | null
    uploadedAt: Date | null
    dependentMemberId: number | null
    languageSkillId: number | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    type: $Enums.DocumentType | null
    key: string | null
    uploadedAt: Date | null
    dependentMemberId: number | null
    languageSkillId: number | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    key: number
    uploadedAt: number
    dependentMemberId: number
    languageSkillId: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    id?: true
    dependentMemberId?: true
    languageSkillId?: true
  }

  export type DocumentSumAggregateInputType = {
    id?: true
    dependentMemberId?: true
    languageSkillId?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    key?: true
    uploadedAt?: true
    dependentMemberId?: true
    languageSkillId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    key?: true
    uploadedAt?: true
    dependentMemberId?: true
    languageSkillId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    key?: true
    uploadedAt?: true
    dependentMemberId?: true
    languageSkillId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: number
    userId: string
    type: $Enums.DocumentType
    key: string
    uploadedAt: Date
    dependentMemberId: number | null
    languageSkillId: number | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    key?: boolean
    uploadedAt?: boolean
    dependentMemberId?: boolean
    languageSkillId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    dependentMember?: boolean | Document$dependentMemberArgs<ExtArgs>
    verification?: boolean | Document$verificationArgs<ExtArgs>
    languageSkill?: boolean | Document$languageSkillArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    key?: boolean
    uploadedAt?: boolean
    dependentMemberId?: boolean
    languageSkillId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    dependentMember?: boolean | Document$dependentMemberArgs<ExtArgs>
    languageSkill?: boolean | Document$languageSkillArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    key?: boolean
    uploadedAt?: boolean
    dependentMemberId?: boolean
    languageSkillId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    dependentMember?: boolean | Document$dependentMemberArgs<ExtArgs>
    languageSkill?: boolean | Document$languageSkillArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    key?: boolean
    uploadedAt?: boolean
    dependentMemberId?: boolean
    languageSkillId?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "key" | "uploadedAt" | "dependentMemberId" | "languageSkillId", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    dependentMember?: boolean | Document$dependentMemberArgs<ExtArgs>
    verification?: boolean | Document$verificationArgs<ExtArgs>
    languageSkill?: boolean | Document$languageSkillArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    dependentMember?: boolean | Document$dependentMemberArgs<ExtArgs>
    languageSkill?: boolean | Document$languageSkillArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    dependentMember?: boolean | Document$dependentMemberArgs<ExtArgs>
    languageSkill?: boolean | Document$languageSkillArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      dependentMember: Prisma.$DependentMemberPayload<ExtArgs> | null
      verification: Prisma.$DocumentVerificationPayload<ExtArgs> | null
      languageSkill: Prisma.$LanguageSkillPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      type: $Enums.DocumentType
      key: string
      uploadedAt: Date
      dependentMemberId: number | null
      languageSkillId: number | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dependentMember<T extends Document$dependentMemberArgs<ExtArgs> = {}>(args?: Subset<T, Document$dependentMemberArgs<ExtArgs>>): Prisma__DependentMemberClient<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    verification<T extends Document$verificationArgs<ExtArgs> = {}>(args?: Subset<T, Document$verificationArgs<ExtArgs>>): Prisma__DocumentVerificationClient<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    languageSkill<T extends Document$languageSkillArgs<ExtArgs> = {}>(args?: Subset<T, Document$languageSkillArgs<ExtArgs>>): Prisma__LanguageSkillClient<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'Int'>
    readonly userId: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly key: FieldRef<"Document", 'String'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
    readonly dependentMemberId: FieldRef<"Document", 'Int'>
    readonly languageSkillId: FieldRef<"Document", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.dependentMember
   */
  export type Document$dependentMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    where?: DependentMemberWhereInput
  }

  /**
   * Document.verification
   */
  export type Document$verificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    where?: DocumentVerificationWhereInput
  }

  /**
   * Document.languageSkill
   */
  export type Document$languageSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    where?: LanguageSkillWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentVerification
   */

  export type AggregateDocumentVerification = {
    _count: DocumentVerificationCountAggregateOutputType | null
    _avg: DocumentVerificationAvgAggregateOutputType | null
    _sum: DocumentVerificationSumAggregateOutputType | null
    _min: DocumentVerificationMinAggregateOutputType | null
    _max: DocumentVerificationMaxAggregateOutputType | null
  }

  export type DocumentVerificationAvgAggregateOutputType = {
    id: number | null
    documentId: number | null
  }

  export type DocumentVerificationSumAggregateOutputType = {
    id: number | null
    documentId: number | null
  }

  export type DocumentVerificationMinAggregateOutputType = {
    id: number | null
    documentId: number | null
    status: $Enums.VerificationStatus | null
    reviewedById: string | null
    comments: string | null
    reviewedAt: Date | null
    userId: string | null
  }

  export type DocumentVerificationMaxAggregateOutputType = {
    id: number | null
    documentId: number | null
    status: $Enums.VerificationStatus | null
    reviewedById: string | null
    comments: string | null
    reviewedAt: Date | null
    userId: string | null
  }

  export type DocumentVerificationCountAggregateOutputType = {
    id: number
    documentId: number
    status: number
    reviewedById: number
    comments: number
    reviewedAt: number
    userId: number
    _all: number
  }


  export type DocumentVerificationAvgAggregateInputType = {
    id?: true
    documentId?: true
  }

  export type DocumentVerificationSumAggregateInputType = {
    id?: true
    documentId?: true
  }

  export type DocumentVerificationMinAggregateInputType = {
    id?: true
    documentId?: true
    status?: true
    reviewedById?: true
    comments?: true
    reviewedAt?: true
    userId?: true
  }

  export type DocumentVerificationMaxAggregateInputType = {
    id?: true
    documentId?: true
    status?: true
    reviewedById?: true
    comments?: true
    reviewedAt?: true
    userId?: true
  }

  export type DocumentVerificationCountAggregateInputType = {
    id?: true
    documentId?: true
    status?: true
    reviewedById?: true
    comments?: true
    reviewedAt?: true
    userId?: true
    _all?: true
  }

  export type DocumentVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentVerification to aggregate.
     */
    where?: DocumentVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVerifications to fetch.
     */
    orderBy?: DocumentVerificationOrderByWithRelationInput | DocumentVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentVerifications
    **/
    _count?: true | DocumentVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentVerificationMaxAggregateInputType
  }

  export type GetDocumentVerificationAggregateType<T extends DocumentVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentVerification[P]>
      : GetScalarType<T[P], AggregateDocumentVerification[P]>
  }




  export type DocumentVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVerificationWhereInput
    orderBy?: DocumentVerificationOrderByWithAggregationInput | DocumentVerificationOrderByWithAggregationInput[]
    by: DocumentVerificationScalarFieldEnum[] | DocumentVerificationScalarFieldEnum
    having?: DocumentVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentVerificationCountAggregateInputType | true
    _avg?: DocumentVerificationAvgAggregateInputType
    _sum?: DocumentVerificationSumAggregateInputType
    _min?: DocumentVerificationMinAggregateInputType
    _max?: DocumentVerificationMaxAggregateInputType
  }

  export type DocumentVerificationGroupByOutputType = {
    id: number
    documentId: number
    status: $Enums.VerificationStatus
    reviewedById: string
    comments: string | null
    reviewedAt: Date | null
    userId: string | null
    _count: DocumentVerificationCountAggregateOutputType | null
    _avg: DocumentVerificationAvgAggregateOutputType | null
    _sum: DocumentVerificationSumAggregateOutputType | null
    _min: DocumentVerificationMinAggregateOutputType | null
    _max: DocumentVerificationMaxAggregateOutputType | null
  }

  type GetDocumentVerificationGroupByPayload<T extends DocumentVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentVerificationGroupByOutputType[P]>
        }
      >
    >


  export type DocumentVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    status?: boolean
    reviewedById?: boolean
    comments?: boolean
    reviewedAt?: boolean
    userId?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    reviewedBy?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | DocumentVerification$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentVerification"]>

  export type DocumentVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    status?: boolean
    reviewedById?: boolean
    comments?: boolean
    reviewedAt?: boolean
    userId?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    reviewedBy?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | DocumentVerification$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentVerification"]>

  export type DocumentVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    status?: boolean
    reviewedById?: boolean
    comments?: boolean
    reviewedAt?: boolean
    userId?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    reviewedBy?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | DocumentVerification$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentVerification"]>

  export type DocumentVerificationSelectScalar = {
    id?: boolean
    documentId?: boolean
    status?: boolean
    reviewedById?: boolean
    comments?: boolean
    reviewedAt?: boolean
    userId?: boolean
  }

  export type DocumentVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "status" | "reviewedById" | "comments" | "reviewedAt" | "userId", ExtArgs["result"]["documentVerification"]>
  export type DocumentVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    reviewedBy?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | DocumentVerification$UserArgs<ExtArgs>
  }
  export type DocumentVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    reviewedBy?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | DocumentVerification$UserArgs<ExtArgs>
  }
  export type DocumentVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    reviewedBy?: boolean | UserDefaultArgs<ExtArgs>
    User?: boolean | DocumentVerification$UserArgs<ExtArgs>
  }

  export type $DocumentVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentVerification"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      reviewedBy: Prisma.$UserPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      documentId: number
      status: $Enums.VerificationStatus
      reviewedById: string
      comments: string | null
      reviewedAt: Date | null
      userId: string | null
    }, ExtArgs["result"]["documentVerification"]>
    composites: {}
  }

  type DocumentVerificationGetPayload<S extends boolean | null | undefined | DocumentVerificationDefaultArgs> = $Result.GetResult<Prisma.$DocumentVerificationPayload, S>

  type DocumentVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentVerificationCountAggregateInputType | true
    }

  export interface DocumentVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentVerification'], meta: { name: 'DocumentVerification' } }
    /**
     * Find zero or one DocumentVerification that matches the filter.
     * @param {DocumentVerificationFindUniqueArgs} args - Arguments to find a DocumentVerification
     * @example
     * // Get one DocumentVerification
     * const documentVerification = await prisma.documentVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentVerificationFindUniqueArgs>(args: SelectSubset<T, DocumentVerificationFindUniqueArgs<ExtArgs>>): Prisma__DocumentVerificationClient<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentVerificationFindUniqueOrThrowArgs} args - Arguments to find a DocumentVerification
     * @example
     * // Get one DocumentVerification
     * const documentVerification = await prisma.documentVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentVerificationClient<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVerificationFindFirstArgs} args - Arguments to find a DocumentVerification
     * @example
     * // Get one DocumentVerification
     * const documentVerification = await prisma.documentVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentVerificationFindFirstArgs>(args?: SelectSubset<T, DocumentVerificationFindFirstArgs<ExtArgs>>): Prisma__DocumentVerificationClient<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVerificationFindFirstOrThrowArgs} args - Arguments to find a DocumentVerification
     * @example
     * // Get one DocumentVerification
     * const documentVerification = await prisma.documentVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentVerificationClient<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentVerifications
     * const documentVerifications = await prisma.documentVerification.findMany()
     * 
     * // Get first 10 DocumentVerifications
     * const documentVerifications = await prisma.documentVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentVerificationWithIdOnly = await prisma.documentVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentVerificationFindManyArgs>(args?: SelectSubset<T, DocumentVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentVerification.
     * @param {DocumentVerificationCreateArgs} args - Arguments to create a DocumentVerification.
     * @example
     * // Create one DocumentVerification
     * const DocumentVerification = await prisma.documentVerification.create({
     *   data: {
     *     // ... data to create a DocumentVerification
     *   }
     * })
     * 
     */
    create<T extends DocumentVerificationCreateArgs>(args: SelectSubset<T, DocumentVerificationCreateArgs<ExtArgs>>): Prisma__DocumentVerificationClient<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentVerifications.
     * @param {DocumentVerificationCreateManyArgs} args - Arguments to create many DocumentVerifications.
     * @example
     * // Create many DocumentVerifications
     * const documentVerification = await prisma.documentVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentVerificationCreateManyArgs>(args?: SelectSubset<T, DocumentVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentVerifications and returns the data saved in the database.
     * @param {DocumentVerificationCreateManyAndReturnArgs} args - Arguments to create many DocumentVerifications.
     * @example
     * // Create many DocumentVerifications
     * const documentVerification = await prisma.documentVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentVerifications and only return the `id`
     * const documentVerificationWithIdOnly = await prisma.documentVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentVerification.
     * @param {DocumentVerificationDeleteArgs} args - Arguments to delete one DocumentVerification.
     * @example
     * // Delete one DocumentVerification
     * const DocumentVerification = await prisma.documentVerification.delete({
     *   where: {
     *     // ... filter to delete one DocumentVerification
     *   }
     * })
     * 
     */
    delete<T extends DocumentVerificationDeleteArgs>(args: SelectSubset<T, DocumentVerificationDeleteArgs<ExtArgs>>): Prisma__DocumentVerificationClient<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentVerification.
     * @param {DocumentVerificationUpdateArgs} args - Arguments to update one DocumentVerification.
     * @example
     * // Update one DocumentVerification
     * const documentVerification = await prisma.documentVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentVerificationUpdateArgs>(args: SelectSubset<T, DocumentVerificationUpdateArgs<ExtArgs>>): Prisma__DocumentVerificationClient<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentVerifications.
     * @param {DocumentVerificationDeleteManyArgs} args - Arguments to filter DocumentVerifications to delete.
     * @example
     * // Delete a few DocumentVerifications
     * const { count } = await prisma.documentVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentVerificationDeleteManyArgs>(args?: SelectSubset<T, DocumentVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentVerifications
     * const documentVerification = await prisma.documentVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentVerificationUpdateManyArgs>(args: SelectSubset<T, DocumentVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentVerifications and returns the data updated in the database.
     * @param {DocumentVerificationUpdateManyAndReturnArgs} args - Arguments to update many DocumentVerifications.
     * @example
     * // Update many DocumentVerifications
     * const documentVerification = await prisma.documentVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentVerifications and only return the `id`
     * const documentVerificationWithIdOnly = await prisma.documentVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentVerification.
     * @param {DocumentVerificationUpsertArgs} args - Arguments to update or create a DocumentVerification.
     * @example
     * // Update or create a DocumentVerification
     * const documentVerification = await prisma.documentVerification.upsert({
     *   create: {
     *     // ... data to create a DocumentVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentVerification we want to update
     *   }
     * })
     */
    upsert<T extends DocumentVerificationUpsertArgs>(args: SelectSubset<T, DocumentVerificationUpsertArgs<ExtArgs>>): Prisma__DocumentVerificationClient<$Result.GetResult<Prisma.$DocumentVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVerificationCountArgs} args - Arguments to filter DocumentVerifications to count.
     * @example
     * // Count the number of DocumentVerifications
     * const count = await prisma.documentVerification.count({
     *   where: {
     *     // ... the filter for the DocumentVerifications we want to count
     *   }
     * })
    **/
    count<T extends DocumentVerificationCountArgs>(
      args?: Subset<T, DocumentVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentVerificationAggregateArgs>(args: Subset<T, DocumentVerificationAggregateArgs>): Prisma.PrismaPromise<GetDocumentVerificationAggregateType<T>>

    /**
     * Group by DocumentVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentVerificationGroupByArgs['orderBy'] }
        : { orderBy?: DocumentVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentVerification model
   */
  readonly fields: DocumentVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends DocumentVerification$UserArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVerification$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentVerification model
   */ 
  interface DocumentVerificationFieldRefs {
    readonly id: FieldRef<"DocumentVerification", 'Int'>
    readonly documentId: FieldRef<"DocumentVerification", 'Int'>
    readonly status: FieldRef<"DocumentVerification", 'VerificationStatus'>
    readonly reviewedById: FieldRef<"DocumentVerification", 'String'>
    readonly comments: FieldRef<"DocumentVerification", 'String'>
    readonly reviewedAt: FieldRef<"DocumentVerification", 'DateTime'>
    readonly userId: FieldRef<"DocumentVerification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentVerification findUnique
   */
  export type DocumentVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVerification to fetch.
     */
    where: DocumentVerificationWhereUniqueInput
  }

  /**
   * DocumentVerification findUniqueOrThrow
   */
  export type DocumentVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVerification to fetch.
     */
    where: DocumentVerificationWhereUniqueInput
  }

  /**
   * DocumentVerification findFirst
   */
  export type DocumentVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVerification to fetch.
     */
    where?: DocumentVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVerifications to fetch.
     */
    orderBy?: DocumentVerificationOrderByWithRelationInput | DocumentVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentVerifications.
     */
    cursor?: DocumentVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentVerifications.
     */
    distinct?: DocumentVerificationScalarFieldEnum | DocumentVerificationScalarFieldEnum[]
  }

  /**
   * DocumentVerification findFirstOrThrow
   */
  export type DocumentVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVerification to fetch.
     */
    where?: DocumentVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVerifications to fetch.
     */
    orderBy?: DocumentVerificationOrderByWithRelationInput | DocumentVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentVerifications.
     */
    cursor?: DocumentVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentVerifications.
     */
    distinct?: DocumentVerificationScalarFieldEnum | DocumentVerificationScalarFieldEnum[]
  }

  /**
   * DocumentVerification findMany
   */
  export type DocumentVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVerifications to fetch.
     */
    where?: DocumentVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVerifications to fetch.
     */
    orderBy?: DocumentVerificationOrderByWithRelationInput | DocumentVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentVerifications.
     */
    cursor?: DocumentVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVerifications.
     */
    skip?: number
    distinct?: DocumentVerificationScalarFieldEnum | DocumentVerificationScalarFieldEnum[]
  }

  /**
   * DocumentVerification create
   */
  export type DocumentVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentVerification.
     */
    data: XOR<DocumentVerificationCreateInput, DocumentVerificationUncheckedCreateInput>
  }

  /**
   * DocumentVerification createMany
   */
  export type DocumentVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentVerifications.
     */
    data: DocumentVerificationCreateManyInput | DocumentVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentVerification createManyAndReturn
   */
  export type DocumentVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentVerifications.
     */
    data: DocumentVerificationCreateManyInput | DocumentVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentVerification update
   */
  export type DocumentVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentVerification.
     */
    data: XOR<DocumentVerificationUpdateInput, DocumentVerificationUncheckedUpdateInput>
    /**
     * Choose, which DocumentVerification to update.
     */
    where: DocumentVerificationWhereUniqueInput
  }

  /**
   * DocumentVerification updateMany
   */
  export type DocumentVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentVerifications.
     */
    data: XOR<DocumentVerificationUpdateManyMutationInput, DocumentVerificationUncheckedUpdateManyInput>
    /**
     * Filter which DocumentVerifications to update
     */
    where?: DocumentVerificationWhereInput
    /**
     * Limit how many DocumentVerifications to update.
     */
    limit?: number
  }

  /**
   * DocumentVerification updateManyAndReturn
   */
  export type DocumentVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * The data used to update DocumentVerifications.
     */
    data: XOR<DocumentVerificationUpdateManyMutationInput, DocumentVerificationUncheckedUpdateManyInput>
    /**
     * Filter which DocumentVerifications to update
     */
    where?: DocumentVerificationWhereInput
    /**
     * Limit how many DocumentVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentVerification upsert
   */
  export type DocumentVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentVerification to update in case it exists.
     */
    where: DocumentVerificationWhereUniqueInput
    /**
     * In case the DocumentVerification found by the `where` argument doesn't exist, create a new DocumentVerification with this data.
     */
    create: XOR<DocumentVerificationCreateInput, DocumentVerificationUncheckedCreateInput>
    /**
     * In case the DocumentVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentVerificationUpdateInput, DocumentVerificationUncheckedUpdateInput>
  }

  /**
   * DocumentVerification delete
   */
  export type DocumentVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
    /**
     * Filter which DocumentVerification to delete.
     */
    where: DocumentVerificationWhereUniqueInput
  }

  /**
   * DocumentVerification deleteMany
   */
  export type DocumentVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentVerifications to delete
     */
    where?: DocumentVerificationWhereInput
    /**
     * Limit how many DocumentVerifications to delete.
     */
    limit?: number
  }

  /**
   * DocumentVerification.User
   */
  export type DocumentVerification$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DocumentVerification without action
   */
  export type DocumentVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVerification
     */
    select?: DocumentVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVerification
     */
    omit?: DocumentVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVerificationInclude<ExtArgs> | null
  }


  /**
   * Model OnboardingProgress
   */

  export type AggregateOnboardingProgress = {
    _count: OnboardingProgressCountAggregateOutputType | null
    _avg: OnboardingProgressAvgAggregateOutputType | null
    _sum: OnboardingProgressSumAggregateOutputType | null
    _min: OnboardingProgressMinAggregateOutputType | null
    _max: OnboardingProgressMaxAggregateOutputType | null
  }

  export type OnboardingProgressAvgAggregateOutputType = {
    id: number | null
    applicationId: number | null
  }

  export type OnboardingProgressSumAggregateOutputType = {
    id: number | null
    applicationId: number | null
  }

  export type OnboardingProgressMinAggregateOutputType = {
    id: number | null
    userId: string | null
    applicationId: number | null
    currentPhase: $Enums.Phase | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.OnboardingStatus | null
    hireDate: Date | null
    hiringManagerId: string | null
  }

  export type OnboardingProgressMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    applicationId: number | null
    currentPhase: $Enums.Phase | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.OnboardingStatus | null
    hireDate: Date | null
    hiringManagerId: string | null
  }

  export type OnboardingProgressCountAggregateOutputType = {
    id: number
    userId: number
    applicationId: number
    currentPhase: number
    startedAt: number
    completedAt: number
    status: number
    hireDate: number
    hiringManagerId: number
    _all: number
  }


  export type OnboardingProgressAvgAggregateInputType = {
    id?: true
    applicationId?: true
  }

  export type OnboardingProgressSumAggregateInputType = {
    id?: true
    applicationId?: true
  }

  export type OnboardingProgressMinAggregateInputType = {
    id?: true
    userId?: true
    applicationId?: true
    currentPhase?: true
    startedAt?: true
    completedAt?: true
    status?: true
    hireDate?: true
    hiringManagerId?: true
  }

  export type OnboardingProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    applicationId?: true
    currentPhase?: true
    startedAt?: true
    completedAt?: true
    status?: true
    hireDate?: true
    hiringManagerId?: true
  }

  export type OnboardingProgressCountAggregateInputType = {
    id?: true
    userId?: true
    applicationId?: true
    currentPhase?: true
    startedAt?: true
    completedAt?: true
    status?: true
    hireDate?: true
    hiringManagerId?: true
    _all?: true
  }

  export type OnboardingProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingProgress to aggregate.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnboardingProgresses
    **/
    _count?: true | OnboardingProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OnboardingProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OnboardingProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnboardingProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnboardingProgressMaxAggregateInputType
  }

  export type GetOnboardingProgressAggregateType<T extends OnboardingProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateOnboardingProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnboardingProgress[P]>
      : GetScalarType<T[P], AggregateOnboardingProgress[P]>
  }




  export type OnboardingProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingProgressWhereInput
    orderBy?: OnboardingProgressOrderByWithAggregationInput | OnboardingProgressOrderByWithAggregationInput[]
    by: OnboardingProgressScalarFieldEnum[] | OnboardingProgressScalarFieldEnum
    having?: OnboardingProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnboardingProgressCountAggregateInputType | true
    _avg?: OnboardingProgressAvgAggregateInputType
    _sum?: OnboardingProgressSumAggregateInputType
    _min?: OnboardingProgressMinAggregateInputType
    _max?: OnboardingProgressMaxAggregateInputType
  }

  export type OnboardingProgressGroupByOutputType = {
    id: number
    userId: string
    applicationId: number
    currentPhase: $Enums.Phase
    startedAt: Date
    completedAt: Date | null
    status: $Enums.OnboardingStatus
    hireDate: Date
    hiringManagerId: string
    _count: OnboardingProgressCountAggregateOutputType | null
    _avg: OnboardingProgressAvgAggregateOutputType | null
    _sum: OnboardingProgressSumAggregateOutputType | null
    _min: OnboardingProgressMinAggregateOutputType | null
    _max: OnboardingProgressMaxAggregateOutputType | null
  }

  type GetOnboardingProgressGroupByPayload<T extends OnboardingProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnboardingProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnboardingProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnboardingProgressGroupByOutputType[P]>
            : GetScalarType<T[P], OnboardingProgressGroupByOutputType[P]>
        }
      >
    >


  export type OnboardingProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    applicationId?: boolean
    currentPhase?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    hireDate?: boolean
    hiringManagerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    hiringManager?: boolean | UserDefaultArgs<ExtArgs>
    contract?: boolean | OnboardingProgress$contractArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingProgress"]>

  export type OnboardingProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    applicationId?: boolean
    currentPhase?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    hireDate?: boolean
    hiringManagerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    hiringManager?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingProgress"]>

  export type OnboardingProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    applicationId?: boolean
    currentPhase?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    hireDate?: boolean
    hiringManagerId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    hiringManager?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingProgress"]>

  export type OnboardingProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    applicationId?: boolean
    currentPhase?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    hireDate?: boolean
    hiringManagerId?: boolean
  }

  export type OnboardingProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "applicationId" | "currentPhase" | "startedAt" | "completedAt" | "status" | "hireDate" | "hiringManagerId", ExtArgs["result"]["onboardingProgress"]>
  export type OnboardingProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    hiringManager?: boolean | UserDefaultArgs<ExtArgs>
    contract?: boolean | OnboardingProgress$contractArgs<ExtArgs>
  }
  export type OnboardingProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    hiringManager?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OnboardingProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    hiringManager?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OnboardingProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnboardingProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      application: Prisma.$JobApplicationPayload<ExtArgs>
      hiringManager: Prisma.$UserPayload<ExtArgs>
      contract: Prisma.$ContractPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      applicationId: number
      currentPhase: $Enums.Phase
      startedAt: Date
      completedAt: Date | null
      status: $Enums.OnboardingStatus
      hireDate: Date
      hiringManagerId: string
    }, ExtArgs["result"]["onboardingProgress"]>
    composites: {}
  }

  type OnboardingProgressGetPayload<S extends boolean | null | undefined | OnboardingProgressDefaultArgs> = $Result.GetResult<Prisma.$OnboardingProgressPayload, S>

  type OnboardingProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OnboardingProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OnboardingProgressCountAggregateInputType | true
    }

  export interface OnboardingProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnboardingProgress'], meta: { name: 'OnboardingProgress' } }
    /**
     * Find zero or one OnboardingProgress that matches the filter.
     * @param {OnboardingProgressFindUniqueArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnboardingProgressFindUniqueArgs>(args: SelectSubset<T, OnboardingProgressFindUniqueArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OnboardingProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OnboardingProgressFindUniqueOrThrowArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnboardingProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, OnboardingProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnboardingProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressFindFirstArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnboardingProgressFindFirstArgs>(args?: SelectSubset<T, OnboardingProgressFindFirstArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnboardingProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressFindFirstOrThrowArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnboardingProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, OnboardingProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OnboardingProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnboardingProgresses
     * const onboardingProgresses = await prisma.onboardingProgress.findMany()
     * 
     * // Get first 10 OnboardingProgresses
     * const onboardingProgresses = await prisma.onboardingProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onboardingProgressWithIdOnly = await prisma.onboardingProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnboardingProgressFindManyArgs>(args?: SelectSubset<T, OnboardingProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OnboardingProgress.
     * @param {OnboardingProgressCreateArgs} args - Arguments to create a OnboardingProgress.
     * @example
     * // Create one OnboardingProgress
     * const OnboardingProgress = await prisma.onboardingProgress.create({
     *   data: {
     *     // ... data to create a OnboardingProgress
     *   }
     * })
     * 
     */
    create<T extends OnboardingProgressCreateArgs>(args: SelectSubset<T, OnboardingProgressCreateArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OnboardingProgresses.
     * @param {OnboardingProgressCreateManyArgs} args - Arguments to create many OnboardingProgresses.
     * @example
     * // Create many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnboardingProgressCreateManyArgs>(args?: SelectSubset<T, OnboardingProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnboardingProgresses and returns the data saved in the database.
     * @param {OnboardingProgressCreateManyAndReturnArgs} args - Arguments to create many OnboardingProgresses.
     * @example
     * // Create many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnboardingProgresses and only return the `id`
     * const onboardingProgressWithIdOnly = await prisma.onboardingProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnboardingProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, OnboardingProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OnboardingProgress.
     * @param {OnboardingProgressDeleteArgs} args - Arguments to delete one OnboardingProgress.
     * @example
     * // Delete one OnboardingProgress
     * const OnboardingProgress = await prisma.onboardingProgress.delete({
     *   where: {
     *     // ... filter to delete one OnboardingProgress
     *   }
     * })
     * 
     */
    delete<T extends OnboardingProgressDeleteArgs>(args: SelectSubset<T, OnboardingProgressDeleteArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OnboardingProgress.
     * @param {OnboardingProgressUpdateArgs} args - Arguments to update one OnboardingProgress.
     * @example
     * // Update one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnboardingProgressUpdateArgs>(args: SelectSubset<T, OnboardingProgressUpdateArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OnboardingProgresses.
     * @param {OnboardingProgressDeleteManyArgs} args - Arguments to filter OnboardingProgresses to delete.
     * @example
     * // Delete a few OnboardingProgresses
     * const { count } = await prisma.onboardingProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnboardingProgressDeleteManyArgs>(args?: SelectSubset<T, OnboardingProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnboardingProgressUpdateManyArgs>(args: SelectSubset<T, OnboardingProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingProgresses and returns the data updated in the database.
     * @param {OnboardingProgressUpdateManyAndReturnArgs} args - Arguments to update many OnboardingProgresses.
     * @example
     * // Update many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OnboardingProgresses and only return the `id`
     * const onboardingProgressWithIdOnly = await prisma.onboardingProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OnboardingProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, OnboardingProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OnboardingProgress.
     * @param {OnboardingProgressUpsertArgs} args - Arguments to update or create a OnboardingProgress.
     * @example
     * // Update or create a OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.upsert({
     *   create: {
     *     // ... data to create a OnboardingProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnboardingProgress we want to update
     *   }
     * })
     */
    upsert<T extends OnboardingProgressUpsertArgs>(args: SelectSubset<T, OnboardingProgressUpsertArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OnboardingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressCountArgs} args - Arguments to filter OnboardingProgresses to count.
     * @example
     * // Count the number of OnboardingProgresses
     * const count = await prisma.onboardingProgress.count({
     *   where: {
     *     // ... the filter for the OnboardingProgresses we want to count
     *   }
     * })
    **/
    count<T extends OnboardingProgressCountArgs>(
      args?: Subset<T, OnboardingProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnboardingProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnboardingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnboardingProgressAggregateArgs>(args: Subset<T, OnboardingProgressAggregateArgs>): Prisma.PrismaPromise<GetOnboardingProgressAggregateType<T>>

    /**
     * Group by OnboardingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnboardingProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnboardingProgressGroupByArgs['orderBy'] }
        : { orderBy?: OnboardingProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnboardingProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnboardingProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnboardingProgress model
   */
  readonly fields: OnboardingProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnboardingProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnboardingProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    application<T extends JobApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobApplicationDefaultArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hiringManager<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contract<T extends OnboardingProgress$contractArgs<ExtArgs> = {}>(args?: Subset<T, OnboardingProgress$contractArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnboardingProgress model
   */ 
  interface OnboardingProgressFieldRefs {
    readonly id: FieldRef<"OnboardingProgress", 'Int'>
    readonly userId: FieldRef<"OnboardingProgress", 'String'>
    readonly applicationId: FieldRef<"OnboardingProgress", 'Int'>
    readonly currentPhase: FieldRef<"OnboardingProgress", 'Phase'>
    readonly startedAt: FieldRef<"OnboardingProgress", 'DateTime'>
    readonly completedAt: FieldRef<"OnboardingProgress", 'DateTime'>
    readonly status: FieldRef<"OnboardingProgress", 'OnboardingStatus'>
    readonly hireDate: FieldRef<"OnboardingProgress", 'DateTime'>
    readonly hiringManagerId: FieldRef<"OnboardingProgress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OnboardingProgress findUnique
   */
  export type OnboardingProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress findUniqueOrThrow
   */
  export type OnboardingProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress findFirst
   */
  export type OnboardingProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingProgresses.
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingProgresses.
     */
    distinct?: OnboardingProgressScalarFieldEnum | OnboardingProgressScalarFieldEnum[]
  }

  /**
   * OnboardingProgress findFirstOrThrow
   */
  export type OnboardingProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingProgresses.
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingProgresses.
     */
    distinct?: OnboardingProgressScalarFieldEnum | OnboardingProgressScalarFieldEnum[]
  }

  /**
   * OnboardingProgress findMany
   */
  export type OnboardingProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgresses to fetch.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnboardingProgresses.
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    distinct?: OnboardingProgressScalarFieldEnum | OnboardingProgressScalarFieldEnum[]
  }

  /**
   * OnboardingProgress create
   */
  export type OnboardingProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a OnboardingProgress.
     */
    data: XOR<OnboardingProgressCreateInput, OnboardingProgressUncheckedCreateInput>
  }

  /**
   * OnboardingProgress createMany
   */
  export type OnboardingProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnboardingProgresses.
     */
    data: OnboardingProgressCreateManyInput | OnboardingProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnboardingProgress createManyAndReturn
   */
  export type OnboardingProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * The data used to create many OnboardingProgresses.
     */
    data: OnboardingProgressCreateManyInput | OnboardingProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingProgress update
   */
  export type OnboardingProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a OnboardingProgress.
     */
    data: XOR<OnboardingProgressUpdateInput, OnboardingProgressUncheckedUpdateInput>
    /**
     * Choose, which OnboardingProgress to update.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress updateMany
   */
  export type OnboardingProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnboardingProgresses.
     */
    data: XOR<OnboardingProgressUpdateManyMutationInput, OnboardingProgressUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingProgresses to update
     */
    where?: OnboardingProgressWhereInput
    /**
     * Limit how many OnboardingProgresses to update.
     */
    limit?: number
  }

  /**
   * OnboardingProgress updateManyAndReturn
   */
  export type OnboardingProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * The data used to update OnboardingProgresses.
     */
    data: XOR<OnboardingProgressUpdateManyMutationInput, OnboardingProgressUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingProgresses to update
     */
    where?: OnboardingProgressWhereInput
    /**
     * Limit how many OnboardingProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingProgress upsert
   */
  export type OnboardingProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the OnboardingProgress to update in case it exists.
     */
    where: OnboardingProgressWhereUniqueInput
    /**
     * In case the OnboardingProgress found by the `where` argument doesn't exist, create a new OnboardingProgress with this data.
     */
    create: XOR<OnboardingProgressCreateInput, OnboardingProgressUncheckedCreateInput>
    /**
     * In case the OnboardingProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnboardingProgressUpdateInput, OnboardingProgressUncheckedUpdateInput>
  }

  /**
   * OnboardingProgress delete
   */
  export type OnboardingProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter which OnboardingProgress to delete.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress deleteMany
   */
  export type OnboardingProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingProgresses to delete
     */
    where?: OnboardingProgressWhereInput
    /**
     * Limit how many OnboardingProgresses to delete.
     */
    limit?: number
  }

  /**
   * OnboardingProgress.contract
   */
  export type OnboardingProgress$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
  }

  /**
   * OnboardingProgress without action
   */
  export type OnboardingProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
  }


  /**
   * Model OnboardingInvitation
   */

  export type AggregateOnboardingInvitation = {
    _count: OnboardingInvitationCountAggregateOutputType | null
    _avg: OnboardingInvitationAvgAggregateOutputType | null
    _sum: OnboardingInvitationSumAggregateOutputType | null
    _min: OnboardingInvitationMinAggregateOutputType | null
    _max: OnboardingInvitationMaxAggregateOutputType | null
  }

  export type OnboardingInvitationAvgAggregateOutputType = {
    applicationId: number | null
  }

  export type OnboardingInvitationSumAggregateOutputType = {
    applicationId: number | null
  }

  export type OnboardingInvitationMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    otp: string | null
    otpExpiresAt: Date | null
    applicationId: number | null
    expiresAt: Date | null
    verifiedAt: Date | null
    lastAccessedAt: Date | null
    sessionToken: string | null
    sessionExpiresAt: Date | null
    createdAt: Date | null
  }

  export type OnboardingInvitationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    otp: string | null
    otpExpiresAt: Date | null
    applicationId: number | null
    expiresAt: Date | null
    verifiedAt: Date | null
    lastAccessedAt: Date | null
    sessionToken: string | null
    sessionExpiresAt: Date | null
    createdAt: Date | null
  }

  export type OnboardingInvitationCountAggregateOutputType = {
    id: number
    email: number
    token: number
    otp: number
    otpExpiresAt: number
    applicationId: number
    expiresAt: number
    verifiedAt: number
    lastAccessedAt: number
    sessionToken: number
    sessionExpiresAt: number
    createdAt: number
    _all: number
  }


  export type OnboardingInvitationAvgAggregateInputType = {
    applicationId?: true
  }

  export type OnboardingInvitationSumAggregateInputType = {
    applicationId?: true
  }

  export type OnboardingInvitationMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    otp?: true
    otpExpiresAt?: true
    applicationId?: true
    expiresAt?: true
    verifiedAt?: true
    lastAccessedAt?: true
    sessionToken?: true
    sessionExpiresAt?: true
    createdAt?: true
  }

  export type OnboardingInvitationMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    otp?: true
    otpExpiresAt?: true
    applicationId?: true
    expiresAt?: true
    verifiedAt?: true
    lastAccessedAt?: true
    sessionToken?: true
    sessionExpiresAt?: true
    createdAt?: true
  }

  export type OnboardingInvitationCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    otp?: true
    otpExpiresAt?: true
    applicationId?: true
    expiresAt?: true
    verifiedAt?: true
    lastAccessedAt?: true
    sessionToken?: true
    sessionExpiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type OnboardingInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingInvitation to aggregate.
     */
    where?: OnboardingInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingInvitations to fetch.
     */
    orderBy?: OnboardingInvitationOrderByWithRelationInput | OnboardingInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnboardingInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnboardingInvitations
    **/
    _count?: true | OnboardingInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OnboardingInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OnboardingInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnboardingInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnboardingInvitationMaxAggregateInputType
  }

  export type GetOnboardingInvitationAggregateType<T extends OnboardingInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateOnboardingInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnboardingInvitation[P]>
      : GetScalarType<T[P], AggregateOnboardingInvitation[P]>
  }




  export type OnboardingInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingInvitationWhereInput
    orderBy?: OnboardingInvitationOrderByWithAggregationInput | OnboardingInvitationOrderByWithAggregationInput[]
    by: OnboardingInvitationScalarFieldEnum[] | OnboardingInvitationScalarFieldEnum
    having?: OnboardingInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnboardingInvitationCountAggregateInputType | true
    _avg?: OnboardingInvitationAvgAggregateInputType
    _sum?: OnboardingInvitationSumAggregateInputType
    _min?: OnboardingInvitationMinAggregateInputType
    _max?: OnboardingInvitationMaxAggregateInputType
  }

  export type OnboardingInvitationGroupByOutputType = {
    id: string
    email: string
    token: string
    otp: string | null
    otpExpiresAt: Date | null
    applicationId: number
    expiresAt: Date
    verifiedAt: Date | null
    lastAccessedAt: Date
    sessionToken: string | null
    sessionExpiresAt: Date | null
    createdAt: Date
    _count: OnboardingInvitationCountAggregateOutputType | null
    _avg: OnboardingInvitationAvgAggregateOutputType | null
    _sum: OnboardingInvitationSumAggregateOutputType | null
    _min: OnboardingInvitationMinAggregateOutputType | null
    _max: OnboardingInvitationMaxAggregateOutputType | null
  }

  type GetOnboardingInvitationGroupByPayload<T extends OnboardingInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnboardingInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnboardingInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnboardingInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], OnboardingInvitationGroupByOutputType[P]>
        }
      >
    >


  export type OnboardingInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    applicationId?: boolean
    expiresAt?: boolean
    verifiedAt?: boolean
    lastAccessedAt?: boolean
    sessionToken?: boolean
    sessionExpiresAt?: boolean
    createdAt?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingInvitation"]>

  export type OnboardingInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    applicationId?: boolean
    expiresAt?: boolean
    verifiedAt?: boolean
    lastAccessedAt?: boolean
    sessionToken?: boolean
    sessionExpiresAt?: boolean
    createdAt?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingInvitation"]>

  export type OnboardingInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    applicationId?: boolean
    expiresAt?: boolean
    verifiedAt?: boolean
    lastAccessedAt?: boolean
    sessionToken?: boolean
    sessionExpiresAt?: boolean
    createdAt?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingInvitation"]>

  export type OnboardingInvitationSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    applicationId?: boolean
    expiresAt?: boolean
    verifiedAt?: boolean
    lastAccessedAt?: boolean
    sessionToken?: boolean
    sessionExpiresAt?: boolean
    createdAt?: boolean
  }

  export type OnboardingInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "otp" | "otpExpiresAt" | "applicationId" | "expiresAt" | "verifiedAt" | "lastAccessedAt" | "sessionToken" | "sessionExpiresAt" | "createdAt", ExtArgs["result"]["onboardingInvitation"]>
  export type OnboardingInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }
  export type OnboardingInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }
  export type OnboardingInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }

  export type $OnboardingInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnboardingInvitation"
    objects: {
      application: Prisma.$JobApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      otp: string | null
      otpExpiresAt: Date | null
      applicationId: number
      expiresAt: Date
      verifiedAt: Date | null
      lastAccessedAt: Date
      sessionToken: string | null
      sessionExpiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["onboardingInvitation"]>
    composites: {}
  }

  type OnboardingInvitationGetPayload<S extends boolean | null | undefined | OnboardingInvitationDefaultArgs> = $Result.GetResult<Prisma.$OnboardingInvitationPayload, S>

  type OnboardingInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OnboardingInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OnboardingInvitationCountAggregateInputType | true
    }

  export interface OnboardingInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnboardingInvitation'], meta: { name: 'OnboardingInvitation' } }
    /**
     * Find zero or one OnboardingInvitation that matches the filter.
     * @param {OnboardingInvitationFindUniqueArgs} args - Arguments to find a OnboardingInvitation
     * @example
     * // Get one OnboardingInvitation
     * const onboardingInvitation = await prisma.onboardingInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnboardingInvitationFindUniqueArgs>(args: SelectSubset<T, OnboardingInvitationFindUniqueArgs<ExtArgs>>): Prisma__OnboardingInvitationClient<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OnboardingInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OnboardingInvitationFindUniqueOrThrowArgs} args - Arguments to find a OnboardingInvitation
     * @example
     * // Get one OnboardingInvitation
     * const onboardingInvitation = await prisma.onboardingInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnboardingInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, OnboardingInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnboardingInvitationClient<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnboardingInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInvitationFindFirstArgs} args - Arguments to find a OnboardingInvitation
     * @example
     * // Get one OnboardingInvitation
     * const onboardingInvitation = await prisma.onboardingInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnboardingInvitationFindFirstArgs>(args?: SelectSubset<T, OnboardingInvitationFindFirstArgs<ExtArgs>>): Prisma__OnboardingInvitationClient<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnboardingInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInvitationFindFirstOrThrowArgs} args - Arguments to find a OnboardingInvitation
     * @example
     * // Get one OnboardingInvitation
     * const onboardingInvitation = await prisma.onboardingInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnboardingInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, OnboardingInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnboardingInvitationClient<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OnboardingInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnboardingInvitations
     * const onboardingInvitations = await prisma.onboardingInvitation.findMany()
     * 
     * // Get first 10 OnboardingInvitations
     * const onboardingInvitations = await prisma.onboardingInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onboardingInvitationWithIdOnly = await prisma.onboardingInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnboardingInvitationFindManyArgs>(args?: SelectSubset<T, OnboardingInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OnboardingInvitation.
     * @param {OnboardingInvitationCreateArgs} args - Arguments to create a OnboardingInvitation.
     * @example
     * // Create one OnboardingInvitation
     * const OnboardingInvitation = await prisma.onboardingInvitation.create({
     *   data: {
     *     // ... data to create a OnboardingInvitation
     *   }
     * })
     * 
     */
    create<T extends OnboardingInvitationCreateArgs>(args: SelectSubset<T, OnboardingInvitationCreateArgs<ExtArgs>>): Prisma__OnboardingInvitationClient<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OnboardingInvitations.
     * @param {OnboardingInvitationCreateManyArgs} args - Arguments to create many OnboardingInvitations.
     * @example
     * // Create many OnboardingInvitations
     * const onboardingInvitation = await prisma.onboardingInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnboardingInvitationCreateManyArgs>(args?: SelectSubset<T, OnboardingInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnboardingInvitations and returns the data saved in the database.
     * @param {OnboardingInvitationCreateManyAndReturnArgs} args - Arguments to create many OnboardingInvitations.
     * @example
     * // Create many OnboardingInvitations
     * const onboardingInvitation = await prisma.onboardingInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnboardingInvitations and only return the `id`
     * const onboardingInvitationWithIdOnly = await prisma.onboardingInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnboardingInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, OnboardingInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OnboardingInvitation.
     * @param {OnboardingInvitationDeleteArgs} args - Arguments to delete one OnboardingInvitation.
     * @example
     * // Delete one OnboardingInvitation
     * const OnboardingInvitation = await prisma.onboardingInvitation.delete({
     *   where: {
     *     // ... filter to delete one OnboardingInvitation
     *   }
     * })
     * 
     */
    delete<T extends OnboardingInvitationDeleteArgs>(args: SelectSubset<T, OnboardingInvitationDeleteArgs<ExtArgs>>): Prisma__OnboardingInvitationClient<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OnboardingInvitation.
     * @param {OnboardingInvitationUpdateArgs} args - Arguments to update one OnboardingInvitation.
     * @example
     * // Update one OnboardingInvitation
     * const onboardingInvitation = await prisma.onboardingInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnboardingInvitationUpdateArgs>(args: SelectSubset<T, OnboardingInvitationUpdateArgs<ExtArgs>>): Prisma__OnboardingInvitationClient<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OnboardingInvitations.
     * @param {OnboardingInvitationDeleteManyArgs} args - Arguments to filter OnboardingInvitations to delete.
     * @example
     * // Delete a few OnboardingInvitations
     * const { count } = await prisma.onboardingInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnboardingInvitationDeleteManyArgs>(args?: SelectSubset<T, OnboardingInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnboardingInvitations
     * const onboardingInvitation = await prisma.onboardingInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnboardingInvitationUpdateManyArgs>(args: SelectSubset<T, OnboardingInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingInvitations and returns the data updated in the database.
     * @param {OnboardingInvitationUpdateManyAndReturnArgs} args - Arguments to update many OnboardingInvitations.
     * @example
     * // Update many OnboardingInvitations
     * const onboardingInvitation = await prisma.onboardingInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OnboardingInvitations and only return the `id`
     * const onboardingInvitationWithIdOnly = await prisma.onboardingInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OnboardingInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, OnboardingInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OnboardingInvitation.
     * @param {OnboardingInvitationUpsertArgs} args - Arguments to update or create a OnboardingInvitation.
     * @example
     * // Update or create a OnboardingInvitation
     * const onboardingInvitation = await prisma.onboardingInvitation.upsert({
     *   create: {
     *     // ... data to create a OnboardingInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnboardingInvitation we want to update
     *   }
     * })
     */
    upsert<T extends OnboardingInvitationUpsertArgs>(args: SelectSubset<T, OnboardingInvitationUpsertArgs<ExtArgs>>): Prisma__OnboardingInvitationClient<$Result.GetResult<Prisma.$OnboardingInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OnboardingInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInvitationCountArgs} args - Arguments to filter OnboardingInvitations to count.
     * @example
     * // Count the number of OnboardingInvitations
     * const count = await prisma.onboardingInvitation.count({
     *   where: {
     *     // ... the filter for the OnboardingInvitations we want to count
     *   }
     * })
    **/
    count<T extends OnboardingInvitationCountArgs>(
      args?: Subset<T, OnboardingInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnboardingInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnboardingInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnboardingInvitationAggregateArgs>(args: Subset<T, OnboardingInvitationAggregateArgs>): Prisma.PrismaPromise<GetOnboardingInvitationAggregateType<T>>

    /**
     * Group by OnboardingInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnboardingInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnboardingInvitationGroupByArgs['orderBy'] }
        : { orderBy?: OnboardingInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnboardingInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnboardingInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnboardingInvitation model
   */
  readonly fields: OnboardingInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnboardingInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnboardingInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends JobApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobApplicationDefaultArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnboardingInvitation model
   */ 
  interface OnboardingInvitationFieldRefs {
    readonly id: FieldRef<"OnboardingInvitation", 'String'>
    readonly email: FieldRef<"OnboardingInvitation", 'String'>
    readonly token: FieldRef<"OnboardingInvitation", 'String'>
    readonly otp: FieldRef<"OnboardingInvitation", 'String'>
    readonly otpExpiresAt: FieldRef<"OnboardingInvitation", 'DateTime'>
    readonly applicationId: FieldRef<"OnboardingInvitation", 'Int'>
    readonly expiresAt: FieldRef<"OnboardingInvitation", 'DateTime'>
    readonly verifiedAt: FieldRef<"OnboardingInvitation", 'DateTime'>
    readonly lastAccessedAt: FieldRef<"OnboardingInvitation", 'DateTime'>
    readonly sessionToken: FieldRef<"OnboardingInvitation", 'String'>
    readonly sessionExpiresAt: FieldRef<"OnboardingInvitation", 'DateTime'>
    readonly createdAt: FieldRef<"OnboardingInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OnboardingInvitation findUnique
   */
  export type OnboardingInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingInvitation to fetch.
     */
    where: OnboardingInvitationWhereUniqueInput
  }

  /**
   * OnboardingInvitation findUniqueOrThrow
   */
  export type OnboardingInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingInvitation to fetch.
     */
    where: OnboardingInvitationWhereUniqueInput
  }

  /**
   * OnboardingInvitation findFirst
   */
  export type OnboardingInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingInvitation to fetch.
     */
    where?: OnboardingInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingInvitations to fetch.
     */
    orderBy?: OnboardingInvitationOrderByWithRelationInput | OnboardingInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingInvitations.
     */
    cursor?: OnboardingInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingInvitations.
     */
    distinct?: OnboardingInvitationScalarFieldEnum | OnboardingInvitationScalarFieldEnum[]
  }

  /**
   * OnboardingInvitation findFirstOrThrow
   */
  export type OnboardingInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingInvitation to fetch.
     */
    where?: OnboardingInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingInvitations to fetch.
     */
    orderBy?: OnboardingInvitationOrderByWithRelationInput | OnboardingInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingInvitations.
     */
    cursor?: OnboardingInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingInvitations.
     */
    distinct?: OnboardingInvitationScalarFieldEnum | OnboardingInvitationScalarFieldEnum[]
  }

  /**
   * OnboardingInvitation findMany
   */
  export type OnboardingInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingInvitations to fetch.
     */
    where?: OnboardingInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingInvitations to fetch.
     */
    orderBy?: OnboardingInvitationOrderByWithRelationInput | OnboardingInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnboardingInvitations.
     */
    cursor?: OnboardingInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingInvitations.
     */
    skip?: number
    distinct?: OnboardingInvitationScalarFieldEnum | OnboardingInvitationScalarFieldEnum[]
  }

  /**
   * OnboardingInvitation create
   */
  export type OnboardingInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a OnboardingInvitation.
     */
    data: XOR<OnboardingInvitationCreateInput, OnboardingInvitationUncheckedCreateInput>
  }

  /**
   * OnboardingInvitation createMany
   */
  export type OnboardingInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnboardingInvitations.
     */
    data: OnboardingInvitationCreateManyInput | OnboardingInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnboardingInvitation createManyAndReturn
   */
  export type OnboardingInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many OnboardingInvitations.
     */
    data: OnboardingInvitationCreateManyInput | OnboardingInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingInvitation update
   */
  export type OnboardingInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a OnboardingInvitation.
     */
    data: XOR<OnboardingInvitationUpdateInput, OnboardingInvitationUncheckedUpdateInput>
    /**
     * Choose, which OnboardingInvitation to update.
     */
    where: OnboardingInvitationWhereUniqueInput
  }

  /**
   * OnboardingInvitation updateMany
   */
  export type OnboardingInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnboardingInvitations.
     */
    data: XOR<OnboardingInvitationUpdateManyMutationInput, OnboardingInvitationUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingInvitations to update
     */
    where?: OnboardingInvitationWhereInput
    /**
     * Limit how many OnboardingInvitations to update.
     */
    limit?: number
  }

  /**
   * OnboardingInvitation updateManyAndReturn
   */
  export type OnboardingInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * The data used to update OnboardingInvitations.
     */
    data: XOR<OnboardingInvitationUpdateManyMutationInput, OnboardingInvitationUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingInvitations to update
     */
    where?: OnboardingInvitationWhereInput
    /**
     * Limit how many OnboardingInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingInvitation upsert
   */
  export type OnboardingInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the OnboardingInvitation to update in case it exists.
     */
    where: OnboardingInvitationWhereUniqueInput
    /**
     * In case the OnboardingInvitation found by the `where` argument doesn't exist, create a new OnboardingInvitation with this data.
     */
    create: XOR<OnboardingInvitationCreateInput, OnboardingInvitationUncheckedCreateInput>
    /**
     * In case the OnboardingInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnboardingInvitationUpdateInput, OnboardingInvitationUncheckedUpdateInput>
  }

  /**
   * OnboardingInvitation delete
   */
  export type OnboardingInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
    /**
     * Filter which OnboardingInvitation to delete.
     */
    where: OnboardingInvitationWhereUniqueInput
  }

  /**
   * OnboardingInvitation deleteMany
   */
  export type OnboardingInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingInvitations to delete
     */
    where?: OnboardingInvitationWhereInput
    /**
     * Limit how many OnboardingInvitations to delete.
     */
    limit?: number
  }

  /**
   * OnboardingInvitation without action
   */
  export type OnboardingInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingInvitation
     */
    select?: OnboardingInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingInvitation
     */
    omit?: OnboardingInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInvitationInclude<ExtArgs> | null
  }


  /**
   * Model EmergencyContact
   */

  export type AggregateEmergencyContact = {
    _count: EmergencyContactCountAggregateOutputType | null
    _avg: EmergencyContactAvgAggregateOutputType | null
    _sum: EmergencyContactSumAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  export type EmergencyContactAvgAggregateOutputType = {
    id: number | null
  }

  export type EmergencyContactSumAggregateOutputType = {
    id: number | null
  }

  export type EmergencyContactMinAggregateOutputType = {
    id: number | null
    userId: string | null
    fullName: string | null
    relationship: string | null
    primaryPhone: string | null
    secondaryPhone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmergencyContactMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    fullName: string | null
    relationship: string | null
    primaryPhone: string | null
    secondaryPhone: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmergencyContactCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    relationship: number
    primaryPhone: number
    secondaryPhone: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmergencyContactAvgAggregateInputType = {
    id?: true
  }

  export type EmergencyContactSumAggregateInputType = {
    id?: true
  }

  export type EmergencyContactMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    relationship?: true
    primaryPhone?: true
    secondaryPhone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmergencyContactMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    relationship?: true
    primaryPhone?: true
    secondaryPhone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmergencyContactCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    relationship?: true
    primaryPhone?: true
    secondaryPhone?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmergencyContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContact to aggregate.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmergencyContacts
    **/
    _count?: true | EmergencyContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencyContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type GetEmergencyContactAggregateType<T extends EmergencyContactAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergencyContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergencyContact[P]>
      : GetScalarType<T[P], AggregateEmergencyContact[P]>
  }




  export type EmergencyContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyContactWhereInput
    orderBy?: EmergencyContactOrderByWithAggregationInput | EmergencyContactOrderByWithAggregationInput[]
    by: EmergencyContactScalarFieldEnum[] | EmergencyContactScalarFieldEnum
    having?: EmergencyContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyContactCountAggregateInputType | true
    _avg?: EmergencyContactAvgAggregateInputType
    _sum?: EmergencyContactSumAggregateInputType
    _min?: EmergencyContactMinAggregateInputType
    _max?: EmergencyContactMaxAggregateInputType
  }

  export type EmergencyContactGroupByOutputType = {
    id: number
    userId: string
    fullName: string
    relationship: string
    primaryPhone: string
    secondaryPhone: string | null
    email: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmergencyContactCountAggregateOutputType | null
    _avg: EmergencyContactAvgAggregateOutputType | null
    _sum: EmergencyContactSumAggregateOutputType | null
    _min: EmergencyContactMinAggregateOutputType | null
    _max: EmergencyContactMaxAggregateOutputType | null
  }

  type GetEmergencyContactGroupByPayload<T extends EmergencyContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyContactGroupByOutputType[P]>
        }
      >
    >


  export type EmergencyContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    relationship?: boolean
    primaryPhone?: boolean
    secondaryPhone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    relationship?: boolean
    primaryPhone?: boolean
    secondaryPhone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    relationship?: boolean
    primaryPhone?: boolean
    secondaryPhone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergencyContact"]>

  export type EmergencyContactSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    relationship?: boolean
    primaryPhone?: boolean
    secondaryPhone?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmergencyContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fullName" | "relationship" | "primaryPhone" | "secondaryPhone" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["emergencyContact"]>
  export type EmergencyContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmergencyContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmergencyContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmergencyContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmergencyContact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      fullName: string
      relationship: string
      primaryPhone: string
      secondaryPhone: string | null
      email: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emergencyContact"]>
    composites: {}
  }

  type EmergencyContactGetPayload<S extends boolean | null | undefined | EmergencyContactDefaultArgs> = $Result.GetResult<Prisma.$EmergencyContactPayload, S>

  type EmergencyContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmergencyContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmergencyContactCountAggregateInputType | true
    }

  export interface EmergencyContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmergencyContact'], meta: { name: 'EmergencyContact' } }
    /**
     * Find zero or one EmergencyContact that matches the filter.
     * @param {EmergencyContactFindUniqueArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyContactFindUniqueArgs>(args: SelectSubset<T, EmergencyContactFindUniqueArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmergencyContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmergencyContactFindUniqueOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyContactFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyContactFindFirstArgs>(args?: SelectSubset<T, EmergencyContactFindFirstArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmergencyContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindFirstOrThrowArgs} args - Arguments to find a EmergencyContact
     * @example
     * // Get one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyContactFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmergencyContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany()
     * 
     * // Get first 10 EmergencyContacts
     * const emergencyContacts = await prisma.emergencyContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyContactFindManyArgs>(args?: SelectSubset<T, EmergencyContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmergencyContact.
     * @param {EmergencyContactCreateArgs} args - Arguments to create a EmergencyContact.
     * @example
     * // Create one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.create({
     *   data: {
     *     // ... data to create a EmergencyContact
     *   }
     * })
     * 
     */
    create<T extends EmergencyContactCreateArgs>(args: SelectSubset<T, EmergencyContactCreateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmergencyContacts.
     * @param {EmergencyContactCreateManyArgs} args - Arguments to create many EmergencyContacts.
     * @example
     * // Create many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyContactCreateManyArgs>(args?: SelectSubset<T, EmergencyContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmergencyContacts and returns the data saved in the database.
     * @param {EmergencyContactCreateManyAndReturnArgs} args - Arguments to create many EmergencyContacts.
     * @example
     * // Create many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmergencyContacts and only return the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmergencyContactCreateManyAndReturnArgs>(args?: SelectSubset<T, EmergencyContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmergencyContact.
     * @param {EmergencyContactDeleteArgs} args - Arguments to delete one EmergencyContact.
     * @example
     * // Delete one EmergencyContact
     * const EmergencyContact = await prisma.emergencyContact.delete({
     *   where: {
     *     // ... filter to delete one EmergencyContact
     *   }
     * })
     * 
     */
    delete<T extends EmergencyContactDeleteArgs>(args: SelectSubset<T, EmergencyContactDeleteArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmergencyContact.
     * @param {EmergencyContactUpdateArgs} args - Arguments to update one EmergencyContact.
     * @example
     * // Update one EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyContactUpdateArgs>(args: SelectSubset<T, EmergencyContactUpdateArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmergencyContacts.
     * @param {EmergencyContactDeleteManyArgs} args - Arguments to filter EmergencyContacts to delete.
     * @example
     * // Delete a few EmergencyContacts
     * const { count } = await prisma.emergencyContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyContactDeleteManyArgs>(args?: SelectSubset<T, EmergencyContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyContactUpdateManyArgs>(args: SelectSubset<T, EmergencyContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmergencyContacts and returns the data updated in the database.
     * @param {EmergencyContactUpdateManyAndReturnArgs} args - Arguments to update many EmergencyContacts.
     * @example
     * // Update many EmergencyContacts
     * const emergencyContact = await prisma.emergencyContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmergencyContacts and only return the `id`
     * const emergencyContactWithIdOnly = await prisma.emergencyContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmergencyContactUpdateManyAndReturnArgs>(args: SelectSubset<T, EmergencyContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmergencyContact.
     * @param {EmergencyContactUpsertArgs} args - Arguments to update or create a EmergencyContact.
     * @example
     * // Update or create a EmergencyContact
     * const emergencyContact = await prisma.emergencyContact.upsert({
     *   create: {
     *     // ... data to create a EmergencyContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmergencyContact we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyContactUpsertArgs>(args: SelectSubset<T, EmergencyContactUpsertArgs<ExtArgs>>): Prisma__EmergencyContactClient<$Result.GetResult<Prisma.$EmergencyContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmergencyContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactCountArgs} args - Arguments to filter EmergencyContacts to count.
     * @example
     * // Count the number of EmergencyContacts
     * const count = await prisma.emergencyContact.count({
     *   where: {
     *     // ... the filter for the EmergencyContacts we want to count
     *   }
     * })
    **/
    count<T extends EmergencyContactCountArgs>(
      args?: Subset<T, EmergencyContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyContactAggregateArgs>(args: Subset<T, EmergencyContactAggregateArgs>): Prisma.PrismaPromise<GetEmergencyContactAggregateType<T>>

    /**
     * Group by EmergencyContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyContactGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmergencyContact model
   */
  readonly fields: EmergencyContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmergencyContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmergencyContact model
   */ 
  interface EmergencyContactFieldRefs {
    readonly id: FieldRef<"EmergencyContact", 'Int'>
    readonly userId: FieldRef<"EmergencyContact", 'String'>
    readonly fullName: FieldRef<"EmergencyContact", 'String'>
    readonly relationship: FieldRef<"EmergencyContact", 'String'>
    readonly primaryPhone: FieldRef<"EmergencyContact", 'String'>
    readonly secondaryPhone: FieldRef<"EmergencyContact", 'String'>
    readonly email: FieldRef<"EmergencyContact", 'String'>
    readonly createdAt: FieldRef<"EmergencyContact", 'DateTime'>
    readonly updatedAt: FieldRef<"EmergencyContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmergencyContact findUnique
   */
  export type EmergencyContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findUniqueOrThrow
   */
  export type EmergencyContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact findFirst
   */
  export type EmergencyContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findFirstOrThrow
   */
  export type EmergencyContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContact to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmergencyContacts.
     */
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact findMany
   */
  export type EmergencyContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter, which EmergencyContacts to fetch.
     */
    where?: EmergencyContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmergencyContacts to fetch.
     */
    orderBy?: EmergencyContactOrderByWithRelationInput | EmergencyContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmergencyContacts.
     */
    cursor?: EmergencyContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmergencyContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmergencyContacts.
     */
    skip?: number
    distinct?: EmergencyContactScalarFieldEnum | EmergencyContactScalarFieldEnum[]
  }

  /**
   * EmergencyContact create
   */
  export type EmergencyContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to create a EmergencyContact.
     */
    data: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
  }

  /**
   * EmergencyContact createMany
   */
  export type EmergencyContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmergencyContacts.
     */
    data: EmergencyContactCreateManyInput | EmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmergencyContact createManyAndReturn
   */
  export type EmergencyContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to create many EmergencyContacts.
     */
    data: EmergencyContactCreateManyInput | EmergencyContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyContact update
   */
  export type EmergencyContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The data needed to update a EmergencyContact.
     */
    data: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
    /**
     * Choose, which EmergencyContact to update.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact updateMany
   */
  export type EmergencyContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmergencyContacts.
     */
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyContacts to update
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to update.
     */
    limit?: number
  }

  /**
   * EmergencyContact updateManyAndReturn
   */
  export type EmergencyContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * The data used to update EmergencyContacts.
     */
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyInput>
    /**
     * Filter which EmergencyContacts to update
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmergencyContact upsert
   */
  export type EmergencyContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * The filter to search for the EmergencyContact to update in case it exists.
     */
    where: EmergencyContactWhereUniqueInput
    /**
     * In case the EmergencyContact found by the `where` argument doesn't exist, create a new EmergencyContact with this data.
     */
    create: XOR<EmergencyContactCreateInput, EmergencyContactUncheckedCreateInput>
    /**
     * In case the EmergencyContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyContactUpdateInput, EmergencyContactUncheckedUpdateInput>
  }

  /**
   * EmergencyContact delete
   */
  export type EmergencyContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
    /**
     * Filter which EmergencyContact to delete.
     */
    where: EmergencyContactWhereUniqueInput
  }

  /**
   * EmergencyContact deleteMany
   */
  export type EmergencyContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmergencyContacts to delete
     */
    where?: EmergencyContactWhereInput
    /**
     * Limit how many EmergencyContacts to delete.
     */
    limit?: number
  }

  /**
   * EmergencyContact without action
   */
  export type EmergencyContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmergencyContact
     */
    select?: EmergencyContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmergencyContact
     */
    omit?: EmergencyContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyContactInclude<ExtArgs> | null
  }


  /**
   * Model DependentMember
   */

  export type AggregateDependentMember = {
    _count: DependentMemberCountAggregateOutputType | null
    _avg: DependentMemberAvgAggregateOutputType | null
    _sum: DependentMemberSumAggregateOutputType | null
    _min: DependentMemberMinAggregateOutputType | null
    _max: DependentMemberMaxAggregateOutputType | null
  }

  export type DependentMemberAvgAggregateOutputType = {
    id: number | null
  }

  export type DependentMemberSumAggregateOutputType = {
    id: number | null
  }

  export type DependentMemberMinAggregateOutputType = {
    id: number | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    birthDate: Date | null
    relationship: string | null
    isStudent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DependentMemberMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    birthDate: Date | null
    relationship: string | null
    isStudent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DependentMemberCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    middleName: number
    birthDate: number
    relationship: number
    isStudent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DependentMemberAvgAggregateInputType = {
    id?: true
  }

  export type DependentMemberSumAggregateInputType = {
    id?: true
  }

  export type DependentMemberMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    birthDate?: true
    relationship?: true
    isStudent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DependentMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    birthDate?: true
    relationship?: true
    isStudent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DependentMemberCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    birthDate?: true
    relationship?: true
    isStudent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DependentMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DependentMember to aggregate.
     */
    where?: DependentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DependentMembers to fetch.
     */
    orderBy?: DependentMemberOrderByWithRelationInput | DependentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DependentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DependentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DependentMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DependentMembers
    **/
    _count?: true | DependentMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DependentMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DependentMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DependentMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DependentMemberMaxAggregateInputType
  }

  export type GetDependentMemberAggregateType<T extends DependentMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateDependentMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDependentMember[P]>
      : GetScalarType<T[P], AggregateDependentMember[P]>
  }




  export type DependentMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DependentMemberWhereInput
    orderBy?: DependentMemberOrderByWithAggregationInput | DependentMemberOrderByWithAggregationInput[]
    by: DependentMemberScalarFieldEnum[] | DependentMemberScalarFieldEnum
    having?: DependentMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DependentMemberCountAggregateInputType | true
    _avg?: DependentMemberAvgAggregateInputType
    _sum?: DependentMemberSumAggregateInputType
    _min?: DependentMemberMinAggregateInputType
    _max?: DependentMemberMaxAggregateInputType
  }

  export type DependentMemberGroupByOutputType = {
    id: number
    userId: string
    firstName: string
    lastName: string
    middleName: string | null
    birthDate: Date
    relationship: string
    isStudent: boolean
    createdAt: Date
    updatedAt: Date
    _count: DependentMemberCountAggregateOutputType | null
    _avg: DependentMemberAvgAggregateOutputType | null
    _sum: DependentMemberSumAggregateOutputType | null
    _min: DependentMemberMinAggregateOutputType | null
    _max: DependentMemberMaxAggregateOutputType | null
  }

  type GetDependentMemberGroupByPayload<T extends DependentMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DependentMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DependentMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DependentMemberGroupByOutputType[P]>
            : GetScalarType<T[P], DependentMemberGroupByOutputType[P]>
        }
      >
    >


  export type DependentMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    birthDate?: boolean
    relationship?: boolean
    isStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Document?: boolean | DependentMember$DocumentArgs<ExtArgs>
    _count?: boolean | DependentMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependentMember"]>

  export type DependentMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    birthDate?: boolean
    relationship?: boolean
    isStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependentMember"]>

  export type DependentMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    birthDate?: boolean
    relationship?: boolean
    isStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependentMember"]>

  export type DependentMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    birthDate?: boolean
    relationship?: boolean
    isStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DependentMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "middleName" | "birthDate" | "relationship" | "isStudent" | "createdAt" | "updatedAt", ExtArgs["result"]["dependentMember"]>
  export type DependentMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Document?: boolean | DependentMember$DocumentArgs<ExtArgs>
    _count?: boolean | DependentMemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DependentMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DependentMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DependentMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DependentMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Document: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      firstName: string
      lastName: string
      middleName: string | null
      birthDate: Date
      relationship: string
      isStudent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dependentMember"]>
    composites: {}
  }

  type DependentMemberGetPayload<S extends boolean | null | undefined | DependentMemberDefaultArgs> = $Result.GetResult<Prisma.$DependentMemberPayload, S>

  type DependentMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DependentMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DependentMemberCountAggregateInputType | true
    }

  export interface DependentMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DependentMember'], meta: { name: 'DependentMember' } }
    /**
     * Find zero or one DependentMember that matches the filter.
     * @param {DependentMemberFindUniqueArgs} args - Arguments to find a DependentMember
     * @example
     * // Get one DependentMember
     * const dependentMember = await prisma.dependentMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DependentMemberFindUniqueArgs>(args: SelectSubset<T, DependentMemberFindUniqueArgs<ExtArgs>>): Prisma__DependentMemberClient<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DependentMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DependentMemberFindUniqueOrThrowArgs} args - Arguments to find a DependentMember
     * @example
     * // Get one DependentMember
     * const dependentMember = await prisma.dependentMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DependentMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, DependentMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DependentMemberClient<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DependentMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentMemberFindFirstArgs} args - Arguments to find a DependentMember
     * @example
     * // Get one DependentMember
     * const dependentMember = await prisma.dependentMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DependentMemberFindFirstArgs>(args?: SelectSubset<T, DependentMemberFindFirstArgs<ExtArgs>>): Prisma__DependentMemberClient<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DependentMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentMemberFindFirstOrThrowArgs} args - Arguments to find a DependentMember
     * @example
     * // Get one DependentMember
     * const dependentMember = await prisma.dependentMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DependentMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, DependentMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__DependentMemberClient<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DependentMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DependentMembers
     * const dependentMembers = await prisma.dependentMember.findMany()
     * 
     * // Get first 10 DependentMembers
     * const dependentMembers = await prisma.dependentMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dependentMemberWithIdOnly = await prisma.dependentMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DependentMemberFindManyArgs>(args?: SelectSubset<T, DependentMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DependentMember.
     * @param {DependentMemberCreateArgs} args - Arguments to create a DependentMember.
     * @example
     * // Create one DependentMember
     * const DependentMember = await prisma.dependentMember.create({
     *   data: {
     *     // ... data to create a DependentMember
     *   }
     * })
     * 
     */
    create<T extends DependentMemberCreateArgs>(args: SelectSubset<T, DependentMemberCreateArgs<ExtArgs>>): Prisma__DependentMemberClient<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DependentMembers.
     * @param {DependentMemberCreateManyArgs} args - Arguments to create many DependentMembers.
     * @example
     * // Create many DependentMembers
     * const dependentMember = await prisma.dependentMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DependentMemberCreateManyArgs>(args?: SelectSubset<T, DependentMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DependentMembers and returns the data saved in the database.
     * @param {DependentMemberCreateManyAndReturnArgs} args - Arguments to create many DependentMembers.
     * @example
     * // Create many DependentMembers
     * const dependentMember = await prisma.dependentMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DependentMembers and only return the `id`
     * const dependentMemberWithIdOnly = await prisma.dependentMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DependentMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, DependentMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DependentMember.
     * @param {DependentMemberDeleteArgs} args - Arguments to delete one DependentMember.
     * @example
     * // Delete one DependentMember
     * const DependentMember = await prisma.dependentMember.delete({
     *   where: {
     *     // ... filter to delete one DependentMember
     *   }
     * })
     * 
     */
    delete<T extends DependentMemberDeleteArgs>(args: SelectSubset<T, DependentMemberDeleteArgs<ExtArgs>>): Prisma__DependentMemberClient<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DependentMember.
     * @param {DependentMemberUpdateArgs} args - Arguments to update one DependentMember.
     * @example
     * // Update one DependentMember
     * const dependentMember = await prisma.dependentMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DependentMemberUpdateArgs>(args: SelectSubset<T, DependentMemberUpdateArgs<ExtArgs>>): Prisma__DependentMemberClient<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DependentMembers.
     * @param {DependentMemberDeleteManyArgs} args - Arguments to filter DependentMembers to delete.
     * @example
     * // Delete a few DependentMembers
     * const { count } = await prisma.dependentMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DependentMemberDeleteManyArgs>(args?: SelectSubset<T, DependentMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DependentMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DependentMembers
     * const dependentMember = await prisma.dependentMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DependentMemberUpdateManyArgs>(args: SelectSubset<T, DependentMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DependentMembers and returns the data updated in the database.
     * @param {DependentMemberUpdateManyAndReturnArgs} args - Arguments to update many DependentMembers.
     * @example
     * // Update many DependentMembers
     * const dependentMember = await prisma.dependentMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DependentMembers and only return the `id`
     * const dependentMemberWithIdOnly = await prisma.dependentMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DependentMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, DependentMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DependentMember.
     * @param {DependentMemberUpsertArgs} args - Arguments to update or create a DependentMember.
     * @example
     * // Update or create a DependentMember
     * const dependentMember = await prisma.dependentMember.upsert({
     *   create: {
     *     // ... data to create a DependentMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DependentMember we want to update
     *   }
     * })
     */
    upsert<T extends DependentMemberUpsertArgs>(args: SelectSubset<T, DependentMemberUpsertArgs<ExtArgs>>): Prisma__DependentMemberClient<$Result.GetResult<Prisma.$DependentMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DependentMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentMemberCountArgs} args - Arguments to filter DependentMembers to count.
     * @example
     * // Count the number of DependentMembers
     * const count = await prisma.dependentMember.count({
     *   where: {
     *     // ... the filter for the DependentMembers we want to count
     *   }
     * })
    **/
    count<T extends DependentMemberCountArgs>(
      args?: Subset<T, DependentMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DependentMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DependentMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DependentMemberAggregateArgs>(args: Subset<T, DependentMemberAggregateArgs>): Prisma.PrismaPromise<GetDependentMemberAggregateType<T>>

    /**
     * Group by DependentMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DependentMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DependentMemberGroupByArgs['orderBy'] }
        : { orderBy?: DependentMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DependentMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDependentMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DependentMember model
   */
  readonly fields: DependentMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DependentMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DependentMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Document<T extends DependentMember$DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DependentMember$DocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DependentMember model
   */ 
  interface DependentMemberFieldRefs {
    readonly id: FieldRef<"DependentMember", 'Int'>
    readonly userId: FieldRef<"DependentMember", 'String'>
    readonly firstName: FieldRef<"DependentMember", 'String'>
    readonly lastName: FieldRef<"DependentMember", 'String'>
    readonly middleName: FieldRef<"DependentMember", 'String'>
    readonly birthDate: FieldRef<"DependentMember", 'DateTime'>
    readonly relationship: FieldRef<"DependentMember", 'String'>
    readonly isStudent: FieldRef<"DependentMember", 'Boolean'>
    readonly createdAt: FieldRef<"DependentMember", 'DateTime'>
    readonly updatedAt: FieldRef<"DependentMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DependentMember findUnique
   */
  export type DependentMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    /**
     * Filter, which DependentMember to fetch.
     */
    where: DependentMemberWhereUniqueInput
  }

  /**
   * DependentMember findUniqueOrThrow
   */
  export type DependentMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    /**
     * Filter, which DependentMember to fetch.
     */
    where: DependentMemberWhereUniqueInput
  }

  /**
   * DependentMember findFirst
   */
  export type DependentMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    /**
     * Filter, which DependentMember to fetch.
     */
    where?: DependentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DependentMembers to fetch.
     */
    orderBy?: DependentMemberOrderByWithRelationInput | DependentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DependentMembers.
     */
    cursor?: DependentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DependentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DependentMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DependentMembers.
     */
    distinct?: DependentMemberScalarFieldEnum | DependentMemberScalarFieldEnum[]
  }

  /**
   * DependentMember findFirstOrThrow
   */
  export type DependentMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    /**
     * Filter, which DependentMember to fetch.
     */
    where?: DependentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DependentMembers to fetch.
     */
    orderBy?: DependentMemberOrderByWithRelationInput | DependentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DependentMembers.
     */
    cursor?: DependentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DependentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DependentMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DependentMembers.
     */
    distinct?: DependentMemberScalarFieldEnum | DependentMemberScalarFieldEnum[]
  }

  /**
   * DependentMember findMany
   */
  export type DependentMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    /**
     * Filter, which DependentMembers to fetch.
     */
    where?: DependentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DependentMembers to fetch.
     */
    orderBy?: DependentMemberOrderByWithRelationInput | DependentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DependentMembers.
     */
    cursor?: DependentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DependentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DependentMembers.
     */
    skip?: number
    distinct?: DependentMemberScalarFieldEnum | DependentMemberScalarFieldEnum[]
  }

  /**
   * DependentMember create
   */
  export type DependentMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a DependentMember.
     */
    data: XOR<DependentMemberCreateInput, DependentMemberUncheckedCreateInput>
  }

  /**
   * DependentMember createMany
   */
  export type DependentMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DependentMembers.
     */
    data: DependentMemberCreateManyInput | DependentMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DependentMember createManyAndReturn
   */
  export type DependentMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * The data used to create many DependentMembers.
     */
    data: DependentMemberCreateManyInput | DependentMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DependentMember update
   */
  export type DependentMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a DependentMember.
     */
    data: XOR<DependentMemberUpdateInput, DependentMemberUncheckedUpdateInput>
    /**
     * Choose, which DependentMember to update.
     */
    where: DependentMemberWhereUniqueInput
  }

  /**
   * DependentMember updateMany
   */
  export type DependentMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DependentMembers.
     */
    data: XOR<DependentMemberUpdateManyMutationInput, DependentMemberUncheckedUpdateManyInput>
    /**
     * Filter which DependentMembers to update
     */
    where?: DependentMemberWhereInput
    /**
     * Limit how many DependentMembers to update.
     */
    limit?: number
  }

  /**
   * DependentMember updateManyAndReturn
   */
  export type DependentMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * The data used to update DependentMembers.
     */
    data: XOR<DependentMemberUpdateManyMutationInput, DependentMemberUncheckedUpdateManyInput>
    /**
     * Filter which DependentMembers to update
     */
    where?: DependentMemberWhereInput
    /**
     * Limit how many DependentMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DependentMember upsert
   */
  export type DependentMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the DependentMember to update in case it exists.
     */
    where: DependentMemberWhereUniqueInput
    /**
     * In case the DependentMember found by the `where` argument doesn't exist, create a new DependentMember with this data.
     */
    create: XOR<DependentMemberCreateInput, DependentMemberUncheckedCreateInput>
    /**
     * In case the DependentMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DependentMemberUpdateInput, DependentMemberUncheckedUpdateInput>
  }

  /**
   * DependentMember delete
   */
  export type DependentMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
    /**
     * Filter which DependentMember to delete.
     */
    where: DependentMemberWhereUniqueInput
  }

  /**
   * DependentMember deleteMany
   */
  export type DependentMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DependentMembers to delete
     */
    where?: DependentMemberWhereInput
    /**
     * Limit how many DependentMembers to delete.
     */
    limit?: number
  }

  /**
   * DependentMember.Document
   */
  export type DependentMember$DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * DependentMember without action
   */
  export type DependentMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DependentMember
     */
    select?: DependentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DependentMember
     */
    omit?: DependentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentMemberInclude<ExtArgs> | null
  }


  /**
   * Model UserEmail
   */

  export type AggregateUserEmail = {
    _count: UserEmailCountAggregateOutputType | null
    _avg: UserEmailAvgAggregateOutputType | null
    _sum: UserEmailSumAggregateOutputType | null
    _min: UserEmailMinAggregateOutputType | null
    _max: UserEmailMaxAggregateOutputType | null
  }

  export type UserEmailAvgAggregateOutputType = {
    id: number | null
  }

  export type UserEmailSumAggregateOutputType = {
    id: number | null
  }

  export type UserEmailMinAggregateOutputType = {
    id: number | null
    userId: string | null
    email: string | null
    type: $Enums.EmailType | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserEmailMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    email: string | null
    type: $Enums.EmailType | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserEmailCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    type: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserEmailAvgAggregateInputType = {
    id?: true
  }

  export type UserEmailSumAggregateInputType = {
    id?: true
  }

  export type UserEmailMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    type?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserEmailMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    type?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserEmailCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    type?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserEmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEmail to aggregate.
     */
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     */
    orderBy?: UserEmailOrderByWithRelationInput | UserEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserEmails
    **/
    _count?: true | UserEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserEmailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserEmailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserEmailMaxAggregateInputType
  }

  export type GetUserEmailAggregateType<T extends UserEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateUserEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserEmail[P]>
      : GetScalarType<T[P], AggregateUserEmail[P]>
  }




  export type UserEmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEmailWhereInput
    orderBy?: UserEmailOrderByWithAggregationInput | UserEmailOrderByWithAggregationInput[]
    by: UserEmailScalarFieldEnum[] | UserEmailScalarFieldEnum
    having?: UserEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserEmailCountAggregateInputType | true
    _avg?: UserEmailAvgAggregateInputType
    _sum?: UserEmailSumAggregateInputType
    _min?: UserEmailMinAggregateInputType
    _max?: UserEmailMaxAggregateInputType
  }

  export type UserEmailGroupByOutputType = {
    id: number
    userId: string
    email: string
    type: $Enums.EmailType
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserEmailCountAggregateOutputType | null
    _avg: UserEmailAvgAggregateOutputType | null
    _sum: UserEmailSumAggregateOutputType | null
    _min: UserEmailMinAggregateOutputType | null
    _max: UserEmailMaxAggregateOutputType | null
  }

  type GetUserEmailGroupByPayload<T extends UserEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserEmailGroupByOutputType[P]>
            : GetScalarType<T[P], UserEmailGroupByOutputType[P]>
        }
      >
    >


  export type UserEmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    type?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmail"]>

  export type UserEmailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    type?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmail"]>

  export type UserEmailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    type?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmail"]>

  export type UserEmailSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    type?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserEmailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "email" | "type" | "isPrimary" | "createdAt" | "updatedAt", ExtArgs["result"]["userEmail"]>
  export type UserEmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserEmailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserEmailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserEmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserEmail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      email: string
      type: $Enums.EmailType
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userEmail"]>
    composites: {}
  }

  type UserEmailGetPayload<S extends boolean | null | undefined | UserEmailDefaultArgs> = $Result.GetResult<Prisma.$UserEmailPayload, S>

  type UserEmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserEmailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserEmailCountAggregateInputType | true
    }

  export interface UserEmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserEmail'], meta: { name: 'UserEmail' } }
    /**
     * Find zero or one UserEmail that matches the filter.
     * @param {UserEmailFindUniqueArgs} args - Arguments to find a UserEmail
     * @example
     * // Get one UserEmail
     * const userEmail = await prisma.userEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserEmailFindUniqueArgs>(args: SelectSubset<T, UserEmailFindUniqueArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserEmail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserEmailFindUniqueOrThrowArgs} args - Arguments to find a UserEmail
     * @example
     * // Get one UserEmail
     * const userEmail = await prisma.userEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserEmailFindUniqueOrThrowArgs>(args: SelectSubset<T, UserEmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailFindFirstArgs} args - Arguments to find a UserEmail
     * @example
     * // Get one UserEmail
     * const userEmail = await prisma.userEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserEmailFindFirstArgs>(args?: SelectSubset<T, UserEmailFindFirstArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserEmail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailFindFirstOrThrowArgs} args - Arguments to find a UserEmail
     * @example
     * // Get one UserEmail
     * const userEmail = await prisma.userEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserEmailFindFirstOrThrowArgs>(args?: SelectSubset<T, UserEmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserEmails
     * const userEmails = await prisma.userEmail.findMany()
     * 
     * // Get first 10 UserEmails
     * const userEmails = await prisma.userEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userEmailWithIdOnly = await prisma.userEmail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserEmailFindManyArgs>(args?: SelectSubset<T, UserEmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserEmail.
     * @param {UserEmailCreateArgs} args - Arguments to create a UserEmail.
     * @example
     * // Create one UserEmail
     * const UserEmail = await prisma.userEmail.create({
     *   data: {
     *     // ... data to create a UserEmail
     *   }
     * })
     * 
     */
    create<T extends UserEmailCreateArgs>(args: SelectSubset<T, UserEmailCreateArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserEmails.
     * @param {UserEmailCreateManyArgs} args - Arguments to create many UserEmails.
     * @example
     * // Create many UserEmails
     * const userEmail = await prisma.userEmail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserEmailCreateManyArgs>(args?: SelectSubset<T, UserEmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserEmails and returns the data saved in the database.
     * @param {UserEmailCreateManyAndReturnArgs} args - Arguments to create many UserEmails.
     * @example
     * // Create many UserEmails
     * const userEmail = await prisma.userEmail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserEmails and only return the `id`
     * const userEmailWithIdOnly = await prisma.userEmail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserEmailCreateManyAndReturnArgs>(args?: SelectSubset<T, UserEmailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserEmail.
     * @param {UserEmailDeleteArgs} args - Arguments to delete one UserEmail.
     * @example
     * // Delete one UserEmail
     * const UserEmail = await prisma.userEmail.delete({
     *   where: {
     *     // ... filter to delete one UserEmail
     *   }
     * })
     * 
     */
    delete<T extends UserEmailDeleteArgs>(args: SelectSubset<T, UserEmailDeleteArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserEmail.
     * @param {UserEmailUpdateArgs} args - Arguments to update one UserEmail.
     * @example
     * // Update one UserEmail
     * const userEmail = await prisma.userEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserEmailUpdateArgs>(args: SelectSubset<T, UserEmailUpdateArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserEmails.
     * @param {UserEmailDeleteManyArgs} args - Arguments to filter UserEmails to delete.
     * @example
     * // Delete a few UserEmails
     * const { count } = await prisma.userEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserEmailDeleteManyArgs>(args?: SelectSubset<T, UserEmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserEmails
     * const userEmail = await prisma.userEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserEmailUpdateManyArgs>(args: SelectSubset<T, UserEmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEmails and returns the data updated in the database.
     * @param {UserEmailUpdateManyAndReturnArgs} args - Arguments to update many UserEmails.
     * @example
     * // Update many UserEmails
     * const userEmail = await prisma.userEmail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserEmails and only return the `id`
     * const userEmailWithIdOnly = await prisma.userEmail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserEmailUpdateManyAndReturnArgs>(args: SelectSubset<T, UserEmailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserEmail.
     * @param {UserEmailUpsertArgs} args - Arguments to update or create a UserEmail.
     * @example
     * // Update or create a UserEmail
     * const userEmail = await prisma.userEmail.upsert({
     *   create: {
     *     // ... data to create a UserEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserEmail we want to update
     *   }
     * })
     */
    upsert<T extends UserEmailUpsertArgs>(args: SelectSubset<T, UserEmailUpsertArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailCountArgs} args - Arguments to filter UserEmails to count.
     * @example
     * // Count the number of UserEmails
     * const count = await prisma.userEmail.count({
     *   where: {
     *     // ... the filter for the UserEmails we want to count
     *   }
     * })
    **/
    count<T extends UserEmailCountArgs>(
      args?: Subset<T, UserEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserEmailAggregateArgs>(args: Subset<T, UserEmailAggregateArgs>): Prisma.PrismaPromise<GetUserEmailAggregateType<T>>

    /**
     * Group by UserEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserEmailGroupByArgs['orderBy'] }
        : { orderBy?: UserEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserEmail model
   */
  readonly fields: UserEmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserEmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserEmail model
   */ 
  interface UserEmailFieldRefs {
    readonly id: FieldRef<"UserEmail", 'Int'>
    readonly userId: FieldRef<"UserEmail", 'String'>
    readonly email: FieldRef<"UserEmail", 'String'>
    readonly type: FieldRef<"UserEmail", 'EmailType'>
    readonly isPrimary: FieldRef<"UserEmail", 'Boolean'>
    readonly createdAt: FieldRef<"UserEmail", 'DateTime'>
    readonly updatedAt: FieldRef<"UserEmail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserEmail findUnique
   */
  export type UserEmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter, which UserEmail to fetch.
     */
    where: UserEmailWhereUniqueInput
  }

  /**
   * UserEmail findUniqueOrThrow
   */
  export type UserEmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter, which UserEmail to fetch.
     */
    where: UserEmailWhereUniqueInput
  }

  /**
   * UserEmail findFirst
   */
  export type UserEmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter, which UserEmail to fetch.
     */
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     */
    orderBy?: UserEmailOrderByWithRelationInput | UserEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmails.
     */
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmails.
     */
    distinct?: UserEmailScalarFieldEnum | UserEmailScalarFieldEnum[]
  }

  /**
   * UserEmail findFirstOrThrow
   */
  export type UserEmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter, which UserEmail to fetch.
     */
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     */
    orderBy?: UserEmailOrderByWithRelationInput | UserEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmails.
     */
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmails.
     */
    distinct?: UserEmailScalarFieldEnum | UserEmailScalarFieldEnum[]
  }

  /**
   * UserEmail findMany
   */
  export type UserEmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter, which UserEmails to fetch.
     */
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     */
    orderBy?: UserEmailOrderByWithRelationInput | UserEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserEmails.
     */
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     */
    skip?: number
    distinct?: UserEmailScalarFieldEnum | UserEmailScalarFieldEnum[]
  }

  /**
   * UserEmail create
   */
  export type UserEmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * The data needed to create a UserEmail.
     */
    data: XOR<UserEmailCreateInput, UserEmailUncheckedCreateInput>
  }

  /**
   * UserEmail createMany
   */
  export type UserEmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserEmails.
     */
    data: UserEmailCreateManyInput | UserEmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserEmail createManyAndReturn
   */
  export type UserEmailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * The data used to create many UserEmails.
     */
    data: UserEmailCreateManyInput | UserEmailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEmail update
   */
  export type UserEmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * The data needed to update a UserEmail.
     */
    data: XOR<UserEmailUpdateInput, UserEmailUncheckedUpdateInput>
    /**
     * Choose, which UserEmail to update.
     */
    where: UserEmailWhereUniqueInput
  }

  /**
   * UserEmail updateMany
   */
  export type UserEmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserEmails.
     */
    data: XOR<UserEmailUpdateManyMutationInput, UserEmailUncheckedUpdateManyInput>
    /**
     * Filter which UserEmails to update
     */
    where?: UserEmailWhereInput
    /**
     * Limit how many UserEmails to update.
     */
    limit?: number
  }

  /**
   * UserEmail updateManyAndReturn
   */
  export type UserEmailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * The data used to update UserEmails.
     */
    data: XOR<UserEmailUpdateManyMutationInput, UserEmailUncheckedUpdateManyInput>
    /**
     * Filter which UserEmails to update
     */
    where?: UserEmailWhereInput
    /**
     * Limit how many UserEmails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEmail upsert
   */
  export type UserEmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * The filter to search for the UserEmail to update in case it exists.
     */
    where: UserEmailWhereUniqueInput
    /**
     * In case the UserEmail found by the `where` argument doesn't exist, create a new UserEmail with this data.
     */
    create: XOR<UserEmailCreateInput, UserEmailUncheckedCreateInput>
    /**
     * In case the UserEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserEmailUpdateInput, UserEmailUncheckedUpdateInput>
  }

  /**
   * UserEmail delete
   */
  export type UserEmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter which UserEmail to delete.
     */
    where: UserEmailWhereUniqueInput
  }

  /**
   * UserEmail deleteMany
   */
  export type UserEmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEmails to delete
     */
    where?: UserEmailWhereInput
    /**
     * Limit how many UserEmails to delete.
     */
    limit?: number
  }

  /**
   * UserEmail without action
   */
  export type UserEmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEmail
     */
    omit?: UserEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
  }


  /**
   * Model UserPhone
   */

  export type AggregateUserPhone = {
    _count: UserPhoneCountAggregateOutputType | null
    _avg: UserPhoneAvgAggregateOutputType | null
    _sum: UserPhoneSumAggregateOutputType | null
    _min: UserPhoneMinAggregateOutputType | null
    _max: UserPhoneMaxAggregateOutputType | null
  }

  export type UserPhoneAvgAggregateOutputType = {
    id: number | null
  }

  export type UserPhoneSumAggregateOutputType = {
    id: number | null
  }

  export type UserPhoneMinAggregateOutputType = {
    id: number | null
    userId: string | null
    phoneNumber: string | null
    countryCode: string | null
    type: $Enums.PhoneType | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPhoneMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    phoneNumber: string | null
    countryCode: string | null
    type: $Enums.PhoneType | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPhoneCountAggregateOutputType = {
    id: number
    userId: number
    phoneNumber: number
    countryCode: number
    type: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPhoneAvgAggregateInputType = {
    id?: true
  }

  export type UserPhoneSumAggregateInputType = {
    id?: true
  }

  export type UserPhoneMinAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    countryCode?: true
    type?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPhoneMaxAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    countryCode?: true
    type?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPhoneCountAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    countryCode?: true
    type?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPhoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhone to aggregate.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPhones
    **/
    _count?: true | UserPhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPhoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPhoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPhoneMaxAggregateInputType
  }

  export type GetUserPhoneAggregateType<T extends UserPhoneAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPhone[P]>
      : GetScalarType<T[P], AggregateUserPhone[P]>
  }




  export type UserPhoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhoneWhereInput
    orderBy?: UserPhoneOrderByWithAggregationInput | UserPhoneOrderByWithAggregationInput[]
    by: UserPhoneScalarFieldEnum[] | UserPhoneScalarFieldEnum
    having?: UserPhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPhoneCountAggregateInputType | true
    _avg?: UserPhoneAvgAggregateInputType
    _sum?: UserPhoneSumAggregateInputType
    _min?: UserPhoneMinAggregateInputType
    _max?: UserPhoneMaxAggregateInputType
  }

  export type UserPhoneGroupByOutputType = {
    id: number
    userId: string
    phoneNumber: string
    countryCode: string
    type: $Enums.PhoneType
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserPhoneCountAggregateOutputType | null
    _avg: UserPhoneAvgAggregateOutputType | null
    _sum: UserPhoneSumAggregateOutputType | null
    _min: UserPhoneMinAggregateOutputType | null
    _max: UserPhoneMaxAggregateOutputType | null
  }

  type GetUserPhoneGroupByPayload<T extends UserPhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPhoneGroupByOutputType[P]>
            : GetScalarType<T[P], UserPhoneGroupByOutputType[P]>
        }
      >
    >


  export type UserPhoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    countryCode?: boolean
    type?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhone"]>

  export type UserPhoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    countryCode?: boolean
    type?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhone"]>

  export type UserPhoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    countryCode?: boolean
    type?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhone"]>

  export type UserPhoneSelectScalar = {
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    countryCode?: boolean
    type?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPhoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "phoneNumber" | "countryCode" | "type" | "isPrimary" | "createdAt" | "updatedAt", ExtArgs["result"]["userPhone"]>
  export type UserPhoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPhoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPhoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPhonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPhone"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      phoneNumber: string
      countryCode: string
      type: $Enums.PhoneType
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPhone"]>
    composites: {}
  }

  type UserPhoneGetPayload<S extends boolean | null | undefined | UserPhoneDefaultArgs> = $Result.GetResult<Prisma.$UserPhonePayload, S>

  type UserPhoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPhoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPhoneCountAggregateInputType | true
    }

  export interface UserPhoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPhone'], meta: { name: 'UserPhone' } }
    /**
     * Find zero or one UserPhone that matches the filter.
     * @param {UserPhoneFindUniqueArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPhoneFindUniqueArgs>(args: SelectSubset<T, UserPhoneFindUniqueArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPhone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPhoneFindUniqueOrThrowArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPhoneFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPhoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindFirstArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPhoneFindFirstArgs>(args?: SelectSubset<T, UserPhoneFindFirstArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindFirstOrThrowArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPhoneFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPhoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPhones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPhones
     * const userPhones = await prisma.userPhone.findMany()
     * 
     * // Get first 10 UserPhones
     * const userPhones = await prisma.userPhone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPhoneWithIdOnly = await prisma.userPhone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPhoneFindManyArgs>(args?: SelectSubset<T, UserPhoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPhone.
     * @param {UserPhoneCreateArgs} args - Arguments to create a UserPhone.
     * @example
     * // Create one UserPhone
     * const UserPhone = await prisma.userPhone.create({
     *   data: {
     *     // ... data to create a UserPhone
     *   }
     * })
     * 
     */
    create<T extends UserPhoneCreateArgs>(args: SelectSubset<T, UserPhoneCreateArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPhones.
     * @param {UserPhoneCreateManyArgs} args - Arguments to create many UserPhones.
     * @example
     * // Create many UserPhones
     * const userPhone = await prisma.userPhone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPhoneCreateManyArgs>(args?: SelectSubset<T, UserPhoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPhones and returns the data saved in the database.
     * @param {UserPhoneCreateManyAndReturnArgs} args - Arguments to create many UserPhones.
     * @example
     * // Create many UserPhones
     * const userPhone = await prisma.userPhone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPhones and only return the `id`
     * const userPhoneWithIdOnly = await prisma.userPhone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPhoneCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPhoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPhone.
     * @param {UserPhoneDeleteArgs} args - Arguments to delete one UserPhone.
     * @example
     * // Delete one UserPhone
     * const UserPhone = await prisma.userPhone.delete({
     *   where: {
     *     // ... filter to delete one UserPhone
     *   }
     * })
     * 
     */
    delete<T extends UserPhoneDeleteArgs>(args: SelectSubset<T, UserPhoneDeleteArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPhone.
     * @param {UserPhoneUpdateArgs} args - Arguments to update one UserPhone.
     * @example
     * // Update one UserPhone
     * const userPhone = await prisma.userPhone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPhoneUpdateArgs>(args: SelectSubset<T, UserPhoneUpdateArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPhones.
     * @param {UserPhoneDeleteManyArgs} args - Arguments to filter UserPhones to delete.
     * @example
     * // Delete a few UserPhones
     * const { count } = await prisma.userPhone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPhoneDeleteManyArgs>(args?: SelectSubset<T, UserPhoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPhones
     * const userPhone = await prisma.userPhone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPhoneUpdateManyArgs>(args: SelectSubset<T, UserPhoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhones and returns the data updated in the database.
     * @param {UserPhoneUpdateManyAndReturnArgs} args - Arguments to update many UserPhones.
     * @example
     * // Update many UserPhones
     * const userPhone = await prisma.userPhone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPhones and only return the `id`
     * const userPhoneWithIdOnly = await prisma.userPhone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPhoneUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPhoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPhone.
     * @param {UserPhoneUpsertArgs} args - Arguments to update or create a UserPhone.
     * @example
     * // Update or create a UserPhone
     * const userPhone = await prisma.userPhone.upsert({
     *   create: {
     *     // ... data to create a UserPhone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPhone we want to update
     *   }
     * })
     */
    upsert<T extends UserPhoneUpsertArgs>(args: SelectSubset<T, UserPhoneUpsertArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneCountArgs} args - Arguments to filter UserPhones to count.
     * @example
     * // Count the number of UserPhones
     * const count = await prisma.userPhone.count({
     *   where: {
     *     // ... the filter for the UserPhones we want to count
     *   }
     * })
    **/
    count<T extends UserPhoneCountArgs>(
      args?: Subset<T, UserPhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPhoneAggregateArgs>(args: Subset<T, UserPhoneAggregateArgs>): Prisma.PrismaPromise<GetUserPhoneAggregateType<T>>

    /**
     * Group by UserPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPhoneGroupByArgs['orderBy'] }
        : { orderBy?: UserPhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPhone model
   */
  readonly fields: UserPhoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPhone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPhoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPhone model
   */ 
  interface UserPhoneFieldRefs {
    readonly id: FieldRef<"UserPhone", 'Int'>
    readonly userId: FieldRef<"UserPhone", 'String'>
    readonly phoneNumber: FieldRef<"UserPhone", 'String'>
    readonly countryCode: FieldRef<"UserPhone", 'String'>
    readonly type: FieldRef<"UserPhone", 'PhoneType'>
    readonly isPrimary: FieldRef<"UserPhone", 'Boolean'>
    readonly createdAt: FieldRef<"UserPhone", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPhone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPhone findUnique
   */
  export type UserPhoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone findUniqueOrThrow
   */
  export type UserPhoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone findFirst
   */
  export type UserPhoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhones.
     */
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * UserPhone findFirstOrThrow
   */
  export type UserPhoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhones.
     */
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * UserPhone findMany
   */
  export type UserPhoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhones to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * UserPhone create
   */
  export type UserPhoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPhone.
     */
    data: XOR<UserPhoneCreateInput, UserPhoneUncheckedCreateInput>
  }

  /**
   * UserPhone createMany
   */
  export type UserPhoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPhones.
     */
    data: UserPhoneCreateManyInput | UserPhoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPhone createManyAndReturn
   */
  export type UserPhoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * The data used to create many UserPhones.
     */
    data: UserPhoneCreateManyInput | UserPhoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPhone update
   */
  export type UserPhoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPhone.
     */
    data: XOR<UserPhoneUpdateInput, UserPhoneUncheckedUpdateInput>
    /**
     * Choose, which UserPhone to update.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone updateMany
   */
  export type UserPhoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPhones.
     */
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyInput>
    /**
     * Filter which UserPhones to update
     */
    where?: UserPhoneWhereInput
    /**
     * Limit how many UserPhones to update.
     */
    limit?: number
  }

  /**
   * UserPhone updateManyAndReturn
   */
  export type UserPhoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * The data used to update UserPhones.
     */
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyInput>
    /**
     * Filter which UserPhones to update
     */
    where?: UserPhoneWhereInput
    /**
     * Limit how many UserPhones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPhone upsert
   */
  export type UserPhoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPhone to update in case it exists.
     */
    where: UserPhoneWhereUniqueInput
    /**
     * In case the UserPhone found by the `where` argument doesn't exist, create a new UserPhone with this data.
     */
    create: XOR<UserPhoneCreateInput, UserPhoneUncheckedCreateInput>
    /**
     * In case the UserPhone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPhoneUpdateInput, UserPhoneUncheckedUpdateInput>
  }

  /**
   * UserPhone delete
   */
  export type UserPhoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter which UserPhone to delete.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone deleteMany
   */
  export type UserPhoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhones to delete
     */
    where?: UserPhoneWhereInput
    /**
     * Limit how many UserPhones to delete.
     */
    limit?: number
  }

  /**
   * UserPhone without action
   */
  export type UserPhoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
  }

  export type BankAccountSumAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
    bank: $Enums.GreekBank | null
    iban: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
    bank: $Enums.GreekBank | null
    iban: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    personalInfoId: number
    bank: number
    iban: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    id?: true
    personalInfoId?: true
  }

  export type BankAccountSumAggregateInputType = {
    id?: true
    personalInfoId?: true
  }

  export type BankAccountMinAggregateInputType = {
    id?: true
    personalInfoId?: true
    bank?: true
    iban?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    personalInfoId?: true
    bank?: true
    iban?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    personalInfoId?: true
    bank?: true
    iban?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: number
    personalInfoId: number
    bank: $Enums.GreekBank
    iban: string
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    bank?: boolean
    iban?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    bank?: boolean
    iban?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    bank?: boolean
    iban?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectScalar = {
    id?: boolean
    personalInfoId?: boolean
    bank?: boolean
    iban?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personalInfoId" | "bank" | "iban" | "isPrimary" | "createdAt" | "updatedAt", ExtArgs["result"]["bankAccount"]>
  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }
  export type BankAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }
  export type BankAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }

  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      personalInfo: Prisma.$PersonalInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      personalInfoId: number
      bank: $Enums.GreekBank
      iban: string
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankAccounts and returns the data saved in the database.
     * @param {BankAccountCreateManyAndReturnArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, BankAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts and returns the data updated in the database.
     * @param {BankAccountUpdateManyAndReturnArgs} args - Arguments to update many BankAccounts.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, BankAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalInfo<T extends PersonalInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalInfoDefaultArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */ 
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'Int'>
    readonly personalInfoId: FieldRef<"BankAccount", 'Int'>
    readonly bank: FieldRef<"BankAccount", 'GreekBank'>
    readonly iban: FieldRef<"BankAccount", 'String'>
    readonly isPrimary: FieldRef<"BankAccount", 'Boolean'>
    readonly createdAt: FieldRef<"BankAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"BankAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount createManyAndReturn
   */
  export type BankAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
  }

  /**
   * BankAccount updateManyAndReturn
   */
  export type BankAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to delete.
     */
    limit?: number
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    id: number | null
    onboardingId: number | null
  }

  export type ContractSumAggregateOutputType = {
    id: number | null
    onboardingId: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: number | null
    onboardingId: number | null
    draftKey: string | null
    signedKey: string | null
    uploadedAt: Date | null
    signedAt: Date | null
    status: $Enums.ContractStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractMaxAggregateOutputType = {
    id: number | null
    onboardingId: number | null
    draftKey: string | null
    signedKey: string | null
    uploadedAt: Date | null
    signedAt: Date | null
    status: $Enums.ContractStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    onboardingId: number
    draftKey: number
    signedKey: number
    uploadedAt: number
    signedAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    id?: true
    onboardingId?: true
  }

  export type ContractSumAggregateInputType = {
    id?: true
    onboardingId?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    onboardingId?: true
    draftKey?: true
    signedKey?: true
    uploadedAt?: true
    signedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    onboardingId?: true
    draftKey?: true
    signedKey?: true
    uploadedAt?: true
    signedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    onboardingId?: true
    draftKey?: true
    signedKey?: true
    uploadedAt?: true
    signedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: number
    onboardingId: number
    draftKey: string | null
    signedKey: string | null
    uploadedAt: Date
    signedAt: Date | null
    status: $Enums.ContractStatus
    createdAt: Date
    updatedAt: Date
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onboardingId?: boolean
    draftKey?: boolean
    signedKey?: boolean
    uploadedAt?: boolean
    signedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    onboarding?: boolean | OnboardingProgressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onboardingId?: boolean
    draftKey?: boolean
    signedKey?: boolean
    uploadedAt?: boolean
    signedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    onboarding?: boolean | OnboardingProgressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onboardingId?: boolean
    draftKey?: boolean
    signedKey?: boolean
    uploadedAt?: boolean
    signedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    onboarding?: boolean | OnboardingProgressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    onboardingId?: boolean
    draftKey?: boolean
    signedKey?: boolean
    uploadedAt?: boolean
    signedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "onboardingId" | "draftKey" | "signedKey" | "uploadedAt" | "signedAt" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["contract"]>
  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    onboarding?: boolean | OnboardingProgressDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    onboarding?: boolean | OnboardingProgressDefaultArgs<ExtArgs>
  }
  export type ContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    onboarding?: boolean | OnboardingProgressDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      onboarding: Prisma.$OnboardingProgressPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      onboardingId: number
      draftKey: string | null
      signedKey: string | null
      uploadedAt: Date
      signedAt: Date | null
      status: $Enums.ContractStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts and returns the data updated in the database.
     * @param {ContractUpdateManyAndReturnArgs} args - Arguments to update many Contracts.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    onboarding<T extends OnboardingProgressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OnboardingProgressDefaultArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */ 
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'Int'>
    readonly onboardingId: FieldRef<"Contract", 'Int'>
    readonly draftKey: FieldRef<"Contract", 'String'>
    readonly signedKey: FieldRef<"Contract", 'String'>
    readonly uploadedAt: FieldRef<"Contract", 'DateTime'>
    readonly signedAt: FieldRef<"Contract", 'DateTime'>
    readonly status: FieldRef<"Contract", 'ContractStatus'>
    readonly createdAt: FieldRef<"Contract", 'DateTime'>
    readonly updatedAt: FieldRef<"Contract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
  }

  /**
   * Contract updateManyAndReturn
   */
  export type ContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to delete.
     */
    limit?: number
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model LanguageSkill
   */

  export type AggregateLanguageSkill = {
    _count: LanguageSkillCountAggregateOutputType | null
    _avg: LanguageSkillAvgAggregateOutputType | null
    _sum: LanguageSkillSumAggregateOutputType | null
    _min: LanguageSkillMinAggregateOutputType | null
    _max: LanguageSkillMaxAggregateOutputType | null
  }

  export type LanguageSkillAvgAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
  }

  export type LanguageSkillSumAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
  }

  export type LanguageSkillMinAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
    language: $Enums.Language | null
    proficiency: $Enums.Proficiency | null
    certificate: string | null
    issueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageSkillMaxAggregateOutputType = {
    id: number | null
    personalInfoId: number | null
    language: $Enums.Language | null
    proficiency: $Enums.Proficiency | null
    certificate: string | null
    issueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageSkillCountAggregateOutputType = {
    id: number
    personalInfoId: number
    language: number
    proficiency: number
    certificate: number
    issueDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LanguageSkillAvgAggregateInputType = {
    id?: true
    personalInfoId?: true
  }

  export type LanguageSkillSumAggregateInputType = {
    id?: true
    personalInfoId?: true
  }

  export type LanguageSkillMinAggregateInputType = {
    id?: true
    personalInfoId?: true
    language?: true
    proficiency?: true
    certificate?: true
    issueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageSkillMaxAggregateInputType = {
    id?: true
    personalInfoId?: true
    language?: true
    proficiency?: true
    certificate?: true
    issueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageSkillCountAggregateInputType = {
    id?: true
    personalInfoId?: true
    language?: true
    proficiency?: true
    certificate?: true
    issueDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LanguageSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LanguageSkill to aggregate.
     */
    where?: LanguageSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageSkills to fetch.
     */
    orderBy?: LanguageSkillOrderByWithRelationInput | LanguageSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LanguageSkills
    **/
    _count?: true | LanguageSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageSkillMaxAggregateInputType
  }

  export type GetLanguageSkillAggregateType<T extends LanguageSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguageSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguageSkill[P]>
      : GetScalarType<T[P], AggregateLanguageSkill[P]>
  }




  export type LanguageSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageSkillWhereInput
    orderBy?: LanguageSkillOrderByWithAggregationInput | LanguageSkillOrderByWithAggregationInput[]
    by: LanguageSkillScalarFieldEnum[] | LanguageSkillScalarFieldEnum
    having?: LanguageSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageSkillCountAggregateInputType | true
    _avg?: LanguageSkillAvgAggregateInputType
    _sum?: LanguageSkillSumAggregateInputType
    _min?: LanguageSkillMinAggregateInputType
    _max?: LanguageSkillMaxAggregateInputType
  }

  export type LanguageSkillGroupByOutputType = {
    id: number
    personalInfoId: number
    language: $Enums.Language
    proficiency: $Enums.Proficiency
    certificate: string | null
    issueDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LanguageSkillCountAggregateOutputType | null
    _avg: LanguageSkillAvgAggregateOutputType | null
    _sum: LanguageSkillSumAggregateOutputType | null
    _min: LanguageSkillMinAggregateOutputType | null
    _max: LanguageSkillMaxAggregateOutputType | null
  }

  type GetLanguageSkillGroupByPayload<T extends LanguageSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageSkillGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageSkillGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    language?: boolean
    proficiency?: boolean
    certificate?: boolean
    issueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
    documents?: boolean | LanguageSkill$documentsArgs<ExtArgs>
    _count?: boolean | LanguageSkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languageSkill"]>

  export type LanguageSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    language?: boolean
    proficiency?: boolean
    certificate?: boolean
    issueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languageSkill"]>

  export type LanguageSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalInfoId?: boolean
    language?: boolean
    proficiency?: boolean
    certificate?: boolean
    issueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languageSkill"]>

  export type LanguageSkillSelectScalar = {
    id?: boolean
    personalInfoId?: boolean
    language?: boolean
    proficiency?: boolean
    certificate?: boolean
    issueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LanguageSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personalInfoId" | "language" | "proficiency" | "certificate" | "issueDate" | "createdAt" | "updatedAt", ExtArgs["result"]["languageSkill"]>
  export type LanguageSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
    documents?: boolean | LanguageSkill$documentsArgs<ExtArgs>
    _count?: boolean | LanguageSkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }
  export type LanguageSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalInfo?: boolean | PersonalInfoDefaultArgs<ExtArgs>
  }

  export type $LanguageSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LanguageSkill"
    objects: {
      personalInfo: Prisma.$PersonalInfoPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      personalInfoId: number
      language: $Enums.Language
      proficiency: $Enums.Proficiency
      certificate: string | null
      issueDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["languageSkill"]>
    composites: {}
  }

  type LanguageSkillGetPayload<S extends boolean | null | undefined | LanguageSkillDefaultArgs> = $Result.GetResult<Prisma.$LanguageSkillPayload, S>

  type LanguageSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageSkillCountAggregateInputType | true
    }

  export interface LanguageSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LanguageSkill'], meta: { name: 'LanguageSkill' } }
    /**
     * Find zero or one LanguageSkill that matches the filter.
     * @param {LanguageSkillFindUniqueArgs} args - Arguments to find a LanguageSkill
     * @example
     * // Get one LanguageSkill
     * const languageSkill = await prisma.languageSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageSkillFindUniqueArgs>(args: SelectSubset<T, LanguageSkillFindUniqueArgs<ExtArgs>>): Prisma__LanguageSkillClient<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LanguageSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageSkillFindUniqueOrThrowArgs} args - Arguments to find a LanguageSkill
     * @example
     * // Get one LanguageSkill
     * const languageSkill = await prisma.languageSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageSkillClient<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LanguageSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSkillFindFirstArgs} args - Arguments to find a LanguageSkill
     * @example
     * // Get one LanguageSkill
     * const languageSkill = await prisma.languageSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageSkillFindFirstArgs>(args?: SelectSubset<T, LanguageSkillFindFirstArgs<ExtArgs>>): Prisma__LanguageSkillClient<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LanguageSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSkillFindFirstOrThrowArgs} args - Arguments to find a LanguageSkill
     * @example
     * // Get one LanguageSkill
     * const languageSkill = await prisma.languageSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageSkillClient<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LanguageSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LanguageSkills
     * const languageSkills = await prisma.languageSkill.findMany()
     * 
     * // Get first 10 LanguageSkills
     * const languageSkills = await prisma.languageSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageSkillWithIdOnly = await prisma.languageSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageSkillFindManyArgs>(args?: SelectSubset<T, LanguageSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LanguageSkill.
     * @param {LanguageSkillCreateArgs} args - Arguments to create a LanguageSkill.
     * @example
     * // Create one LanguageSkill
     * const LanguageSkill = await prisma.languageSkill.create({
     *   data: {
     *     // ... data to create a LanguageSkill
     *   }
     * })
     * 
     */
    create<T extends LanguageSkillCreateArgs>(args: SelectSubset<T, LanguageSkillCreateArgs<ExtArgs>>): Prisma__LanguageSkillClient<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LanguageSkills.
     * @param {LanguageSkillCreateManyArgs} args - Arguments to create many LanguageSkills.
     * @example
     * // Create many LanguageSkills
     * const languageSkill = await prisma.languageSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageSkillCreateManyArgs>(args?: SelectSubset<T, LanguageSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LanguageSkills and returns the data saved in the database.
     * @param {LanguageSkillCreateManyAndReturnArgs} args - Arguments to create many LanguageSkills.
     * @example
     * // Create many LanguageSkills
     * const languageSkill = await prisma.languageSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LanguageSkills and only return the `id`
     * const languageSkillWithIdOnly = await prisma.languageSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LanguageSkill.
     * @param {LanguageSkillDeleteArgs} args - Arguments to delete one LanguageSkill.
     * @example
     * // Delete one LanguageSkill
     * const LanguageSkill = await prisma.languageSkill.delete({
     *   where: {
     *     // ... filter to delete one LanguageSkill
     *   }
     * })
     * 
     */
    delete<T extends LanguageSkillDeleteArgs>(args: SelectSubset<T, LanguageSkillDeleteArgs<ExtArgs>>): Prisma__LanguageSkillClient<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LanguageSkill.
     * @param {LanguageSkillUpdateArgs} args - Arguments to update one LanguageSkill.
     * @example
     * // Update one LanguageSkill
     * const languageSkill = await prisma.languageSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageSkillUpdateArgs>(args: SelectSubset<T, LanguageSkillUpdateArgs<ExtArgs>>): Prisma__LanguageSkillClient<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LanguageSkills.
     * @param {LanguageSkillDeleteManyArgs} args - Arguments to filter LanguageSkills to delete.
     * @example
     * // Delete a few LanguageSkills
     * const { count } = await prisma.languageSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageSkillDeleteManyArgs>(args?: SelectSubset<T, LanguageSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LanguageSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LanguageSkills
     * const languageSkill = await prisma.languageSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageSkillUpdateManyArgs>(args: SelectSubset<T, LanguageSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LanguageSkills and returns the data updated in the database.
     * @param {LanguageSkillUpdateManyAndReturnArgs} args - Arguments to update many LanguageSkills.
     * @example
     * // Update many LanguageSkills
     * const languageSkill = await prisma.languageSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LanguageSkills and only return the `id`
     * const languageSkillWithIdOnly = await prisma.languageSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LanguageSkill.
     * @param {LanguageSkillUpsertArgs} args - Arguments to update or create a LanguageSkill.
     * @example
     * // Update or create a LanguageSkill
     * const languageSkill = await prisma.languageSkill.upsert({
     *   create: {
     *     // ... data to create a LanguageSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LanguageSkill we want to update
     *   }
     * })
     */
    upsert<T extends LanguageSkillUpsertArgs>(args: SelectSubset<T, LanguageSkillUpsertArgs<ExtArgs>>): Prisma__LanguageSkillClient<$Result.GetResult<Prisma.$LanguageSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LanguageSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSkillCountArgs} args - Arguments to filter LanguageSkills to count.
     * @example
     * // Count the number of LanguageSkills
     * const count = await prisma.languageSkill.count({
     *   where: {
     *     // ... the filter for the LanguageSkills we want to count
     *   }
     * })
    **/
    count<T extends LanguageSkillCountArgs>(
      args?: Subset<T, LanguageSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LanguageSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageSkillAggregateArgs>(args: Subset<T, LanguageSkillAggregateArgs>): Prisma.PrismaPromise<GetLanguageSkillAggregateType<T>>

    /**
     * Group by LanguageSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageSkillGroupByArgs['orderBy'] }
        : { orderBy?: LanguageSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LanguageSkill model
   */
  readonly fields: LanguageSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LanguageSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalInfo<T extends PersonalInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalInfoDefaultArgs<ExtArgs>>): Prisma__PersonalInfoClient<$Result.GetResult<Prisma.$PersonalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    documents<T extends LanguageSkill$documentsArgs<ExtArgs> = {}>(args?: Subset<T, LanguageSkill$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LanguageSkill model
   */ 
  interface LanguageSkillFieldRefs {
    readonly id: FieldRef<"LanguageSkill", 'Int'>
    readonly personalInfoId: FieldRef<"LanguageSkill", 'Int'>
    readonly language: FieldRef<"LanguageSkill", 'Language'>
    readonly proficiency: FieldRef<"LanguageSkill", 'Proficiency'>
    readonly certificate: FieldRef<"LanguageSkill", 'String'>
    readonly issueDate: FieldRef<"LanguageSkill", 'DateTime'>
    readonly createdAt: FieldRef<"LanguageSkill", 'DateTime'>
    readonly updatedAt: FieldRef<"LanguageSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LanguageSkill findUnique
   */
  export type LanguageSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    /**
     * Filter, which LanguageSkill to fetch.
     */
    where: LanguageSkillWhereUniqueInput
  }

  /**
   * LanguageSkill findUniqueOrThrow
   */
  export type LanguageSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    /**
     * Filter, which LanguageSkill to fetch.
     */
    where: LanguageSkillWhereUniqueInput
  }

  /**
   * LanguageSkill findFirst
   */
  export type LanguageSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    /**
     * Filter, which LanguageSkill to fetch.
     */
    where?: LanguageSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageSkills to fetch.
     */
    orderBy?: LanguageSkillOrderByWithRelationInput | LanguageSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LanguageSkills.
     */
    cursor?: LanguageSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LanguageSkills.
     */
    distinct?: LanguageSkillScalarFieldEnum | LanguageSkillScalarFieldEnum[]
  }

  /**
   * LanguageSkill findFirstOrThrow
   */
  export type LanguageSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    /**
     * Filter, which LanguageSkill to fetch.
     */
    where?: LanguageSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageSkills to fetch.
     */
    orderBy?: LanguageSkillOrderByWithRelationInput | LanguageSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LanguageSkills.
     */
    cursor?: LanguageSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LanguageSkills.
     */
    distinct?: LanguageSkillScalarFieldEnum | LanguageSkillScalarFieldEnum[]
  }

  /**
   * LanguageSkill findMany
   */
  export type LanguageSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    /**
     * Filter, which LanguageSkills to fetch.
     */
    where?: LanguageSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageSkills to fetch.
     */
    orderBy?: LanguageSkillOrderByWithRelationInput | LanguageSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LanguageSkills.
     */
    cursor?: LanguageSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageSkills.
     */
    skip?: number
    distinct?: LanguageSkillScalarFieldEnum | LanguageSkillScalarFieldEnum[]
  }

  /**
   * LanguageSkill create
   */
  export type LanguageSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a LanguageSkill.
     */
    data: XOR<LanguageSkillCreateInput, LanguageSkillUncheckedCreateInput>
  }

  /**
   * LanguageSkill createMany
   */
  export type LanguageSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LanguageSkills.
     */
    data: LanguageSkillCreateManyInput | LanguageSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LanguageSkill createManyAndReturn
   */
  export type LanguageSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * The data used to create many LanguageSkills.
     */
    data: LanguageSkillCreateManyInput | LanguageSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LanguageSkill update
   */
  export type LanguageSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a LanguageSkill.
     */
    data: XOR<LanguageSkillUpdateInput, LanguageSkillUncheckedUpdateInput>
    /**
     * Choose, which LanguageSkill to update.
     */
    where: LanguageSkillWhereUniqueInput
  }

  /**
   * LanguageSkill updateMany
   */
  export type LanguageSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LanguageSkills.
     */
    data: XOR<LanguageSkillUpdateManyMutationInput, LanguageSkillUncheckedUpdateManyInput>
    /**
     * Filter which LanguageSkills to update
     */
    where?: LanguageSkillWhereInput
    /**
     * Limit how many LanguageSkills to update.
     */
    limit?: number
  }

  /**
   * LanguageSkill updateManyAndReturn
   */
  export type LanguageSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * The data used to update LanguageSkills.
     */
    data: XOR<LanguageSkillUpdateManyMutationInput, LanguageSkillUncheckedUpdateManyInput>
    /**
     * Filter which LanguageSkills to update
     */
    where?: LanguageSkillWhereInput
    /**
     * Limit how many LanguageSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LanguageSkill upsert
   */
  export type LanguageSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the LanguageSkill to update in case it exists.
     */
    where: LanguageSkillWhereUniqueInput
    /**
     * In case the LanguageSkill found by the `where` argument doesn't exist, create a new LanguageSkill with this data.
     */
    create: XOR<LanguageSkillCreateInput, LanguageSkillUncheckedCreateInput>
    /**
     * In case the LanguageSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageSkillUpdateInput, LanguageSkillUncheckedUpdateInput>
  }

  /**
   * LanguageSkill delete
   */
  export type LanguageSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
    /**
     * Filter which LanguageSkill to delete.
     */
    where: LanguageSkillWhereUniqueInput
  }

  /**
   * LanguageSkill deleteMany
   */
  export type LanguageSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LanguageSkills to delete
     */
    where?: LanguageSkillWhereInput
    /**
     * Limit how many LanguageSkills to delete.
     */
    limit?: number
  }

  /**
   * LanguageSkill.documents
   */
  export type LanguageSkill$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * LanguageSkill without action
   */
  export type LanguageSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSkill
     */
    select?: LanguageSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSkill
     */
    omit?: LanguageSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageSkillInclude<ExtArgs> | null
  }


  /**
   * Model Request
   */

  export type AggregateRequest = {
    _count: RequestCountAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  export type RequestMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.RequestStatus | null
    requesterId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.RequestStatus | null
    requesterId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    requesterId: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequestMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    requesterId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    requesterId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    requesterId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Request to aggregate.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requests
    **/
    _count?: true | RequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestMaxAggregateInputType
  }

  export type GetRequestAggregateType<T extends RequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequest[P]>
      : GetScalarType<T[P], AggregateRequest[P]>
  }




  export type RequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithAggregationInput | RequestOrderByWithAggregationInput[]
    by: RequestScalarFieldEnum[] | RequestScalarFieldEnum
    having?: RequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCountAggregateInputType | true
    _min?: RequestMinAggregateInputType
    _max?: RequestMaxAggregateInputType
  }

  export type RequestGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.RequestStatus
    requesterId: string
    managerId: string
    createdAt: Date
    updatedAt: Date
    _count: RequestCountAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  type GetRequestGroupByPayload<T extends RequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestGroupByOutputType[P]>
            : GetScalarType<T[P], RequestGroupByOutputType[P]>
        }
      >
    >


  export type RequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    requesterId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Request$attachmentsArgs<ExtArgs>
    RequestStatusHistory?: boolean | Request$RequestStatusHistoryArgs<ExtArgs>
    _count?: boolean | RequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    requesterId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    requesterId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    requesterId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "requesterId" | "managerId" | "createdAt" | "updatedAt", ExtArgs["result"]["request"]>
  export type RequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Request$attachmentsArgs<ExtArgs>
    RequestStatusHistory?: boolean | Request$RequestStatusHistoryArgs<ExtArgs>
    _count?: boolean | RequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Request"
    objects: {
      requester: Prisma.$UserPayload<ExtArgs>
      manager: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$RequestAttachmentPayload<ExtArgs>[]
      RequestStatusHistory: Prisma.$RequestStatusHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.RequestStatus
      requesterId: string
      managerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["request"]>
    composites: {}
  }

  type RequestGetPayload<S extends boolean | null | undefined | RequestDefaultArgs> = $Result.GetResult<Prisma.$RequestPayload, S>

  type RequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestCountAggregateInputType | true
    }

  export interface RequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Request'], meta: { name: 'Request' } }
    /**
     * Find zero or one Request that matches the filter.
     * @param {RequestFindUniqueArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestFindUniqueArgs>(args: SelectSubset<T, RequestFindUniqueArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Request that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestFindUniqueOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestFindFirstArgs>(args?: SelectSubset<T, RequestFindFirstArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.request.findMany()
     * 
     * // Get first 10 Requests
     * const requests = await prisma.request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestWithIdOnly = await prisma.request.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestFindManyArgs>(args?: SelectSubset<T, RequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Request.
     * @param {RequestCreateArgs} args - Arguments to create a Request.
     * @example
     * // Create one Request
     * const Request = await prisma.request.create({
     *   data: {
     *     // ... data to create a Request
     *   }
     * })
     * 
     */
    create<T extends RequestCreateArgs>(args: SelectSubset<T, RequestCreateArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requests.
     * @param {RequestCreateManyArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const request = await prisma.request.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestCreateManyArgs>(args?: SelectSubset<T, RequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requests and returns the data saved in the database.
     * @param {RequestCreateManyAndReturnArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const request = await prisma.request.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requests and only return the `id`
     * const requestWithIdOnly = await prisma.request.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Request.
     * @param {RequestDeleteArgs} args - Arguments to delete one Request.
     * @example
     * // Delete one Request
     * const Request = await prisma.request.delete({
     *   where: {
     *     // ... filter to delete one Request
     *   }
     * })
     * 
     */
    delete<T extends RequestDeleteArgs>(args: SelectSubset<T, RequestDeleteArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Request.
     * @param {RequestUpdateArgs} args - Arguments to update one Request.
     * @example
     * // Update one Request
     * const request = await prisma.request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestUpdateArgs>(args: SelectSubset<T, RequestUpdateArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requests.
     * @param {RequestDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestDeleteManyArgs>(args?: SelectSubset<T, RequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestUpdateManyArgs>(args: SelectSubset<T, RequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests and returns the data updated in the database.
     * @param {RequestUpdateManyAndReturnArgs} args - Arguments to update many Requests.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Requests and only return the `id`
     * const requestWithIdOnly = await prisma.request.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Request.
     * @param {RequestUpsertArgs} args - Arguments to update or create a Request.
     * @example
     * // Update or create a Request
     * const request = await prisma.request.upsert({
     *   create: {
     *     // ... data to create a Request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Request we want to update
     *   }
     * })
     */
    upsert<T extends RequestUpsertArgs>(args: SelectSubset<T, RequestUpsertArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.request.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
    **/
    count<T extends RequestCountArgs>(
      args?: Subset<T, RequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestAggregateArgs>(args: Subset<T, RequestAggregateArgs>): Prisma.PrismaPromise<GetRequestAggregateType<T>>

    /**
     * Group by Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestGroupByArgs['orderBy'] }
        : { orderBy?: RequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Request model
   */
  readonly fields: RequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Request$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Request$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RequestStatusHistory<T extends Request$RequestStatusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Request$RequestStatusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Request model
   */ 
  interface RequestFieldRefs {
    readonly id: FieldRef<"Request", 'String'>
    readonly title: FieldRef<"Request", 'String'>
    readonly description: FieldRef<"Request", 'String'>
    readonly status: FieldRef<"Request", 'RequestStatus'>
    readonly requesterId: FieldRef<"Request", 'String'>
    readonly managerId: FieldRef<"Request", 'String'>
    readonly createdAt: FieldRef<"Request", 'DateTime'>
    readonly updatedAt: FieldRef<"Request", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Request findUnique
   */
  export type RequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request findUniqueOrThrow
   */
  export type RequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request findFirst
   */
  export type RequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request findFirstOrThrow
   */
  export type RequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request findMany
   */
  export type RequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request create
   */
  export type RequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The data needed to create a Request.
     */
    data: XOR<RequestCreateInput, RequestUncheckedCreateInput>
  }

  /**
   * Request createMany
   */
  export type RequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requests.
     */
    data: RequestCreateManyInput | RequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Request createManyAndReturn
   */
  export type RequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * The data used to create many Requests.
     */
    data: RequestCreateManyInput | RequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Request update
   */
  export type RequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The data needed to update a Request.
     */
    data: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
    /**
     * Choose, which Request to update.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request updateMany
   */
  export type RequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to update.
     */
    limit?: number
  }

  /**
   * Request updateManyAndReturn
   */
  export type RequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Request upsert
   */
  export type RequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The filter to search for the Request to update in case it exists.
     */
    where: RequestWhereUniqueInput
    /**
     * In case the Request found by the `where` argument doesn't exist, create a new Request with this data.
     */
    create: XOR<RequestCreateInput, RequestUncheckedCreateInput>
    /**
     * In case the Request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
  }

  /**
   * Request delete
   */
  export type RequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter which Request to delete.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request deleteMany
   */
  export type RequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requests to delete
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to delete.
     */
    limit?: number
  }

  /**
   * Request.attachments
   */
  export type Request$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
    where?: RequestAttachmentWhereInput
    orderBy?: RequestAttachmentOrderByWithRelationInput | RequestAttachmentOrderByWithRelationInput[]
    cursor?: RequestAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestAttachmentScalarFieldEnum | RequestAttachmentScalarFieldEnum[]
  }

  /**
   * Request.RequestStatusHistory
   */
  export type Request$RequestStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    where?: RequestStatusHistoryWhereInput
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    cursor?: RequestStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestStatusHistoryScalarFieldEnum | RequestStatusHistoryScalarFieldEnum[]
  }

  /**
   * Request without action
   */
  export type RequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
  }


  /**
   * Model RequestStatusHistory
   */

  export type AggregateRequestStatusHistory = {
    _count: RequestStatusHistoryCountAggregateOutputType | null
    _avg: RequestStatusHistoryAvgAggregateOutputType | null
    _sum: RequestStatusHistorySumAggregateOutputType | null
    _min: RequestStatusHistoryMinAggregateOutputType | null
    _max: RequestStatusHistoryMaxAggregateOutputType | null
  }

  export type RequestStatusHistoryAvgAggregateOutputType = {
    id: number | null
  }

  export type RequestStatusHistorySumAggregateOutputType = {
    id: number | null
  }

  export type RequestStatusHistoryMinAggregateOutputType = {
    id: number | null
    requestId: string | null
    status: $Enums.RequestStatus | null
    comment: string | null
    changedBy: string | null
    createdAt: Date | null
  }

  export type RequestStatusHistoryMaxAggregateOutputType = {
    id: number | null
    requestId: string | null
    status: $Enums.RequestStatus | null
    comment: string | null
    changedBy: string | null
    createdAt: Date | null
  }

  export type RequestStatusHistoryCountAggregateOutputType = {
    id: number
    requestId: number
    status: number
    comment: number
    changedBy: number
    createdAt: number
    _all: number
  }


  export type RequestStatusHistoryAvgAggregateInputType = {
    id?: true
  }

  export type RequestStatusHistorySumAggregateInputType = {
    id?: true
  }

  export type RequestStatusHistoryMinAggregateInputType = {
    id?: true
    requestId?: true
    status?: true
    comment?: true
    changedBy?: true
    createdAt?: true
  }

  export type RequestStatusHistoryMaxAggregateInputType = {
    id?: true
    requestId?: true
    status?: true
    comment?: true
    changedBy?: true
    createdAt?: true
  }

  export type RequestStatusHistoryCountAggregateInputType = {
    id?: true
    requestId?: true
    status?: true
    comment?: true
    changedBy?: true
    createdAt?: true
    _all?: true
  }

  export type RequestStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestStatusHistory to aggregate.
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatusHistories to fetch.
     */
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestStatusHistories
    **/
    _count?: true | RequestStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestStatusHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestStatusHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestStatusHistoryMaxAggregateInputType
  }

  export type GetRequestStatusHistoryAggregateType<T extends RequestStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestStatusHistory[P]>
      : GetScalarType<T[P], AggregateRequestStatusHistory[P]>
  }




  export type RequestStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestStatusHistoryWhereInput
    orderBy?: RequestStatusHistoryOrderByWithAggregationInput | RequestStatusHistoryOrderByWithAggregationInput[]
    by: RequestStatusHistoryScalarFieldEnum[] | RequestStatusHistoryScalarFieldEnum
    having?: RequestStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestStatusHistoryCountAggregateInputType | true
    _avg?: RequestStatusHistoryAvgAggregateInputType
    _sum?: RequestStatusHistorySumAggregateInputType
    _min?: RequestStatusHistoryMinAggregateInputType
    _max?: RequestStatusHistoryMaxAggregateInputType
  }

  export type RequestStatusHistoryGroupByOutputType = {
    id: number
    requestId: string
    status: $Enums.RequestStatus
    comment: string | null
    changedBy: string
    createdAt: Date
    _count: RequestStatusHistoryCountAggregateOutputType | null
    _avg: RequestStatusHistoryAvgAggregateOutputType | null
    _sum: RequestStatusHistorySumAggregateOutputType | null
    _min: RequestStatusHistoryMinAggregateOutputType | null
    _max: RequestStatusHistoryMaxAggregateOutputType | null
  }

  type GetRequestStatusHistoryGroupByPayload<T extends RequestStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], RequestStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type RequestStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    status?: boolean
    comment?: boolean
    changedBy?: boolean
    createdAt?: boolean
    request?: boolean | RequestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | RequestStatusHistory$attachmentsArgs<ExtArgs>
    _count?: boolean | RequestStatusHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestStatusHistory"]>

  export type RequestStatusHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    status?: boolean
    comment?: boolean
    changedBy?: boolean
    createdAt?: boolean
    request?: boolean | RequestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestStatusHistory"]>

  export type RequestStatusHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    status?: boolean
    comment?: boolean
    changedBy?: boolean
    createdAt?: boolean
    request?: boolean | RequestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestStatusHistory"]>

  export type RequestStatusHistorySelectScalar = {
    id?: boolean
    requestId?: boolean
    status?: boolean
    comment?: boolean
    changedBy?: boolean
    createdAt?: boolean
  }

  export type RequestStatusHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "status" | "comment" | "changedBy" | "createdAt", ExtArgs["result"]["requestStatusHistory"]>
  export type RequestStatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | RequestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | RequestStatusHistory$attachmentsArgs<ExtArgs>
    _count?: boolean | RequestStatusHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestStatusHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | RequestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RequestStatusHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | RequestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RequestStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestStatusHistory"
    objects: {
      request: Prisma.$RequestPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$StatusAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      requestId: string
      status: $Enums.RequestStatus
      comment: string | null
      changedBy: string
      createdAt: Date
    }, ExtArgs["result"]["requestStatusHistory"]>
    composites: {}
  }

  type RequestStatusHistoryGetPayload<S extends boolean | null | undefined | RequestStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$RequestStatusHistoryPayload, S>

  type RequestStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestStatusHistoryCountAggregateInputType | true
    }

  export interface RequestStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestStatusHistory'], meta: { name: 'RequestStatusHistory' } }
    /**
     * Find zero or one RequestStatusHistory that matches the filter.
     * @param {RequestStatusHistoryFindUniqueArgs} args - Arguments to find a RequestStatusHistory
     * @example
     * // Get one RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestStatusHistoryFindUniqueArgs>(args: SelectSubset<T, RequestStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestStatusHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a RequestStatusHistory
     * @example
     * // Get one RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryFindFirstArgs} args - Arguments to find a RequestStatusHistory
     * @example
     * // Get one RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestStatusHistoryFindFirstArgs>(args?: SelectSubset<T, RequestStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a RequestStatusHistory
     * @example
     * // Get one RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestStatusHistories
     * const requestStatusHistories = await prisma.requestStatusHistory.findMany()
     * 
     * // Get first 10 RequestStatusHistories
     * const requestStatusHistories = await prisma.requestStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestStatusHistoryWithIdOnly = await prisma.requestStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestStatusHistoryFindManyArgs>(args?: SelectSubset<T, RequestStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestStatusHistory.
     * @param {RequestStatusHistoryCreateArgs} args - Arguments to create a RequestStatusHistory.
     * @example
     * // Create one RequestStatusHistory
     * const RequestStatusHistory = await prisma.requestStatusHistory.create({
     *   data: {
     *     // ... data to create a RequestStatusHistory
     *   }
     * })
     * 
     */
    create<T extends RequestStatusHistoryCreateArgs>(args: SelectSubset<T, RequestStatusHistoryCreateArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestStatusHistories.
     * @param {RequestStatusHistoryCreateManyArgs} args - Arguments to create many RequestStatusHistories.
     * @example
     * // Create many RequestStatusHistories
     * const requestStatusHistory = await prisma.requestStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestStatusHistoryCreateManyArgs>(args?: SelectSubset<T, RequestStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestStatusHistories and returns the data saved in the database.
     * @param {RequestStatusHistoryCreateManyAndReturnArgs} args - Arguments to create many RequestStatusHistories.
     * @example
     * // Create many RequestStatusHistories
     * const requestStatusHistory = await prisma.requestStatusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestStatusHistories and only return the `id`
     * const requestStatusHistoryWithIdOnly = await prisma.requestStatusHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestStatusHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestStatusHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestStatusHistory.
     * @param {RequestStatusHistoryDeleteArgs} args - Arguments to delete one RequestStatusHistory.
     * @example
     * // Delete one RequestStatusHistory
     * const RequestStatusHistory = await prisma.requestStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one RequestStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends RequestStatusHistoryDeleteArgs>(args: SelectSubset<T, RequestStatusHistoryDeleteArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestStatusHistory.
     * @param {RequestStatusHistoryUpdateArgs} args - Arguments to update one RequestStatusHistory.
     * @example
     * // Update one RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestStatusHistoryUpdateArgs>(args: SelectSubset<T, RequestStatusHistoryUpdateArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestStatusHistories.
     * @param {RequestStatusHistoryDeleteManyArgs} args - Arguments to filter RequestStatusHistories to delete.
     * @example
     * // Delete a few RequestStatusHistories
     * const { count } = await prisma.requestStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, RequestStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestStatusHistories
     * const requestStatusHistory = await prisma.requestStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestStatusHistoryUpdateManyArgs>(args: SelectSubset<T, RequestStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestStatusHistories and returns the data updated in the database.
     * @param {RequestStatusHistoryUpdateManyAndReturnArgs} args - Arguments to update many RequestStatusHistories.
     * @example
     * // Update many RequestStatusHistories
     * const requestStatusHistory = await prisma.requestStatusHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestStatusHistories and only return the `id`
     * const requestStatusHistoryWithIdOnly = await prisma.requestStatusHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestStatusHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestStatusHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestStatusHistory.
     * @param {RequestStatusHistoryUpsertArgs} args - Arguments to update or create a RequestStatusHistory.
     * @example
     * // Update or create a RequestStatusHistory
     * const requestStatusHistory = await prisma.requestStatusHistory.upsert({
     *   create: {
     *     // ... data to create a RequestStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends RequestStatusHistoryUpsertArgs>(args: SelectSubset<T, RequestStatusHistoryUpsertArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryCountArgs} args - Arguments to filter RequestStatusHistories to count.
     * @example
     * // Count the number of RequestStatusHistories
     * const count = await prisma.requestStatusHistory.count({
     *   where: {
     *     // ... the filter for the RequestStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends RequestStatusHistoryCountArgs>(
      args?: Subset<T, RequestStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestStatusHistoryAggregateArgs>(args: Subset<T, RequestStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetRequestStatusHistoryAggregateType<T>>

    /**
     * Group by RequestStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: RequestStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestStatusHistory model
   */
  readonly fields: RequestStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends RequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestDefaultArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends RequestStatusHistory$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, RequestStatusHistory$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestStatusHistory model
   */ 
  interface RequestStatusHistoryFieldRefs {
    readonly id: FieldRef<"RequestStatusHistory", 'Int'>
    readonly requestId: FieldRef<"RequestStatusHistory", 'String'>
    readonly status: FieldRef<"RequestStatusHistory", 'RequestStatus'>
    readonly comment: FieldRef<"RequestStatusHistory", 'String'>
    readonly changedBy: FieldRef<"RequestStatusHistory", 'String'>
    readonly createdAt: FieldRef<"RequestStatusHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestStatusHistory findUnique
   */
  export type RequestStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatusHistory to fetch.
     */
    where: RequestStatusHistoryWhereUniqueInput
  }

  /**
   * RequestStatusHistory findUniqueOrThrow
   */
  export type RequestStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatusHistory to fetch.
     */
    where: RequestStatusHistoryWhereUniqueInput
  }

  /**
   * RequestStatusHistory findFirst
   */
  export type RequestStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatusHistory to fetch.
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatusHistories to fetch.
     */
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestStatusHistories.
     */
    cursor?: RequestStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestStatusHistories.
     */
    distinct?: RequestStatusHistoryScalarFieldEnum | RequestStatusHistoryScalarFieldEnum[]
  }

  /**
   * RequestStatusHistory findFirstOrThrow
   */
  export type RequestStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatusHistory to fetch.
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatusHistories to fetch.
     */
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestStatusHistories.
     */
    cursor?: RequestStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestStatusHistories.
     */
    distinct?: RequestStatusHistoryScalarFieldEnum | RequestStatusHistoryScalarFieldEnum[]
  }

  /**
   * RequestStatusHistory findMany
   */
  export type RequestStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RequestStatusHistories to fetch.
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestStatusHistories to fetch.
     */
    orderBy?: RequestStatusHistoryOrderByWithRelationInput | RequestStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestStatusHistories.
     */
    cursor?: RequestStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestStatusHistories.
     */
    skip?: number
    distinct?: RequestStatusHistoryScalarFieldEnum | RequestStatusHistoryScalarFieldEnum[]
  }

  /**
   * RequestStatusHistory create
   */
  export type RequestStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestStatusHistory.
     */
    data: XOR<RequestStatusHistoryCreateInput, RequestStatusHistoryUncheckedCreateInput>
  }

  /**
   * RequestStatusHistory createMany
   */
  export type RequestStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestStatusHistories.
     */
    data: RequestStatusHistoryCreateManyInput | RequestStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestStatusHistory createManyAndReturn
   */
  export type RequestStatusHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many RequestStatusHistories.
     */
    data: RequestStatusHistoryCreateManyInput | RequestStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestStatusHistory update
   */
  export type RequestStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestStatusHistory.
     */
    data: XOR<RequestStatusHistoryUpdateInput, RequestStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which RequestStatusHistory to update.
     */
    where: RequestStatusHistoryWhereUniqueInput
  }

  /**
   * RequestStatusHistory updateMany
   */
  export type RequestStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestStatusHistories.
     */
    data: XOR<RequestStatusHistoryUpdateManyMutationInput, RequestStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RequestStatusHistories to update
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * Limit how many RequestStatusHistories to update.
     */
    limit?: number
  }

  /**
   * RequestStatusHistory updateManyAndReturn
   */
  export type RequestStatusHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to update RequestStatusHistories.
     */
    data: XOR<RequestStatusHistoryUpdateManyMutationInput, RequestStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RequestStatusHistories to update
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * Limit how many RequestStatusHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestStatusHistory upsert
   */
  export type RequestStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestStatusHistory to update in case it exists.
     */
    where: RequestStatusHistoryWhereUniqueInput
    /**
     * In case the RequestStatusHistory found by the `where` argument doesn't exist, create a new RequestStatusHistory with this data.
     */
    create: XOR<RequestStatusHistoryCreateInput, RequestStatusHistoryUncheckedCreateInput>
    /**
     * In case the RequestStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestStatusHistoryUpdateInput, RequestStatusHistoryUncheckedUpdateInput>
  }

  /**
   * RequestStatusHistory delete
   */
  export type RequestStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which RequestStatusHistory to delete.
     */
    where: RequestStatusHistoryWhereUniqueInput
  }

  /**
   * RequestStatusHistory deleteMany
   */
  export type RequestStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestStatusHistories to delete
     */
    where?: RequestStatusHistoryWhereInput
    /**
     * Limit how many RequestStatusHistories to delete.
     */
    limit?: number
  }

  /**
   * RequestStatusHistory.attachments
   */
  export type RequestStatusHistory$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
    where?: StatusAttachmentWhereInput
    orderBy?: StatusAttachmentOrderByWithRelationInput | StatusAttachmentOrderByWithRelationInput[]
    cursor?: StatusAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatusAttachmentScalarFieldEnum | StatusAttachmentScalarFieldEnum[]
  }

  /**
   * RequestStatusHistory without action
   */
  export type RequestStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestStatusHistory
     */
    select?: RequestStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestStatusHistory
     */
    omit?: RequestStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestStatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model StatusAttachment
   */

  export type AggregateStatusAttachment = {
    _count: StatusAttachmentCountAggregateOutputType | null
    _avg: StatusAttachmentAvgAggregateOutputType | null
    _sum: StatusAttachmentSumAggregateOutputType | null
    _min: StatusAttachmentMinAggregateOutputType | null
    _max: StatusAttachmentMaxAggregateOutputType | null
  }

  export type StatusAttachmentAvgAggregateOutputType = {
    id: number | null
    historyId: number | null
  }

  export type StatusAttachmentSumAggregateOutputType = {
    id: number | null
    historyId: number | null
  }

  export type StatusAttachmentMinAggregateOutputType = {
    id: number | null
    historyId: number | null
    fileName: string | null
    fileKey: string | null
    fileType: string | null
    uploadedAt: Date | null
  }

  export type StatusAttachmentMaxAggregateOutputType = {
    id: number | null
    historyId: number | null
    fileName: string | null
    fileKey: string | null
    fileType: string | null
    uploadedAt: Date | null
  }

  export type StatusAttachmentCountAggregateOutputType = {
    id: number
    historyId: number
    fileName: number
    fileKey: number
    fileType: number
    uploadedAt: number
    _all: number
  }


  export type StatusAttachmentAvgAggregateInputType = {
    id?: true
    historyId?: true
  }

  export type StatusAttachmentSumAggregateInputType = {
    id?: true
    historyId?: true
  }

  export type StatusAttachmentMinAggregateInputType = {
    id?: true
    historyId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
  }

  export type StatusAttachmentMaxAggregateInputType = {
    id?: true
    historyId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
  }

  export type StatusAttachmentCountAggregateInputType = {
    id?: true
    historyId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
    _all?: true
  }

  export type StatusAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusAttachment to aggregate.
     */
    where?: StatusAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusAttachments to fetch.
     */
    orderBy?: StatusAttachmentOrderByWithRelationInput | StatusAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusAttachments
    **/
    _count?: true | StatusAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusAttachmentMaxAggregateInputType
  }

  export type GetStatusAttachmentAggregateType<T extends StatusAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusAttachment[P]>
      : GetScalarType<T[P], AggregateStatusAttachment[P]>
  }




  export type StatusAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusAttachmentWhereInput
    orderBy?: StatusAttachmentOrderByWithAggregationInput | StatusAttachmentOrderByWithAggregationInput[]
    by: StatusAttachmentScalarFieldEnum[] | StatusAttachmentScalarFieldEnum
    having?: StatusAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusAttachmentCountAggregateInputType | true
    _avg?: StatusAttachmentAvgAggregateInputType
    _sum?: StatusAttachmentSumAggregateInputType
    _min?: StatusAttachmentMinAggregateInputType
    _max?: StatusAttachmentMaxAggregateInputType
  }

  export type StatusAttachmentGroupByOutputType = {
    id: number
    historyId: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt: Date
    _count: StatusAttachmentCountAggregateOutputType | null
    _avg: StatusAttachmentAvgAggregateOutputType | null
    _sum: StatusAttachmentSumAggregateOutputType | null
    _min: StatusAttachmentMinAggregateOutputType | null
    _max: StatusAttachmentMaxAggregateOutputType | null
  }

  type GetStatusAttachmentGroupByPayload<T extends StatusAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], StatusAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type StatusAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    historyId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    history?: boolean | RequestStatusHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusAttachment"]>

  export type StatusAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    historyId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    history?: boolean | RequestStatusHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusAttachment"]>

  export type StatusAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    historyId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    history?: boolean | RequestStatusHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusAttachment"]>

  export type StatusAttachmentSelectScalar = {
    id?: boolean
    historyId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
  }

  export type StatusAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "historyId" | "fileName" | "fileKey" | "fileType" | "uploadedAt", ExtArgs["result"]["statusAttachment"]>
  export type StatusAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | RequestStatusHistoryDefaultArgs<ExtArgs>
  }
  export type StatusAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | RequestStatusHistoryDefaultArgs<ExtArgs>
  }
  export type StatusAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | RequestStatusHistoryDefaultArgs<ExtArgs>
  }

  export type $StatusAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatusAttachment"
    objects: {
      history: Prisma.$RequestStatusHistoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      historyId: number
      fileName: string
      fileKey: string
      fileType: string
      uploadedAt: Date
    }, ExtArgs["result"]["statusAttachment"]>
    composites: {}
  }

  type StatusAttachmentGetPayload<S extends boolean | null | undefined | StatusAttachmentDefaultArgs> = $Result.GetResult<Prisma.$StatusAttachmentPayload, S>

  type StatusAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatusAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatusAttachmentCountAggregateInputType | true
    }

  export interface StatusAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatusAttachment'], meta: { name: 'StatusAttachment' } }
    /**
     * Find zero or one StatusAttachment that matches the filter.
     * @param {StatusAttachmentFindUniqueArgs} args - Arguments to find a StatusAttachment
     * @example
     * // Get one StatusAttachment
     * const statusAttachment = await prisma.statusAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatusAttachmentFindUniqueArgs>(args: SelectSubset<T, StatusAttachmentFindUniqueArgs<ExtArgs>>): Prisma__StatusAttachmentClient<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StatusAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatusAttachmentFindUniqueOrThrowArgs} args - Arguments to find a StatusAttachment
     * @example
     * // Get one StatusAttachment
     * const statusAttachment = await prisma.statusAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatusAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, StatusAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatusAttachmentClient<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatusAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAttachmentFindFirstArgs} args - Arguments to find a StatusAttachment
     * @example
     * // Get one StatusAttachment
     * const statusAttachment = await prisma.statusAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatusAttachmentFindFirstArgs>(args?: SelectSubset<T, StatusAttachmentFindFirstArgs<ExtArgs>>): Prisma__StatusAttachmentClient<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatusAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAttachmentFindFirstOrThrowArgs} args - Arguments to find a StatusAttachment
     * @example
     * // Get one StatusAttachment
     * const statusAttachment = await prisma.statusAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatusAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, StatusAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatusAttachmentClient<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StatusAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusAttachments
     * const statusAttachments = await prisma.statusAttachment.findMany()
     * 
     * // Get first 10 StatusAttachments
     * const statusAttachments = await prisma.statusAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusAttachmentWithIdOnly = await prisma.statusAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatusAttachmentFindManyArgs>(args?: SelectSubset<T, StatusAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StatusAttachment.
     * @param {StatusAttachmentCreateArgs} args - Arguments to create a StatusAttachment.
     * @example
     * // Create one StatusAttachment
     * const StatusAttachment = await prisma.statusAttachment.create({
     *   data: {
     *     // ... data to create a StatusAttachment
     *   }
     * })
     * 
     */
    create<T extends StatusAttachmentCreateArgs>(args: SelectSubset<T, StatusAttachmentCreateArgs<ExtArgs>>): Prisma__StatusAttachmentClient<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StatusAttachments.
     * @param {StatusAttachmentCreateManyArgs} args - Arguments to create many StatusAttachments.
     * @example
     * // Create many StatusAttachments
     * const statusAttachment = await prisma.statusAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatusAttachmentCreateManyArgs>(args?: SelectSubset<T, StatusAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatusAttachments and returns the data saved in the database.
     * @param {StatusAttachmentCreateManyAndReturnArgs} args - Arguments to create many StatusAttachments.
     * @example
     * // Create many StatusAttachments
     * const statusAttachment = await prisma.statusAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatusAttachments and only return the `id`
     * const statusAttachmentWithIdOnly = await prisma.statusAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatusAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, StatusAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StatusAttachment.
     * @param {StatusAttachmentDeleteArgs} args - Arguments to delete one StatusAttachment.
     * @example
     * // Delete one StatusAttachment
     * const StatusAttachment = await prisma.statusAttachment.delete({
     *   where: {
     *     // ... filter to delete one StatusAttachment
     *   }
     * })
     * 
     */
    delete<T extends StatusAttachmentDeleteArgs>(args: SelectSubset<T, StatusAttachmentDeleteArgs<ExtArgs>>): Prisma__StatusAttachmentClient<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StatusAttachment.
     * @param {StatusAttachmentUpdateArgs} args - Arguments to update one StatusAttachment.
     * @example
     * // Update one StatusAttachment
     * const statusAttachment = await prisma.statusAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatusAttachmentUpdateArgs>(args: SelectSubset<T, StatusAttachmentUpdateArgs<ExtArgs>>): Prisma__StatusAttachmentClient<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StatusAttachments.
     * @param {StatusAttachmentDeleteManyArgs} args - Arguments to filter StatusAttachments to delete.
     * @example
     * // Delete a few StatusAttachments
     * const { count } = await prisma.statusAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatusAttachmentDeleteManyArgs>(args?: SelectSubset<T, StatusAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusAttachments
     * const statusAttachment = await prisma.statusAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatusAttachmentUpdateManyArgs>(args: SelectSubset<T, StatusAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusAttachments and returns the data updated in the database.
     * @param {StatusAttachmentUpdateManyAndReturnArgs} args - Arguments to update many StatusAttachments.
     * @example
     * // Update many StatusAttachments
     * const statusAttachment = await prisma.statusAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StatusAttachments and only return the `id`
     * const statusAttachmentWithIdOnly = await prisma.statusAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StatusAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, StatusAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StatusAttachment.
     * @param {StatusAttachmentUpsertArgs} args - Arguments to update or create a StatusAttachment.
     * @example
     * // Update or create a StatusAttachment
     * const statusAttachment = await prisma.statusAttachment.upsert({
     *   create: {
     *     // ... data to create a StatusAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusAttachment we want to update
     *   }
     * })
     */
    upsert<T extends StatusAttachmentUpsertArgs>(args: SelectSubset<T, StatusAttachmentUpsertArgs<ExtArgs>>): Prisma__StatusAttachmentClient<$Result.GetResult<Prisma.$StatusAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StatusAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAttachmentCountArgs} args - Arguments to filter StatusAttachments to count.
     * @example
     * // Count the number of StatusAttachments
     * const count = await prisma.statusAttachment.count({
     *   where: {
     *     // ... the filter for the StatusAttachments we want to count
     *   }
     * })
    **/
    count<T extends StatusAttachmentCountArgs>(
      args?: Subset<T, StatusAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusAttachmentAggregateArgs>(args: Subset<T, StatusAttachmentAggregateArgs>): Prisma.PrismaPromise<GetStatusAttachmentAggregateType<T>>

    /**
     * Group by StatusAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: StatusAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatusAttachment model
   */
  readonly fields: StatusAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    history<T extends RequestStatusHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestStatusHistoryDefaultArgs<ExtArgs>>): Prisma__RequestStatusHistoryClient<$Result.GetResult<Prisma.$RequestStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatusAttachment model
   */ 
  interface StatusAttachmentFieldRefs {
    readonly id: FieldRef<"StatusAttachment", 'Int'>
    readonly historyId: FieldRef<"StatusAttachment", 'Int'>
    readonly fileName: FieldRef<"StatusAttachment", 'String'>
    readonly fileKey: FieldRef<"StatusAttachment", 'String'>
    readonly fileType: FieldRef<"StatusAttachment", 'String'>
    readonly uploadedAt: FieldRef<"StatusAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatusAttachment findUnique
   */
  export type StatusAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which StatusAttachment to fetch.
     */
    where: StatusAttachmentWhereUniqueInput
  }

  /**
   * StatusAttachment findUniqueOrThrow
   */
  export type StatusAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which StatusAttachment to fetch.
     */
    where: StatusAttachmentWhereUniqueInput
  }

  /**
   * StatusAttachment findFirst
   */
  export type StatusAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which StatusAttachment to fetch.
     */
    where?: StatusAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusAttachments to fetch.
     */
    orderBy?: StatusAttachmentOrderByWithRelationInput | StatusAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusAttachments.
     */
    cursor?: StatusAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusAttachments.
     */
    distinct?: StatusAttachmentScalarFieldEnum | StatusAttachmentScalarFieldEnum[]
  }

  /**
   * StatusAttachment findFirstOrThrow
   */
  export type StatusAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which StatusAttachment to fetch.
     */
    where?: StatusAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusAttachments to fetch.
     */
    orderBy?: StatusAttachmentOrderByWithRelationInput | StatusAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusAttachments.
     */
    cursor?: StatusAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusAttachments.
     */
    distinct?: StatusAttachmentScalarFieldEnum | StatusAttachmentScalarFieldEnum[]
  }

  /**
   * StatusAttachment findMany
   */
  export type StatusAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which StatusAttachments to fetch.
     */
    where?: StatusAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusAttachments to fetch.
     */
    orderBy?: StatusAttachmentOrderByWithRelationInput | StatusAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusAttachments.
     */
    cursor?: StatusAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusAttachments.
     */
    skip?: number
    distinct?: StatusAttachmentScalarFieldEnum | StatusAttachmentScalarFieldEnum[]
  }

  /**
   * StatusAttachment create
   */
  export type StatusAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a StatusAttachment.
     */
    data: XOR<StatusAttachmentCreateInput, StatusAttachmentUncheckedCreateInput>
  }

  /**
   * StatusAttachment createMany
   */
  export type StatusAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatusAttachments.
     */
    data: StatusAttachmentCreateManyInput | StatusAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatusAttachment createManyAndReturn
   */
  export type StatusAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many StatusAttachments.
     */
    data: StatusAttachmentCreateManyInput | StatusAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatusAttachment update
   */
  export type StatusAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a StatusAttachment.
     */
    data: XOR<StatusAttachmentUpdateInput, StatusAttachmentUncheckedUpdateInput>
    /**
     * Choose, which StatusAttachment to update.
     */
    where: StatusAttachmentWhereUniqueInput
  }

  /**
   * StatusAttachment updateMany
   */
  export type StatusAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatusAttachments.
     */
    data: XOR<StatusAttachmentUpdateManyMutationInput, StatusAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which StatusAttachments to update
     */
    where?: StatusAttachmentWhereInput
    /**
     * Limit how many StatusAttachments to update.
     */
    limit?: number
  }

  /**
   * StatusAttachment updateManyAndReturn
   */
  export type StatusAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update StatusAttachments.
     */
    data: XOR<StatusAttachmentUpdateManyMutationInput, StatusAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which StatusAttachments to update
     */
    where?: StatusAttachmentWhereInput
    /**
     * Limit how many StatusAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatusAttachment upsert
   */
  export type StatusAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the StatusAttachment to update in case it exists.
     */
    where: StatusAttachmentWhereUniqueInput
    /**
     * In case the StatusAttachment found by the `where` argument doesn't exist, create a new StatusAttachment with this data.
     */
    create: XOR<StatusAttachmentCreateInput, StatusAttachmentUncheckedCreateInput>
    /**
     * In case the StatusAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusAttachmentUpdateInput, StatusAttachmentUncheckedUpdateInput>
  }

  /**
   * StatusAttachment delete
   */
  export type StatusAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter which StatusAttachment to delete.
     */
    where: StatusAttachmentWhereUniqueInput
  }

  /**
   * StatusAttachment deleteMany
   */
  export type StatusAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusAttachments to delete
     */
    where?: StatusAttachmentWhereInput
    /**
     * Limit how many StatusAttachments to delete.
     */
    limit?: number
  }

  /**
   * StatusAttachment without action
   */
  export type StatusAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAttachment
     */
    select?: StatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAttachment
     */
    omit?: StatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model RequestAttachment
   */

  export type AggregateRequestAttachment = {
    _count: RequestAttachmentCountAggregateOutputType | null
    _avg: RequestAttachmentAvgAggregateOutputType | null
    _sum: RequestAttachmentSumAggregateOutputType | null
    _min: RequestAttachmentMinAggregateOutputType | null
    _max: RequestAttachmentMaxAggregateOutputType | null
  }

  export type RequestAttachmentAvgAggregateOutputType = {
    id: number | null
  }

  export type RequestAttachmentSumAggregateOutputType = {
    id: number | null
  }

  export type RequestAttachmentMinAggregateOutputType = {
    id: number | null
    requestId: string | null
    fileName: string | null
    fileKey: string | null
    fileType: string | null
    uploadedAt: Date | null
  }

  export type RequestAttachmentMaxAggregateOutputType = {
    id: number | null
    requestId: string | null
    fileName: string | null
    fileKey: string | null
    fileType: string | null
    uploadedAt: Date | null
  }

  export type RequestAttachmentCountAggregateOutputType = {
    id: number
    requestId: number
    fileName: number
    fileKey: number
    fileType: number
    uploadedAt: number
    _all: number
  }


  export type RequestAttachmentAvgAggregateInputType = {
    id?: true
  }

  export type RequestAttachmentSumAggregateInputType = {
    id?: true
  }

  export type RequestAttachmentMinAggregateInputType = {
    id?: true
    requestId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
  }

  export type RequestAttachmentMaxAggregateInputType = {
    id?: true
    requestId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
  }

  export type RequestAttachmentCountAggregateInputType = {
    id?: true
    requestId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
    _all?: true
  }

  export type RequestAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestAttachment to aggregate.
     */
    where?: RequestAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestAttachments to fetch.
     */
    orderBy?: RequestAttachmentOrderByWithRelationInput | RequestAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestAttachments
    **/
    _count?: true | RequestAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestAttachmentMaxAggregateInputType
  }

  export type GetRequestAttachmentAggregateType<T extends RequestAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestAttachment[P]>
      : GetScalarType<T[P], AggregateRequestAttachment[P]>
  }




  export type RequestAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestAttachmentWhereInput
    orderBy?: RequestAttachmentOrderByWithAggregationInput | RequestAttachmentOrderByWithAggregationInput[]
    by: RequestAttachmentScalarFieldEnum[] | RequestAttachmentScalarFieldEnum
    having?: RequestAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestAttachmentCountAggregateInputType | true
    _avg?: RequestAttachmentAvgAggregateInputType
    _sum?: RequestAttachmentSumAggregateInputType
    _min?: RequestAttachmentMinAggregateInputType
    _max?: RequestAttachmentMaxAggregateInputType
  }

  export type RequestAttachmentGroupByOutputType = {
    id: number
    requestId: string
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt: Date
    _count: RequestAttachmentCountAggregateOutputType | null
    _avg: RequestAttachmentAvgAggregateOutputType | null
    _sum: RequestAttachmentSumAggregateOutputType | null
    _min: RequestAttachmentMinAggregateOutputType | null
    _max: RequestAttachmentMaxAggregateOutputType | null
  }

  type GetRequestAttachmentGroupByPayload<T extends RequestAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], RequestAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type RequestAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    request?: boolean | RequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestAttachment"]>

  export type RequestAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    request?: boolean | RequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestAttachment"]>

  export type RequestAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    request?: boolean | RequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestAttachment"]>

  export type RequestAttachmentSelectScalar = {
    id?: boolean
    requestId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
  }

  export type RequestAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "fileName" | "fileKey" | "fileType" | "uploadedAt", ExtArgs["result"]["requestAttachment"]>
  export type RequestAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | RequestDefaultArgs<ExtArgs>
  }
  export type RequestAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | RequestDefaultArgs<ExtArgs>
  }
  export type RequestAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | RequestDefaultArgs<ExtArgs>
  }

  export type $RequestAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestAttachment"
    objects: {
      request: Prisma.$RequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      requestId: string
      fileName: string
      fileKey: string
      fileType: string
      uploadedAt: Date
    }, ExtArgs["result"]["requestAttachment"]>
    composites: {}
  }

  type RequestAttachmentGetPayload<S extends boolean | null | undefined | RequestAttachmentDefaultArgs> = $Result.GetResult<Prisma.$RequestAttachmentPayload, S>

  type RequestAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestAttachmentCountAggregateInputType | true
    }

  export interface RequestAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestAttachment'], meta: { name: 'RequestAttachment' } }
    /**
     * Find zero or one RequestAttachment that matches the filter.
     * @param {RequestAttachmentFindUniqueArgs} args - Arguments to find a RequestAttachment
     * @example
     * // Get one RequestAttachment
     * const requestAttachment = await prisma.requestAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestAttachmentFindUniqueArgs>(args: SelectSubset<T, RequestAttachmentFindUniqueArgs<ExtArgs>>): Prisma__RequestAttachmentClient<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestAttachmentFindUniqueOrThrowArgs} args - Arguments to find a RequestAttachment
     * @example
     * // Get one RequestAttachment
     * const requestAttachment = await prisma.requestAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestAttachmentClient<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAttachmentFindFirstArgs} args - Arguments to find a RequestAttachment
     * @example
     * // Get one RequestAttachment
     * const requestAttachment = await prisma.requestAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestAttachmentFindFirstArgs>(args?: SelectSubset<T, RequestAttachmentFindFirstArgs<ExtArgs>>): Prisma__RequestAttachmentClient<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAttachmentFindFirstOrThrowArgs} args - Arguments to find a RequestAttachment
     * @example
     * // Get one RequestAttachment
     * const requestAttachment = await prisma.requestAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestAttachmentClient<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestAttachments
     * const requestAttachments = await prisma.requestAttachment.findMany()
     * 
     * // Get first 10 RequestAttachments
     * const requestAttachments = await prisma.requestAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestAttachmentWithIdOnly = await prisma.requestAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestAttachmentFindManyArgs>(args?: SelectSubset<T, RequestAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestAttachment.
     * @param {RequestAttachmentCreateArgs} args - Arguments to create a RequestAttachment.
     * @example
     * // Create one RequestAttachment
     * const RequestAttachment = await prisma.requestAttachment.create({
     *   data: {
     *     // ... data to create a RequestAttachment
     *   }
     * })
     * 
     */
    create<T extends RequestAttachmentCreateArgs>(args: SelectSubset<T, RequestAttachmentCreateArgs<ExtArgs>>): Prisma__RequestAttachmentClient<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestAttachments.
     * @param {RequestAttachmentCreateManyArgs} args - Arguments to create many RequestAttachments.
     * @example
     * // Create many RequestAttachments
     * const requestAttachment = await prisma.requestAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestAttachmentCreateManyArgs>(args?: SelectSubset<T, RequestAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestAttachments and returns the data saved in the database.
     * @param {RequestAttachmentCreateManyAndReturnArgs} args - Arguments to create many RequestAttachments.
     * @example
     * // Create many RequestAttachments
     * const requestAttachment = await prisma.requestAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestAttachments and only return the `id`
     * const requestAttachmentWithIdOnly = await prisma.requestAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestAttachment.
     * @param {RequestAttachmentDeleteArgs} args - Arguments to delete one RequestAttachment.
     * @example
     * // Delete one RequestAttachment
     * const RequestAttachment = await prisma.requestAttachment.delete({
     *   where: {
     *     // ... filter to delete one RequestAttachment
     *   }
     * })
     * 
     */
    delete<T extends RequestAttachmentDeleteArgs>(args: SelectSubset<T, RequestAttachmentDeleteArgs<ExtArgs>>): Prisma__RequestAttachmentClient<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestAttachment.
     * @param {RequestAttachmentUpdateArgs} args - Arguments to update one RequestAttachment.
     * @example
     * // Update one RequestAttachment
     * const requestAttachment = await prisma.requestAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestAttachmentUpdateArgs>(args: SelectSubset<T, RequestAttachmentUpdateArgs<ExtArgs>>): Prisma__RequestAttachmentClient<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestAttachments.
     * @param {RequestAttachmentDeleteManyArgs} args - Arguments to filter RequestAttachments to delete.
     * @example
     * // Delete a few RequestAttachments
     * const { count } = await prisma.requestAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestAttachmentDeleteManyArgs>(args?: SelectSubset<T, RequestAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestAttachments
     * const requestAttachment = await prisma.requestAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestAttachmentUpdateManyArgs>(args: SelectSubset<T, RequestAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestAttachments and returns the data updated in the database.
     * @param {RequestAttachmentUpdateManyAndReturnArgs} args - Arguments to update many RequestAttachments.
     * @example
     * // Update many RequestAttachments
     * const requestAttachment = await prisma.requestAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestAttachments and only return the `id`
     * const requestAttachmentWithIdOnly = await prisma.requestAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestAttachment.
     * @param {RequestAttachmentUpsertArgs} args - Arguments to update or create a RequestAttachment.
     * @example
     * // Update or create a RequestAttachment
     * const requestAttachment = await prisma.requestAttachment.upsert({
     *   create: {
     *     // ... data to create a RequestAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestAttachment we want to update
     *   }
     * })
     */
    upsert<T extends RequestAttachmentUpsertArgs>(args: SelectSubset<T, RequestAttachmentUpsertArgs<ExtArgs>>): Prisma__RequestAttachmentClient<$Result.GetResult<Prisma.$RequestAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAttachmentCountArgs} args - Arguments to filter RequestAttachments to count.
     * @example
     * // Count the number of RequestAttachments
     * const count = await prisma.requestAttachment.count({
     *   where: {
     *     // ... the filter for the RequestAttachments we want to count
     *   }
     * })
    **/
    count<T extends RequestAttachmentCountArgs>(
      args?: Subset<T, RequestAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestAttachmentAggregateArgs>(args: Subset<T, RequestAttachmentAggregateArgs>): Prisma.PrismaPromise<GetRequestAttachmentAggregateType<T>>

    /**
     * Group by RequestAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: RequestAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestAttachment model
   */
  readonly fields: RequestAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends RequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequestDefaultArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestAttachment model
   */ 
  interface RequestAttachmentFieldRefs {
    readonly id: FieldRef<"RequestAttachment", 'Int'>
    readonly requestId: FieldRef<"RequestAttachment", 'String'>
    readonly fileName: FieldRef<"RequestAttachment", 'String'>
    readonly fileKey: FieldRef<"RequestAttachment", 'String'>
    readonly fileType: FieldRef<"RequestAttachment", 'String'>
    readonly uploadedAt: FieldRef<"RequestAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestAttachment findUnique
   */
  export type RequestAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which RequestAttachment to fetch.
     */
    where: RequestAttachmentWhereUniqueInput
  }

  /**
   * RequestAttachment findUniqueOrThrow
   */
  export type RequestAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which RequestAttachment to fetch.
     */
    where: RequestAttachmentWhereUniqueInput
  }

  /**
   * RequestAttachment findFirst
   */
  export type RequestAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which RequestAttachment to fetch.
     */
    where?: RequestAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestAttachments to fetch.
     */
    orderBy?: RequestAttachmentOrderByWithRelationInput | RequestAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestAttachments.
     */
    cursor?: RequestAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestAttachments.
     */
    distinct?: RequestAttachmentScalarFieldEnum | RequestAttachmentScalarFieldEnum[]
  }

  /**
   * RequestAttachment findFirstOrThrow
   */
  export type RequestAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which RequestAttachment to fetch.
     */
    where?: RequestAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestAttachments to fetch.
     */
    orderBy?: RequestAttachmentOrderByWithRelationInput | RequestAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestAttachments.
     */
    cursor?: RequestAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestAttachments.
     */
    distinct?: RequestAttachmentScalarFieldEnum | RequestAttachmentScalarFieldEnum[]
  }

  /**
   * RequestAttachment findMany
   */
  export type RequestAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which RequestAttachments to fetch.
     */
    where?: RequestAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestAttachments to fetch.
     */
    orderBy?: RequestAttachmentOrderByWithRelationInput | RequestAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestAttachments.
     */
    cursor?: RequestAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestAttachments.
     */
    skip?: number
    distinct?: RequestAttachmentScalarFieldEnum | RequestAttachmentScalarFieldEnum[]
  }

  /**
   * RequestAttachment create
   */
  export type RequestAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestAttachment.
     */
    data: XOR<RequestAttachmentCreateInput, RequestAttachmentUncheckedCreateInput>
  }

  /**
   * RequestAttachment createMany
   */
  export type RequestAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestAttachments.
     */
    data: RequestAttachmentCreateManyInput | RequestAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestAttachment createManyAndReturn
   */
  export type RequestAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many RequestAttachments.
     */
    data: RequestAttachmentCreateManyInput | RequestAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestAttachment update
   */
  export type RequestAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestAttachment.
     */
    data: XOR<RequestAttachmentUpdateInput, RequestAttachmentUncheckedUpdateInput>
    /**
     * Choose, which RequestAttachment to update.
     */
    where: RequestAttachmentWhereUniqueInput
  }

  /**
   * RequestAttachment updateMany
   */
  export type RequestAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestAttachments.
     */
    data: XOR<RequestAttachmentUpdateManyMutationInput, RequestAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which RequestAttachments to update
     */
    where?: RequestAttachmentWhereInput
    /**
     * Limit how many RequestAttachments to update.
     */
    limit?: number
  }

  /**
   * RequestAttachment updateManyAndReturn
   */
  export type RequestAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update RequestAttachments.
     */
    data: XOR<RequestAttachmentUpdateManyMutationInput, RequestAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which RequestAttachments to update
     */
    where?: RequestAttachmentWhereInput
    /**
     * Limit how many RequestAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestAttachment upsert
   */
  export type RequestAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestAttachment to update in case it exists.
     */
    where: RequestAttachmentWhereUniqueInput
    /**
     * In case the RequestAttachment found by the `where` argument doesn't exist, create a new RequestAttachment with this data.
     */
    create: XOR<RequestAttachmentCreateInput, RequestAttachmentUncheckedCreateInput>
    /**
     * In case the RequestAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestAttachmentUpdateInput, RequestAttachmentUncheckedUpdateInput>
  }

  /**
   * RequestAttachment delete
   */
  export type RequestAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
    /**
     * Filter which RequestAttachment to delete.
     */
    where: RequestAttachmentWhereUniqueInput
  }

  /**
   * RequestAttachment deleteMany
   */
  export type RequestAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestAttachments to delete
     */
    where?: RequestAttachmentWhereInput
    /**
     * Limit how many RequestAttachments to delete.
     */
    limit?: number
  }

  /**
   * RequestAttachment without action
   */
  export type RequestAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestAttachment
     */
    select?: RequestAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestAttachment
     */
    omit?: RequestAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model LeaveRequest
   */

  export type AggregateLeaveRequest = {
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  export type LeaveRequestAvgAggregateOutputType = {
    duration: number | null
  }

  export type LeaveRequestSumAggregateOutputType = {
    duration: number | null
  }

  export type LeaveRequestMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    managerId: string | null
    type: $Enums.LeaveType | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    reason: string | null
    status: $Enums.LeaveStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    managerId: string | null
    type: $Enums.LeaveType | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    reason: string | null
    status: $Enums.LeaveStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestCountAggregateOutputType = {
    id: number
    employeeId: number
    managerId: number
    type: number
    startDate: number
    endDate: number
    duration: number
    reason: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveRequestAvgAggregateInputType = {
    duration?: true
  }

  export type LeaveRequestSumAggregateInputType = {
    duration?: true
  }

  export type LeaveRequestMinAggregateInputType = {
    id?: true
    employeeId?: true
    managerId?: true
    type?: true
    startDate?: true
    endDate?: true
    duration?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestMaxAggregateInputType = {
    id?: true
    employeeId?: true
    managerId?: true
    type?: true
    startDate?: true
    endDate?: true
    duration?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestCountAggregateInputType = {
    id?: true
    employeeId?: true
    managerId?: true
    type?: true
    startDate?: true
    endDate?: true
    duration?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequest to aggregate.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveRequests
    **/
    _count?: true | LeaveRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type GetLeaveRequestAggregateType<T extends LeaveRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveRequest[P]>
      : GetScalarType<T[P], AggregateLeaveRequest[P]>
  }




  export type LeaveRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithAggregationInput | LeaveRequestOrderByWithAggregationInput[]
    by: LeaveRequestScalarFieldEnum[] | LeaveRequestScalarFieldEnum
    having?: LeaveRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveRequestCountAggregateInputType | true
    _avg?: LeaveRequestAvgAggregateInputType
    _sum?: LeaveRequestSumAggregateInputType
    _min?: LeaveRequestMinAggregateInputType
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type LeaveRequestGroupByOutputType = {
    id: string
    employeeId: string
    managerId: string
    type: $Enums.LeaveType
    startDate: Date
    endDate: Date
    duration: number
    reason: string | null
    status: $Enums.LeaveStatus
    createdAt: Date
    updatedAt: Date
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  type GetLeaveRequestGroupByPayload<T extends LeaveRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
        }
      >
    >


  export type LeaveRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    managerId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | LeaveRequest$attachmentsArgs<ExtArgs>
    statusHistory?: boolean | LeaveRequest$statusHistoryArgs<ExtArgs>
    _count?: boolean | LeaveRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    managerId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    managerId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectScalar = {
    id?: boolean
    employeeId?: boolean
    managerId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "managerId" | "type" | "startDate" | "endDate" | "duration" | "reason" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["leaveRequest"]>
  export type LeaveRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | LeaveRequest$attachmentsArgs<ExtArgs>
    statusHistory?: boolean | LeaveRequest$statusHistoryArgs<ExtArgs>
    _count?: boolean | LeaveRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeaveRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaveRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeaveRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveRequest"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
      manager: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$LeaveAttachmentPayload<ExtArgs>[]
      statusHistory: Prisma.$LeaveStatusHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      managerId: string
      type: $Enums.LeaveType
      startDate: Date
      endDate: Date
      duration: number
      reason: string | null
      status: $Enums.LeaveStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveRequest"]>
    composites: {}
  }

  type LeaveRequestGetPayload<S extends boolean | null | undefined | LeaveRequestDefaultArgs> = $Result.GetResult<Prisma.$LeaveRequestPayload, S>

  type LeaveRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveRequestCountAggregateInputType | true
    }

  export interface LeaveRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveRequest'], meta: { name: 'LeaveRequest' } }
    /**
     * Find zero or one LeaveRequest that matches the filter.
     * @param {LeaveRequestFindUniqueArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveRequestFindUniqueArgs>(args: SelectSubset<T, LeaveRequestFindUniqueArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveRequestFindUniqueOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveRequestFindFirstArgs>(args?: SelectSubset<T, LeaveRequestFindFirstArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany()
     * 
     * // Get first 10 LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveRequestFindManyArgs>(args?: SelectSubset<T, LeaveRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveRequest.
     * @param {LeaveRequestCreateArgs} args - Arguments to create a LeaveRequest.
     * @example
     * // Create one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.create({
     *   data: {
     *     // ... data to create a LeaveRequest
     *   }
     * })
     * 
     */
    create<T extends LeaveRequestCreateArgs>(args: SelectSubset<T, LeaveRequestCreateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveRequests.
     * @param {LeaveRequestCreateManyArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveRequestCreateManyArgs>(args?: SelectSubset<T, LeaveRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveRequests and returns the data saved in the database.
     * @param {LeaveRequestCreateManyAndReturnArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveRequest.
     * @param {LeaveRequestDeleteArgs} args - Arguments to delete one LeaveRequest.
     * @example
     * // Delete one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.delete({
     *   where: {
     *     // ... filter to delete one LeaveRequest
     *   }
     * })
     * 
     */
    delete<T extends LeaveRequestDeleteArgs>(args: SelectSubset<T, LeaveRequestDeleteArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveRequest.
     * @param {LeaveRequestUpdateArgs} args - Arguments to update one LeaveRequest.
     * @example
     * // Update one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveRequestUpdateArgs>(args: SelectSubset<T, LeaveRequestUpdateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveRequests.
     * @param {LeaveRequestDeleteManyArgs} args - Arguments to filter LeaveRequests to delete.
     * @example
     * // Delete a few LeaveRequests
     * const { count } = await prisma.leaveRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveRequestDeleteManyArgs>(args?: SelectSubset<T, LeaveRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveRequestUpdateManyArgs>(args: SelectSubset<T, LeaveRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests and returns the data updated in the database.
     * @param {LeaveRequestUpdateManyAndReturnArgs} args - Arguments to update many LeaveRequests.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveRequest.
     * @param {LeaveRequestUpsertArgs} args - Arguments to update or create a LeaveRequest.
     * @example
     * // Update or create a LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.upsert({
     *   create: {
     *     // ... data to create a LeaveRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveRequest we want to update
     *   }
     * })
     */
    upsert<T extends LeaveRequestUpsertArgs>(args: SelectSubset<T, LeaveRequestUpsertArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestCountArgs} args - Arguments to filter LeaveRequests to count.
     * @example
     * // Count the number of LeaveRequests
     * const count = await prisma.leaveRequest.count({
     *   where: {
     *     // ... the filter for the LeaveRequests we want to count
     *   }
     * })
    **/
    count<T extends LeaveRequestCountArgs>(
      args?: Subset<T, LeaveRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveRequestAggregateArgs>(args: Subset<T, LeaveRequestAggregateArgs>): Prisma.PrismaPromise<GetLeaveRequestAggregateType<T>>

    /**
     * Group by LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveRequestGroupByArgs['orderBy'] }
        : { orderBy?: LeaveRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveRequest model
   */
  readonly fields: LeaveRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends LeaveRequest$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequest$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusHistory<T extends LeaveRequest$statusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequest$statusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveRequest model
   */ 
  interface LeaveRequestFieldRefs {
    readonly id: FieldRef<"LeaveRequest", 'String'>
    readonly employeeId: FieldRef<"LeaveRequest", 'String'>
    readonly managerId: FieldRef<"LeaveRequest", 'String'>
    readonly type: FieldRef<"LeaveRequest", 'LeaveType'>
    readonly startDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly endDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly duration: FieldRef<"LeaveRequest", 'Float'>
    readonly reason: FieldRef<"LeaveRequest", 'String'>
    readonly status: FieldRef<"LeaveRequest", 'LeaveStatus'>
    readonly createdAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveRequest findUnique
   */
  export type LeaveRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findUniqueOrThrow
   */
  export type LeaveRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findFirst
   */
  export type LeaveRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findFirstOrThrow
   */
  export type LeaveRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findMany
   */
  export type LeaveRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequests to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest create
   */
  export type LeaveRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveRequest.
     */
    data: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
  }

  /**
   * LeaveRequest createMany
   */
  export type LeaveRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveRequest createManyAndReturn
   */
  export type LeaveRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveRequest update
   */
  export type LeaveRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveRequest.
     */
    data: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
    /**
     * Choose, which LeaveRequest to update.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest updateMany
   */
  export type LeaveRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to update.
     */
    limit?: number
  }

  /**
   * LeaveRequest updateManyAndReturn
   */
  export type LeaveRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveRequest upsert
   */
  export type LeaveRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveRequest to update in case it exists.
     */
    where: LeaveRequestWhereUniqueInput
    /**
     * In case the LeaveRequest found by the `where` argument doesn't exist, create a new LeaveRequest with this data.
     */
    create: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
    /**
     * In case the LeaveRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
  }

  /**
   * LeaveRequest delete
   */
  export type LeaveRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter which LeaveRequest to delete.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest deleteMany
   */
  export type LeaveRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequests to delete
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to delete.
     */
    limit?: number
  }

  /**
   * LeaveRequest.attachments
   */
  export type LeaveRequest$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
    where?: LeaveAttachmentWhereInput
    orderBy?: LeaveAttachmentOrderByWithRelationInput | LeaveAttachmentOrderByWithRelationInput[]
    cursor?: LeaveAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveAttachmentScalarFieldEnum | LeaveAttachmentScalarFieldEnum[]
  }

  /**
   * LeaveRequest.statusHistory
   */
  export type LeaveRequest$statusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    where?: LeaveStatusHistoryWhereInput
    orderBy?: LeaveStatusHistoryOrderByWithRelationInput | LeaveStatusHistoryOrderByWithRelationInput[]
    cursor?: LeaveStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveStatusHistoryScalarFieldEnum | LeaveStatusHistoryScalarFieldEnum[]
  }

  /**
   * LeaveRequest without action
   */
  export type LeaveRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
  }


  /**
   * Model LeaveAttachment
   */

  export type AggregateLeaveAttachment = {
    _count: LeaveAttachmentCountAggregateOutputType | null
    _avg: LeaveAttachmentAvgAggregateOutputType | null
    _sum: LeaveAttachmentSumAggregateOutputType | null
    _min: LeaveAttachmentMinAggregateOutputType | null
    _max: LeaveAttachmentMaxAggregateOutputType | null
  }

  export type LeaveAttachmentAvgAggregateOutputType = {
    id: number | null
  }

  export type LeaveAttachmentSumAggregateOutputType = {
    id: number | null
  }

  export type LeaveAttachmentMinAggregateOutputType = {
    id: number | null
    leaveId: string | null
    fileName: string | null
    fileKey: string | null
    fileType: string | null
    uploadedAt: Date | null
  }

  export type LeaveAttachmentMaxAggregateOutputType = {
    id: number | null
    leaveId: string | null
    fileName: string | null
    fileKey: string | null
    fileType: string | null
    uploadedAt: Date | null
  }

  export type LeaveAttachmentCountAggregateOutputType = {
    id: number
    leaveId: number
    fileName: number
    fileKey: number
    fileType: number
    uploadedAt: number
    _all: number
  }


  export type LeaveAttachmentAvgAggregateInputType = {
    id?: true
  }

  export type LeaveAttachmentSumAggregateInputType = {
    id?: true
  }

  export type LeaveAttachmentMinAggregateInputType = {
    id?: true
    leaveId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
  }

  export type LeaveAttachmentMaxAggregateInputType = {
    id?: true
    leaveId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
  }

  export type LeaveAttachmentCountAggregateInputType = {
    id?: true
    leaveId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
    _all?: true
  }

  export type LeaveAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveAttachment to aggregate.
     */
    where?: LeaveAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveAttachments to fetch.
     */
    orderBy?: LeaveAttachmentOrderByWithRelationInput | LeaveAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveAttachments
    **/
    _count?: true | LeaveAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveAttachmentMaxAggregateInputType
  }

  export type GetLeaveAttachmentAggregateType<T extends LeaveAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveAttachment[P]>
      : GetScalarType<T[P], AggregateLeaveAttachment[P]>
  }




  export type LeaveAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveAttachmentWhereInput
    orderBy?: LeaveAttachmentOrderByWithAggregationInput | LeaveAttachmentOrderByWithAggregationInput[]
    by: LeaveAttachmentScalarFieldEnum[] | LeaveAttachmentScalarFieldEnum
    having?: LeaveAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveAttachmentCountAggregateInputType | true
    _avg?: LeaveAttachmentAvgAggregateInputType
    _sum?: LeaveAttachmentSumAggregateInputType
    _min?: LeaveAttachmentMinAggregateInputType
    _max?: LeaveAttachmentMaxAggregateInputType
  }

  export type LeaveAttachmentGroupByOutputType = {
    id: number
    leaveId: string
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt: Date
    _count: LeaveAttachmentCountAggregateOutputType | null
    _avg: LeaveAttachmentAvgAggregateOutputType | null
    _sum: LeaveAttachmentSumAggregateOutputType | null
    _min: LeaveAttachmentMinAggregateOutputType | null
    _max: LeaveAttachmentMaxAggregateOutputType | null
  }

  type GetLeaveAttachmentGroupByPayload<T extends LeaveAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type LeaveAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveAttachment"]>

  export type LeaveAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveAttachment"]>

  export type LeaveAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveAttachment"]>

  export type LeaveAttachmentSelectScalar = {
    id?: boolean
    leaveId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
  }

  export type LeaveAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaveId" | "fileName" | "fileKey" | "fileType" | "uploadedAt", ExtArgs["result"]["leaveAttachment"]>
  export type LeaveAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
  }
  export type LeaveAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
  }
  export type LeaveAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
  }

  export type $LeaveAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveAttachment"
    objects: {
      leave: Prisma.$LeaveRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      leaveId: string
      fileName: string
      fileKey: string
      fileType: string
      uploadedAt: Date
    }, ExtArgs["result"]["leaveAttachment"]>
    composites: {}
  }

  type LeaveAttachmentGetPayload<S extends boolean | null | undefined | LeaveAttachmentDefaultArgs> = $Result.GetResult<Prisma.$LeaveAttachmentPayload, S>

  type LeaveAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveAttachmentCountAggregateInputType | true
    }

  export interface LeaveAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveAttachment'], meta: { name: 'LeaveAttachment' } }
    /**
     * Find zero or one LeaveAttachment that matches the filter.
     * @param {LeaveAttachmentFindUniqueArgs} args - Arguments to find a LeaveAttachment
     * @example
     * // Get one LeaveAttachment
     * const leaveAttachment = await prisma.leaveAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveAttachmentFindUniqueArgs>(args: SelectSubset<T, LeaveAttachmentFindUniqueArgs<ExtArgs>>): Prisma__LeaveAttachmentClient<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveAttachmentFindUniqueOrThrowArgs} args - Arguments to find a LeaveAttachment
     * @example
     * // Get one LeaveAttachment
     * const leaveAttachment = await prisma.leaveAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveAttachmentClient<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAttachmentFindFirstArgs} args - Arguments to find a LeaveAttachment
     * @example
     * // Get one LeaveAttachment
     * const leaveAttachment = await prisma.leaveAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveAttachmentFindFirstArgs>(args?: SelectSubset<T, LeaveAttachmentFindFirstArgs<ExtArgs>>): Prisma__LeaveAttachmentClient<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAttachmentFindFirstOrThrowArgs} args - Arguments to find a LeaveAttachment
     * @example
     * // Get one LeaveAttachment
     * const leaveAttachment = await prisma.leaveAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveAttachmentClient<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveAttachments
     * const leaveAttachments = await prisma.leaveAttachment.findMany()
     * 
     * // Get first 10 LeaveAttachments
     * const leaveAttachments = await prisma.leaveAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveAttachmentWithIdOnly = await prisma.leaveAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveAttachmentFindManyArgs>(args?: SelectSubset<T, LeaveAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveAttachment.
     * @param {LeaveAttachmentCreateArgs} args - Arguments to create a LeaveAttachment.
     * @example
     * // Create one LeaveAttachment
     * const LeaveAttachment = await prisma.leaveAttachment.create({
     *   data: {
     *     // ... data to create a LeaveAttachment
     *   }
     * })
     * 
     */
    create<T extends LeaveAttachmentCreateArgs>(args: SelectSubset<T, LeaveAttachmentCreateArgs<ExtArgs>>): Prisma__LeaveAttachmentClient<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveAttachments.
     * @param {LeaveAttachmentCreateManyArgs} args - Arguments to create many LeaveAttachments.
     * @example
     * // Create many LeaveAttachments
     * const leaveAttachment = await prisma.leaveAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveAttachmentCreateManyArgs>(args?: SelectSubset<T, LeaveAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveAttachments and returns the data saved in the database.
     * @param {LeaveAttachmentCreateManyAndReturnArgs} args - Arguments to create many LeaveAttachments.
     * @example
     * // Create many LeaveAttachments
     * const leaveAttachment = await prisma.leaveAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveAttachments and only return the `id`
     * const leaveAttachmentWithIdOnly = await prisma.leaveAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveAttachment.
     * @param {LeaveAttachmentDeleteArgs} args - Arguments to delete one LeaveAttachment.
     * @example
     * // Delete one LeaveAttachment
     * const LeaveAttachment = await prisma.leaveAttachment.delete({
     *   where: {
     *     // ... filter to delete one LeaveAttachment
     *   }
     * })
     * 
     */
    delete<T extends LeaveAttachmentDeleteArgs>(args: SelectSubset<T, LeaveAttachmentDeleteArgs<ExtArgs>>): Prisma__LeaveAttachmentClient<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveAttachment.
     * @param {LeaveAttachmentUpdateArgs} args - Arguments to update one LeaveAttachment.
     * @example
     * // Update one LeaveAttachment
     * const leaveAttachment = await prisma.leaveAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveAttachmentUpdateArgs>(args: SelectSubset<T, LeaveAttachmentUpdateArgs<ExtArgs>>): Prisma__LeaveAttachmentClient<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveAttachments.
     * @param {LeaveAttachmentDeleteManyArgs} args - Arguments to filter LeaveAttachments to delete.
     * @example
     * // Delete a few LeaveAttachments
     * const { count } = await prisma.leaveAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveAttachmentDeleteManyArgs>(args?: SelectSubset<T, LeaveAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveAttachments
     * const leaveAttachment = await prisma.leaveAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveAttachmentUpdateManyArgs>(args: SelectSubset<T, LeaveAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveAttachments and returns the data updated in the database.
     * @param {LeaveAttachmentUpdateManyAndReturnArgs} args - Arguments to update many LeaveAttachments.
     * @example
     * // Update many LeaveAttachments
     * const leaveAttachment = await prisma.leaveAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveAttachments and only return the `id`
     * const leaveAttachmentWithIdOnly = await prisma.leaveAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveAttachment.
     * @param {LeaveAttachmentUpsertArgs} args - Arguments to update or create a LeaveAttachment.
     * @example
     * // Update or create a LeaveAttachment
     * const leaveAttachment = await prisma.leaveAttachment.upsert({
     *   create: {
     *     // ... data to create a LeaveAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveAttachment we want to update
     *   }
     * })
     */
    upsert<T extends LeaveAttachmentUpsertArgs>(args: SelectSubset<T, LeaveAttachmentUpsertArgs<ExtArgs>>): Prisma__LeaveAttachmentClient<$Result.GetResult<Prisma.$LeaveAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAttachmentCountArgs} args - Arguments to filter LeaveAttachments to count.
     * @example
     * // Count the number of LeaveAttachments
     * const count = await prisma.leaveAttachment.count({
     *   where: {
     *     // ... the filter for the LeaveAttachments we want to count
     *   }
     * })
    **/
    count<T extends LeaveAttachmentCountArgs>(
      args?: Subset<T, LeaveAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAttachmentAggregateArgs>(args: Subset<T, LeaveAttachmentAggregateArgs>): Prisma.PrismaPromise<GetLeaveAttachmentAggregateType<T>>

    /**
     * Group by LeaveAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: LeaveAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveAttachment model
   */
  readonly fields: LeaveAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leave<T extends LeaveRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequestDefaultArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveAttachment model
   */ 
  interface LeaveAttachmentFieldRefs {
    readonly id: FieldRef<"LeaveAttachment", 'Int'>
    readonly leaveId: FieldRef<"LeaveAttachment", 'String'>
    readonly fileName: FieldRef<"LeaveAttachment", 'String'>
    readonly fileKey: FieldRef<"LeaveAttachment", 'String'>
    readonly fileType: FieldRef<"LeaveAttachment", 'String'>
    readonly uploadedAt: FieldRef<"LeaveAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveAttachment findUnique
   */
  export type LeaveAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveAttachment to fetch.
     */
    where: LeaveAttachmentWhereUniqueInput
  }

  /**
   * LeaveAttachment findUniqueOrThrow
   */
  export type LeaveAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveAttachment to fetch.
     */
    where: LeaveAttachmentWhereUniqueInput
  }

  /**
   * LeaveAttachment findFirst
   */
  export type LeaveAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveAttachment to fetch.
     */
    where?: LeaveAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveAttachments to fetch.
     */
    orderBy?: LeaveAttachmentOrderByWithRelationInput | LeaveAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveAttachments.
     */
    cursor?: LeaveAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveAttachments.
     */
    distinct?: LeaveAttachmentScalarFieldEnum | LeaveAttachmentScalarFieldEnum[]
  }

  /**
   * LeaveAttachment findFirstOrThrow
   */
  export type LeaveAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveAttachment to fetch.
     */
    where?: LeaveAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveAttachments to fetch.
     */
    orderBy?: LeaveAttachmentOrderByWithRelationInput | LeaveAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveAttachments.
     */
    cursor?: LeaveAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveAttachments.
     */
    distinct?: LeaveAttachmentScalarFieldEnum | LeaveAttachmentScalarFieldEnum[]
  }

  /**
   * LeaveAttachment findMany
   */
  export type LeaveAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveAttachments to fetch.
     */
    where?: LeaveAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveAttachments to fetch.
     */
    orderBy?: LeaveAttachmentOrderByWithRelationInput | LeaveAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveAttachments.
     */
    cursor?: LeaveAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveAttachments.
     */
    skip?: number
    distinct?: LeaveAttachmentScalarFieldEnum | LeaveAttachmentScalarFieldEnum[]
  }

  /**
   * LeaveAttachment create
   */
  export type LeaveAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveAttachment.
     */
    data: XOR<LeaveAttachmentCreateInput, LeaveAttachmentUncheckedCreateInput>
  }

  /**
   * LeaveAttachment createMany
   */
  export type LeaveAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveAttachments.
     */
    data: LeaveAttachmentCreateManyInput | LeaveAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveAttachment createManyAndReturn
   */
  export type LeaveAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveAttachments.
     */
    data: LeaveAttachmentCreateManyInput | LeaveAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveAttachment update
   */
  export type LeaveAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveAttachment.
     */
    data: XOR<LeaveAttachmentUpdateInput, LeaveAttachmentUncheckedUpdateInput>
    /**
     * Choose, which LeaveAttachment to update.
     */
    where: LeaveAttachmentWhereUniqueInput
  }

  /**
   * LeaveAttachment updateMany
   */
  export type LeaveAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveAttachments.
     */
    data: XOR<LeaveAttachmentUpdateManyMutationInput, LeaveAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which LeaveAttachments to update
     */
    where?: LeaveAttachmentWhereInput
    /**
     * Limit how many LeaveAttachments to update.
     */
    limit?: number
  }

  /**
   * LeaveAttachment updateManyAndReturn
   */
  export type LeaveAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update LeaveAttachments.
     */
    data: XOR<LeaveAttachmentUpdateManyMutationInput, LeaveAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which LeaveAttachments to update
     */
    where?: LeaveAttachmentWhereInput
    /**
     * Limit how many LeaveAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveAttachment upsert
   */
  export type LeaveAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveAttachment to update in case it exists.
     */
    where: LeaveAttachmentWhereUniqueInput
    /**
     * In case the LeaveAttachment found by the `where` argument doesn't exist, create a new LeaveAttachment with this data.
     */
    create: XOR<LeaveAttachmentCreateInput, LeaveAttachmentUncheckedCreateInput>
    /**
     * In case the LeaveAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveAttachmentUpdateInput, LeaveAttachmentUncheckedUpdateInput>
  }

  /**
   * LeaveAttachment delete
   */
  export type LeaveAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
    /**
     * Filter which LeaveAttachment to delete.
     */
    where: LeaveAttachmentWhereUniqueInput
  }

  /**
   * LeaveAttachment deleteMany
   */
  export type LeaveAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveAttachments to delete
     */
    where?: LeaveAttachmentWhereInput
    /**
     * Limit how many LeaveAttachments to delete.
     */
    limit?: number
  }

  /**
   * LeaveAttachment without action
   */
  export type LeaveAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveAttachment
     */
    select?: LeaveAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveAttachment
     */
    omit?: LeaveAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model LeaveStatusHistory
   */

  export type AggregateLeaveStatusHistory = {
    _count: LeaveStatusHistoryCountAggregateOutputType | null
    _avg: LeaveStatusHistoryAvgAggregateOutputType | null
    _sum: LeaveStatusHistorySumAggregateOutputType | null
    _min: LeaveStatusHistoryMinAggregateOutputType | null
    _max: LeaveStatusHistoryMaxAggregateOutputType | null
  }

  export type LeaveStatusHistoryAvgAggregateOutputType = {
    id: number | null
  }

  export type LeaveStatusHistorySumAggregateOutputType = {
    id: number | null
  }

  export type LeaveStatusHistoryMinAggregateOutputType = {
    id: number | null
    leaveId: string | null
    status: $Enums.LeaveStatus | null
    comment: string | null
    changedById: string | null
    createdAt: Date | null
  }

  export type LeaveStatusHistoryMaxAggregateOutputType = {
    id: number | null
    leaveId: string | null
    status: $Enums.LeaveStatus | null
    comment: string | null
    changedById: string | null
    createdAt: Date | null
  }

  export type LeaveStatusHistoryCountAggregateOutputType = {
    id: number
    leaveId: number
    status: number
    comment: number
    changedById: number
    createdAt: number
    _all: number
  }


  export type LeaveStatusHistoryAvgAggregateInputType = {
    id?: true
  }

  export type LeaveStatusHistorySumAggregateInputType = {
    id?: true
  }

  export type LeaveStatusHistoryMinAggregateInputType = {
    id?: true
    leaveId?: true
    status?: true
    comment?: true
    changedById?: true
    createdAt?: true
  }

  export type LeaveStatusHistoryMaxAggregateInputType = {
    id?: true
    leaveId?: true
    status?: true
    comment?: true
    changedById?: true
    createdAt?: true
  }

  export type LeaveStatusHistoryCountAggregateInputType = {
    id?: true
    leaveId?: true
    status?: true
    comment?: true
    changedById?: true
    createdAt?: true
    _all?: true
  }

  export type LeaveStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveStatusHistory to aggregate.
     */
    where?: LeaveStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveStatusHistories to fetch.
     */
    orderBy?: LeaveStatusHistoryOrderByWithRelationInput | LeaveStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveStatusHistories
    **/
    _count?: true | LeaveStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveStatusHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveStatusHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveStatusHistoryMaxAggregateInputType
  }

  export type GetLeaveStatusHistoryAggregateType<T extends LeaveStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveStatusHistory[P]>
      : GetScalarType<T[P], AggregateLeaveStatusHistory[P]>
  }




  export type LeaveStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveStatusHistoryWhereInput
    orderBy?: LeaveStatusHistoryOrderByWithAggregationInput | LeaveStatusHistoryOrderByWithAggregationInput[]
    by: LeaveStatusHistoryScalarFieldEnum[] | LeaveStatusHistoryScalarFieldEnum
    having?: LeaveStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveStatusHistoryCountAggregateInputType | true
    _avg?: LeaveStatusHistoryAvgAggregateInputType
    _sum?: LeaveStatusHistorySumAggregateInputType
    _min?: LeaveStatusHistoryMinAggregateInputType
    _max?: LeaveStatusHistoryMaxAggregateInputType
  }

  export type LeaveStatusHistoryGroupByOutputType = {
    id: number
    leaveId: string
    status: $Enums.LeaveStatus
    comment: string | null
    changedById: string
    createdAt: Date
    _count: LeaveStatusHistoryCountAggregateOutputType | null
    _avg: LeaveStatusHistoryAvgAggregateOutputType | null
    _sum: LeaveStatusHistorySumAggregateOutputType | null
    _min: LeaveStatusHistoryMinAggregateOutputType | null
    _max: LeaveStatusHistoryMaxAggregateOutputType | null
  }

  type GetLeaveStatusHistoryGroupByPayload<T extends LeaveStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LeaveStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveId?: boolean
    status?: boolean
    comment?: boolean
    changedById?: boolean
    createdAt?: boolean
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | LeaveStatusHistory$attachmentsArgs<ExtArgs>
    _count?: boolean | LeaveStatusHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveStatusHistory"]>

  export type LeaveStatusHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveId?: boolean
    status?: boolean
    comment?: boolean
    changedById?: boolean
    createdAt?: boolean
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveStatusHistory"]>

  export type LeaveStatusHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaveId?: boolean
    status?: boolean
    comment?: boolean
    changedById?: boolean
    createdAt?: boolean
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveStatusHistory"]>

  export type LeaveStatusHistorySelectScalar = {
    id?: boolean
    leaveId?: boolean
    status?: boolean
    comment?: boolean
    changedById?: boolean
    createdAt?: boolean
  }

  export type LeaveStatusHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaveId" | "status" | "comment" | "changedById" | "createdAt", ExtArgs["result"]["leaveStatusHistory"]>
  export type LeaveStatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | LeaveStatusHistory$attachmentsArgs<ExtArgs>
    _count?: boolean | LeaveStatusHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeaveStatusHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeaveStatusHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leave?: boolean | LeaveRequestDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeaveStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveStatusHistory"
    objects: {
      leave: Prisma.$LeaveRequestPayload<ExtArgs>
      changedBy: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$LeaveStatusAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      leaveId: string
      status: $Enums.LeaveStatus
      comment: string | null
      changedById: string
      createdAt: Date
    }, ExtArgs["result"]["leaveStatusHistory"]>
    composites: {}
  }

  type LeaveStatusHistoryGetPayload<S extends boolean | null | undefined | LeaveStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$LeaveStatusHistoryPayload, S>

  type LeaveStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveStatusHistoryCountAggregateInputType | true
    }

  export interface LeaveStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveStatusHistory'], meta: { name: 'LeaveStatusHistory' } }
    /**
     * Find zero or one LeaveStatusHistory that matches the filter.
     * @param {LeaveStatusHistoryFindUniqueArgs} args - Arguments to find a LeaveStatusHistory
     * @example
     * // Get one LeaveStatusHistory
     * const leaveStatusHistory = await prisma.leaveStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveStatusHistoryFindUniqueArgs>(args: SelectSubset<T, LeaveStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__LeaveStatusHistoryClient<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveStatusHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a LeaveStatusHistory
     * @example
     * // Get one LeaveStatusHistory
     * const leaveStatusHistory = await prisma.leaveStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveStatusHistoryClient<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusHistoryFindFirstArgs} args - Arguments to find a LeaveStatusHistory
     * @example
     * // Get one LeaveStatusHistory
     * const leaveStatusHistory = await prisma.leaveStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveStatusHistoryFindFirstArgs>(args?: SelectSubset<T, LeaveStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__LeaveStatusHistoryClient<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a LeaveStatusHistory
     * @example
     * // Get one LeaveStatusHistory
     * const leaveStatusHistory = await prisma.leaveStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveStatusHistoryClient<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveStatusHistories
     * const leaveStatusHistories = await prisma.leaveStatusHistory.findMany()
     * 
     * // Get first 10 LeaveStatusHistories
     * const leaveStatusHistories = await prisma.leaveStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveStatusHistoryWithIdOnly = await prisma.leaveStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveStatusHistoryFindManyArgs>(args?: SelectSubset<T, LeaveStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveStatusHistory.
     * @param {LeaveStatusHistoryCreateArgs} args - Arguments to create a LeaveStatusHistory.
     * @example
     * // Create one LeaveStatusHistory
     * const LeaveStatusHistory = await prisma.leaveStatusHistory.create({
     *   data: {
     *     // ... data to create a LeaveStatusHistory
     *   }
     * })
     * 
     */
    create<T extends LeaveStatusHistoryCreateArgs>(args: SelectSubset<T, LeaveStatusHistoryCreateArgs<ExtArgs>>): Prisma__LeaveStatusHistoryClient<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveStatusHistories.
     * @param {LeaveStatusHistoryCreateManyArgs} args - Arguments to create many LeaveStatusHistories.
     * @example
     * // Create many LeaveStatusHistories
     * const leaveStatusHistory = await prisma.leaveStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveStatusHistoryCreateManyArgs>(args?: SelectSubset<T, LeaveStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveStatusHistories and returns the data saved in the database.
     * @param {LeaveStatusHistoryCreateManyAndReturnArgs} args - Arguments to create many LeaveStatusHistories.
     * @example
     * // Create many LeaveStatusHistories
     * const leaveStatusHistory = await prisma.leaveStatusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveStatusHistories and only return the `id`
     * const leaveStatusHistoryWithIdOnly = await prisma.leaveStatusHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveStatusHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveStatusHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveStatusHistory.
     * @param {LeaveStatusHistoryDeleteArgs} args - Arguments to delete one LeaveStatusHistory.
     * @example
     * // Delete one LeaveStatusHistory
     * const LeaveStatusHistory = await prisma.leaveStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one LeaveStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends LeaveStatusHistoryDeleteArgs>(args: SelectSubset<T, LeaveStatusHistoryDeleteArgs<ExtArgs>>): Prisma__LeaveStatusHistoryClient<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveStatusHistory.
     * @param {LeaveStatusHistoryUpdateArgs} args - Arguments to update one LeaveStatusHistory.
     * @example
     * // Update one LeaveStatusHistory
     * const leaveStatusHistory = await prisma.leaveStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveStatusHistoryUpdateArgs>(args: SelectSubset<T, LeaveStatusHistoryUpdateArgs<ExtArgs>>): Prisma__LeaveStatusHistoryClient<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveStatusHistories.
     * @param {LeaveStatusHistoryDeleteManyArgs} args - Arguments to filter LeaveStatusHistories to delete.
     * @example
     * // Delete a few LeaveStatusHistories
     * const { count } = await prisma.leaveStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, LeaveStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveStatusHistories
     * const leaveStatusHistory = await prisma.leaveStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveStatusHistoryUpdateManyArgs>(args: SelectSubset<T, LeaveStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveStatusHistories and returns the data updated in the database.
     * @param {LeaveStatusHistoryUpdateManyAndReturnArgs} args - Arguments to update many LeaveStatusHistories.
     * @example
     * // Update many LeaveStatusHistories
     * const leaveStatusHistory = await prisma.leaveStatusHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveStatusHistories and only return the `id`
     * const leaveStatusHistoryWithIdOnly = await prisma.leaveStatusHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveStatusHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveStatusHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveStatusHistory.
     * @param {LeaveStatusHistoryUpsertArgs} args - Arguments to update or create a LeaveStatusHistory.
     * @example
     * // Update or create a LeaveStatusHistory
     * const leaveStatusHistory = await prisma.leaveStatusHistory.upsert({
     *   create: {
     *     // ... data to create a LeaveStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends LeaveStatusHistoryUpsertArgs>(args: SelectSubset<T, LeaveStatusHistoryUpsertArgs<ExtArgs>>): Prisma__LeaveStatusHistoryClient<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusHistoryCountArgs} args - Arguments to filter LeaveStatusHistories to count.
     * @example
     * // Count the number of LeaveStatusHistories
     * const count = await prisma.leaveStatusHistory.count({
     *   where: {
     *     // ... the filter for the LeaveStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends LeaveStatusHistoryCountArgs>(
      args?: Subset<T, LeaveStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveStatusHistoryAggregateArgs>(args: Subset<T, LeaveStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetLeaveStatusHistoryAggregateType<T>>

    /**
     * Group by LeaveStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LeaveStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveStatusHistory model
   */
  readonly fields: LeaveStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leave<T extends LeaveRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequestDefaultArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    changedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends LeaveStatusHistory$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, LeaveStatusHistory$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveStatusHistory model
   */ 
  interface LeaveStatusHistoryFieldRefs {
    readonly id: FieldRef<"LeaveStatusHistory", 'Int'>
    readonly leaveId: FieldRef<"LeaveStatusHistory", 'String'>
    readonly status: FieldRef<"LeaveStatusHistory", 'LeaveStatus'>
    readonly comment: FieldRef<"LeaveStatusHistory", 'String'>
    readonly changedById: FieldRef<"LeaveStatusHistory", 'String'>
    readonly createdAt: FieldRef<"LeaveStatusHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveStatusHistory findUnique
   */
  export type LeaveStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LeaveStatusHistory to fetch.
     */
    where: LeaveStatusHistoryWhereUniqueInput
  }

  /**
   * LeaveStatusHistory findUniqueOrThrow
   */
  export type LeaveStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LeaveStatusHistory to fetch.
     */
    where: LeaveStatusHistoryWhereUniqueInput
  }

  /**
   * LeaveStatusHistory findFirst
   */
  export type LeaveStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LeaveStatusHistory to fetch.
     */
    where?: LeaveStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveStatusHistories to fetch.
     */
    orderBy?: LeaveStatusHistoryOrderByWithRelationInput | LeaveStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveStatusHistories.
     */
    cursor?: LeaveStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveStatusHistories.
     */
    distinct?: LeaveStatusHistoryScalarFieldEnum | LeaveStatusHistoryScalarFieldEnum[]
  }

  /**
   * LeaveStatusHistory findFirstOrThrow
   */
  export type LeaveStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LeaveStatusHistory to fetch.
     */
    where?: LeaveStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveStatusHistories to fetch.
     */
    orderBy?: LeaveStatusHistoryOrderByWithRelationInput | LeaveStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveStatusHistories.
     */
    cursor?: LeaveStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveStatusHistories.
     */
    distinct?: LeaveStatusHistoryScalarFieldEnum | LeaveStatusHistoryScalarFieldEnum[]
  }

  /**
   * LeaveStatusHistory findMany
   */
  export type LeaveStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LeaveStatusHistories to fetch.
     */
    where?: LeaveStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveStatusHistories to fetch.
     */
    orderBy?: LeaveStatusHistoryOrderByWithRelationInput | LeaveStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveStatusHistories.
     */
    cursor?: LeaveStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveStatusHistories.
     */
    skip?: number
    distinct?: LeaveStatusHistoryScalarFieldEnum | LeaveStatusHistoryScalarFieldEnum[]
  }

  /**
   * LeaveStatusHistory create
   */
  export type LeaveStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveStatusHistory.
     */
    data: XOR<LeaveStatusHistoryCreateInput, LeaveStatusHistoryUncheckedCreateInput>
  }

  /**
   * LeaveStatusHistory createMany
   */
  export type LeaveStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveStatusHistories.
     */
    data: LeaveStatusHistoryCreateManyInput | LeaveStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveStatusHistory createManyAndReturn
   */
  export type LeaveStatusHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveStatusHistories.
     */
    data: LeaveStatusHistoryCreateManyInput | LeaveStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveStatusHistory update
   */
  export type LeaveStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveStatusHistory.
     */
    data: XOR<LeaveStatusHistoryUpdateInput, LeaveStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which LeaveStatusHistory to update.
     */
    where: LeaveStatusHistoryWhereUniqueInput
  }

  /**
   * LeaveStatusHistory updateMany
   */
  export type LeaveStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveStatusHistories.
     */
    data: XOR<LeaveStatusHistoryUpdateManyMutationInput, LeaveStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LeaveStatusHistories to update
     */
    where?: LeaveStatusHistoryWhereInput
    /**
     * Limit how many LeaveStatusHistories to update.
     */
    limit?: number
  }

  /**
   * LeaveStatusHistory updateManyAndReturn
   */
  export type LeaveStatusHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to update LeaveStatusHistories.
     */
    data: XOR<LeaveStatusHistoryUpdateManyMutationInput, LeaveStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LeaveStatusHistories to update
     */
    where?: LeaveStatusHistoryWhereInput
    /**
     * Limit how many LeaveStatusHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveStatusHistory upsert
   */
  export type LeaveStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveStatusHistory to update in case it exists.
     */
    where: LeaveStatusHistoryWhereUniqueInput
    /**
     * In case the LeaveStatusHistory found by the `where` argument doesn't exist, create a new LeaveStatusHistory with this data.
     */
    create: XOR<LeaveStatusHistoryCreateInput, LeaveStatusHistoryUncheckedCreateInput>
    /**
     * In case the LeaveStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveStatusHistoryUpdateInput, LeaveStatusHistoryUncheckedUpdateInput>
  }

  /**
   * LeaveStatusHistory delete
   */
  export type LeaveStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which LeaveStatusHistory to delete.
     */
    where: LeaveStatusHistoryWhereUniqueInput
  }

  /**
   * LeaveStatusHistory deleteMany
   */
  export type LeaveStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveStatusHistories to delete
     */
    where?: LeaveStatusHistoryWhereInput
    /**
     * Limit how many LeaveStatusHistories to delete.
     */
    limit?: number
  }

  /**
   * LeaveStatusHistory.attachments
   */
  export type LeaveStatusHistory$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
    where?: LeaveStatusAttachmentWhereInput
    orderBy?: LeaveStatusAttachmentOrderByWithRelationInput | LeaveStatusAttachmentOrderByWithRelationInput[]
    cursor?: LeaveStatusAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveStatusAttachmentScalarFieldEnum | LeaveStatusAttachmentScalarFieldEnum[]
  }

  /**
   * LeaveStatusHistory without action
   */
  export type LeaveStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusHistory
     */
    select?: LeaveStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusHistory
     */
    omit?: LeaveStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model LeaveStatusAttachment
   */

  export type AggregateLeaveStatusAttachment = {
    _count: LeaveStatusAttachmentCountAggregateOutputType | null
    _avg: LeaveStatusAttachmentAvgAggregateOutputType | null
    _sum: LeaveStatusAttachmentSumAggregateOutputType | null
    _min: LeaveStatusAttachmentMinAggregateOutputType | null
    _max: LeaveStatusAttachmentMaxAggregateOutputType | null
  }

  export type LeaveStatusAttachmentAvgAggregateOutputType = {
    id: number | null
    historyId: number | null
  }

  export type LeaveStatusAttachmentSumAggregateOutputType = {
    id: number | null
    historyId: number | null
  }

  export type LeaveStatusAttachmentMinAggregateOutputType = {
    id: number | null
    historyId: number | null
    fileName: string | null
    fileKey: string | null
    fileType: string | null
    uploadedAt: Date | null
  }

  export type LeaveStatusAttachmentMaxAggregateOutputType = {
    id: number | null
    historyId: number | null
    fileName: string | null
    fileKey: string | null
    fileType: string | null
    uploadedAt: Date | null
  }

  export type LeaveStatusAttachmentCountAggregateOutputType = {
    id: number
    historyId: number
    fileName: number
    fileKey: number
    fileType: number
    uploadedAt: number
    _all: number
  }


  export type LeaveStatusAttachmentAvgAggregateInputType = {
    id?: true
    historyId?: true
  }

  export type LeaveStatusAttachmentSumAggregateInputType = {
    id?: true
    historyId?: true
  }

  export type LeaveStatusAttachmentMinAggregateInputType = {
    id?: true
    historyId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
  }

  export type LeaveStatusAttachmentMaxAggregateInputType = {
    id?: true
    historyId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
  }

  export type LeaveStatusAttachmentCountAggregateInputType = {
    id?: true
    historyId?: true
    fileName?: true
    fileKey?: true
    fileType?: true
    uploadedAt?: true
    _all?: true
  }

  export type LeaveStatusAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveStatusAttachment to aggregate.
     */
    where?: LeaveStatusAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveStatusAttachments to fetch.
     */
    orderBy?: LeaveStatusAttachmentOrderByWithRelationInput | LeaveStatusAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveStatusAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveStatusAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveStatusAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveStatusAttachments
    **/
    _count?: true | LeaveStatusAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveStatusAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveStatusAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveStatusAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveStatusAttachmentMaxAggregateInputType
  }

  export type GetLeaveStatusAttachmentAggregateType<T extends LeaveStatusAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveStatusAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveStatusAttachment[P]>
      : GetScalarType<T[P], AggregateLeaveStatusAttachment[P]>
  }




  export type LeaveStatusAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveStatusAttachmentWhereInput
    orderBy?: LeaveStatusAttachmentOrderByWithAggregationInput | LeaveStatusAttachmentOrderByWithAggregationInput[]
    by: LeaveStatusAttachmentScalarFieldEnum[] | LeaveStatusAttachmentScalarFieldEnum
    having?: LeaveStatusAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveStatusAttachmentCountAggregateInputType | true
    _avg?: LeaveStatusAttachmentAvgAggregateInputType
    _sum?: LeaveStatusAttachmentSumAggregateInputType
    _min?: LeaveStatusAttachmentMinAggregateInputType
    _max?: LeaveStatusAttachmentMaxAggregateInputType
  }

  export type LeaveStatusAttachmentGroupByOutputType = {
    id: number
    historyId: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt: Date
    _count: LeaveStatusAttachmentCountAggregateOutputType | null
    _avg: LeaveStatusAttachmentAvgAggregateOutputType | null
    _sum: LeaveStatusAttachmentSumAggregateOutputType | null
    _min: LeaveStatusAttachmentMinAggregateOutputType | null
    _max: LeaveStatusAttachmentMaxAggregateOutputType | null
  }

  type GetLeaveStatusAttachmentGroupByPayload<T extends LeaveStatusAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveStatusAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveStatusAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveStatusAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveStatusAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type LeaveStatusAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    historyId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    history?: boolean | LeaveStatusHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveStatusAttachment"]>

  export type LeaveStatusAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    historyId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    history?: boolean | LeaveStatusHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveStatusAttachment"]>

  export type LeaveStatusAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    historyId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
    history?: boolean | LeaveStatusHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveStatusAttachment"]>

  export type LeaveStatusAttachmentSelectScalar = {
    id?: boolean
    historyId?: boolean
    fileName?: boolean
    fileKey?: boolean
    fileType?: boolean
    uploadedAt?: boolean
  }

  export type LeaveStatusAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "historyId" | "fileName" | "fileKey" | "fileType" | "uploadedAt", ExtArgs["result"]["leaveStatusAttachment"]>
  export type LeaveStatusAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | LeaveStatusHistoryDefaultArgs<ExtArgs>
  }
  export type LeaveStatusAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | LeaveStatusHistoryDefaultArgs<ExtArgs>
  }
  export type LeaveStatusAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | LeaveStatusHistoryDefaultArgs<ExtArgs>
  }

  export type $LeaveStatusAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveStatusAttachment"
    objects: {
      history: Prisma.$LeaveStatusHistoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      historyId: number
      fileName: string
      fileKey: string
      fileType: string
      uploadedAt: Date
    }, ExtArgs["result"]["leaveStatusAttachment"]>
    composites: {}
  }

  type LeaveStatusAttachmentGetPayload<S extends boolean | null | undefined | LeaveStatusAttachmentDefaultArgs> = $Result.GetResult<Prisma.$LeaveStatusAttachmentPayload, S>

  type LeaveStatusAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveStatusAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveStatusAttachmentCountAggregateInputType | true
    }

  export interface LeaveStatusAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveStatusAttachment'], meta: { name: 'LeaveStatusAttachment' } }
    /**
     * Find zero or one LeaveStatusAttachment that matches the filter.
     * @param {LeaveStatusAttachmentFindUniqueArgs} args - Arguments to find a LeaveStatusAttachment
     * @example
     * // Get one LeaveStatusAttachment
     * const leaveStatusAttachment = await prisma.leaveStatusAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveStatusAttachmentFindUniqueArgs>(args: SelectSubset<T, LeaveStatusAttachmentFindUniqueArgs<ExtArgs>>): Prisma__LeaveStatusAttachmentClient<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveStatusAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveStatusAttachmentFindUniqueOrThrowArgs} args - Arguments to find a LeaveStatusAttachment
     * @example
     * // Get one LeaveStatusAttachment
     * const leaveStatusAttachment = await prisma.leaveStatusAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveStatusAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveStatusAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveStatusAttachmentClient<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveStatusAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusAttachmentFindFirstArgs} args - Arguments to find a LeaveStatusAttachment
     * @example
     * // Get one LeaveStatusAttachment
     * const leaveStatusAttachment = await prisma.leaveStatusAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveStatusAttachmentFindFirstArgs>(args?: SelectSubset<T, LeaveStatusAttachmentFindFirstArgs<ExtArgs>>): Prisma__LeaveStatusAttachmentClient<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveStatusAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusAttachmentFindFirstOrThrowArgs} args - Arguments to find a LeaveStatusAttachment
     * @example
     * // Get one LeaveStatusAttachment
     * const leaveStatusAttachment = await prisma.leaveStatusAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveStatusAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveStatusAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveStatusAttachmentClient<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveStatusAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveStatusAttachments
     * const leaveStatusAttachments = await prisma.leaveStatusAttachment.findMany()
     * 
     * // Get first 10 LeaveStatusAttachments
     * const leaveStatusAttachments = await prisma.leaveStatusAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveStatusAttachmentWithIdOnly = await prisma.leaveStatusAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveStatusAttachmentFindManyArgs>(args?: SelectSubset<T, LeaveStatusAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveStatusAttachment.
     * @param {LeaveStatusAttachmentCreateArgs} args - Arguments to create a LeaveStatusAttachment.
     * @example
     * // Create one LeaveStatusAttachment
     * const LeaveStatusAttachment = await prisma.leaveStatusAttachment.create({
     *   data: {
     *     // ... data to create a LeaveStatusAttachment
     *   }
     * })
     * 
     */
    create<T extends LeaveStatusAttachmentCreateArgs>(args: SelectSubset<T, LeaveStatusAttachmentCreateArgs<ExtArgs>>): Prisma__LeaveStatusAttachmentClient<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveStatusAttachments.
     * @param {LeaveStatusAttachmentCreateManyArgs} args - Arguments to create many LeaveStatusAttachments.
     * @example
     * // Create many LeaveStatusAttachments
     * const leaveStatusAttachment = await prisma.leaveStatusAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveStatusAttachmentCreateManyArgs>(args?: SelectSubset<T, LeaveStatusAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveStatusAttachments and returns the data saved in the database.
     * @param {LeaveStatusAttachmentCreateManyAndReturnArgs} args - Arguments to create many LeaveStatusAttachments.
     * @example
     * // Create many LeaveStatusAttachments
     * const leaveStatusAttachment = await prisma.leaveStatusAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveStatusAttachments and only return the `id`
     * const leaveStatusAttachmentWithIdOnly = await prisma.leaveStatusAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveStatusAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveStatusAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveStatusAttachment.
     * @param {LeaveStatusAttachmentDeleteArgs} args - Arguments to delete one LeaveStatusAttachment.
     * @example
     * // Delete one LeaveStatusAttachment
     * const LeaveStatusAttachment = await prisma.leaveStatusAttachment.delete({
     *   where: {
     *     // ... filter to delete one LeaveStatusAttachment
     *   }
     * })
     * 
     */
    delete<T extends LeaveStatusAttachmentDeleteArgs>(args: SelectSubset<T, LeaveStatusAttachmentDeleteArgs<ExtArgs>>): Prisma__LeaveStatusAttachmentClient<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveStatusAttachment.
     * @param {LeaveStatusAttachmentUpdateArgs} args - Arguments to update one LeaveStatusAttachment.
     * @example
     * // Update one LeaveStatusAttachment
     * const leaveStatusAttachment = await prisma.leaveStatusAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveStatusAttachmentUpdateArgs>(args: SelectSubset<T, LeaveStatusAttachmentUpdateArgs<ExtArgs>>): Prisma__LeaveStatusAttachmentClient<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveStatusAttachments.
     * @param {LeaveStatusAttachmentDeleteManyArgs} args - Arguments to filter LeaveStatusAttachments to delete.
     * @example
     * // Delete a few LeaveStatusAttachments
     * const { count } = await prisma.leaveStatusAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveStatusAttachmentDeleteManyArgs>(args?: SelectSubset<T, LeaveStatusAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveStatusAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveStatusAttachments
     * const leaveStatusAttachment = await prisma.leaveStatusAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveStatusAttachmentUpdateManyArgs>(args: SelectSubset<T, LeaveStatusAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveStatusAttachments and returns the data updated in the database.
     * @param {LeaveStatusAttachmentUpdateManyAndReturnArgs} args - Arguments to update many LeaveStatusAttachments.
     * @example
     * // Update many LeaveStatusAttachments
     * const leaveStatusAttachment = await prisma.leaveStatusAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveStatusAttachments and only return the `id`
     * const leaveStatusAttachmentWithIdOnly = await prisma.leaveStatusAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveStatusAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveStatusAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveStatusAttachment.
     * @param {LeaveStatusAttachmentUpsertArgs} args - Arguments to update or create a LeaveStatusAttachment.
     * @example
     * // Update or create a LeaveStatusAttachment
     * const leaveStatusAttachment = await prisma.leaveStatusAttachment.upsert({
     *   create: {
     *     // ... data to create a LeaveStatusAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveStatusAttachment we want to update
     *   }
     * })
     */
    upsert<T extends LeaveStatusAttachmentUpsertArgs>(args: SelectSubset<T, LeaveStatusAttachmentUpsertArgs<ExtArgs>>): Prisma__LeaveStatusAttachmentClient<$Result.GetResult<Prisma.$LeaveStatusAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveStatusAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusAttachmentCountArgs} args - Arguments to filter LeaveStatusAttachments to count.
     * @example
     * // Count the number of LeaveStatusAttachments
     * const count = await prisma.leaveStatusAttachment.count({
     *   where: {
     *     // ... the filter for the LeaveStatusAttachments we want to count
     *   }
     * })
    **/
    count<T extends LeaveStatusAttachmentCountArgs>(
      args?: Subset<T, LeaveStatusAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveStatusAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveStatusAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveStatusAttachmentAggregateArgs>(args: Subset<T, LeaveStatusAttachmentAggregateArgs>): Prisma.PrismaPromise<GetLeaveStatusAttachmentAggregateType<T>>

    /**
     * Group by LeaveStatusAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveStatusAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveStatusAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveStatusAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: LeaveStatusAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveStatusAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveStatusAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveStatusAttachment model
   */
  readonly fields: LeaveStatusAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveStatusAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveStatusAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    history<T extends LeaveStatusHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveStatusHistoryDefaultArgs<ExtArgs>>): Prisma__LeaveStatusHistoryClient<$Result.GetResult<Prisma.$LeaveStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveStatusAttachment model
   */ 
  interface LeaveStatusAttachmentFieldRefs {
    readonly id: FieldRef<"LeaveStatusAttachment", 'Int'>
    readonly historyId: FieldRef<"LeaveStatusAttachment", 'Int'>
    readonly fileName: FieldRef<"LeaveStatusAttachment", 'String'>
    readonly fileKey: FieldRef<"LeaveStatusAttachment", 'String'>
    readonly fileType: FieldRef<"LeaveStatusAttachment", 'String'>
    readonly uploadedAt: FieldRef<"LeaveStatusAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveStatusAttachment findUnique
   */
  export type LeaveStatusAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveStatusAttachment to fetch.
     */
    where: LeaveStatusAttachmentWhereUniqueInput
  }

  /**
   * LeaveStatusAttachment findUniqueOrThrow
   */
  export type LeaveStatusAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveStatusAttachment to fetch.
     */
    where: LeaveStatusAttachmentWhereUniqueInput
  }

  /**
   * LeaveStatusAttachment findFirst
   */
  export type LeaveStatusAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveStatusAttachment to fetch.
     */
    where?: LeaveStatusAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveStatusAttachments to fetch.
     */
    orderBy?: LeaveStatusAttachmentOrderByWithRelationInput | LeaveStatusAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveStatusAttachments.
     */
    cursor?: LeaveStatusAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveStatusAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveStatusAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveStatusAttachments.
     */
    distinct?: LeaveStatusAttachmentScalarFieldEnum | LeaveStatusAttachmentScalarFieldEnum[]
  }

  /**
   * LeaveStatusAttachment findFirstOrThrow
   */
  export type LeaveStatusAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveStatusAttachment to fetch.
     */
    where?: LeaveStatusAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveStatusAttachments to fetch.
     */
    orderBy?: LeaveStatusAttachmentOrderByWithRelationInput | LeaveStatusAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveStatusAttachments.
     */
    cursor?: LeaveStatusAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveStatusAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveStatusAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveStatusAttachments.
     */
    distinct?: LeaveStatusAttachmentScalarFieldEnum | LeaveStatusAttachmentScalarFieldEnum[]
  }

  /**
   * LeaveStatusAttachment findMany
   */
  export type LeaveStatusAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LeaveStatusAttachments to fetch.
     */
    where?: LeaveStatusAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveStatusAttachments to fetch.
     */
    orderBy?: LeaveStatusAttachmentOrderByWithRelationInput | LeaveStatusAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveStatusAttachments.
     */
    cursor?: LeaveStatusAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveStatusAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveStatusAttachments.
     */
    skip?: number
    distinct?: LeaveStatusAttachmentScalarFieldEnum | LeaveStatusAttachmentScalarFieldEnum[]
  }

  /**
   * LeaveStatusAttachment create
   */
  export type LeaveStatusAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveStatusAttachment.
     */
    data: XOR<LeaveStatusAttachmentCreateInput, LeaveStatusAttachmentUncheckedCreateInput>
  }

  /**
   * LeaveStatusAttachment createMany
   */
  export type LeaveStatusAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveStatusAttachments.
     */
    data: LeaveStatusAttachmentCreateManyInput | LeaveStatusAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveStatusAttachment createManyAndReturn
   */
  export type LeaveStatusAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveStatusAttachments.
     */
    data: LeaveStatusAttachmentCreateManyInput | LeaveStatusAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveStatusAttachment update
   */
  export type LeaveStatusAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveStatusAttachment.
     */
    data: XOR<LeaveStatusAttachmentUpdateInput, LeaveStatusAttachmentUncheckedUpdateInput>
    /**
     * Choose, which LeaveStatusAttachment to update.
     */
    where: LeaveStatusAttachmentWhereUniqueInput
  }

  /**
   * LeaveStatusAttachment updateMany
   */
  export type LeaveStatusAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveStatusAttachments.
     */
    data: XOR<LeaveStatusAttachmentUpdateManyMutationInput, LeaveStatusAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which LeaveStatusAttachments to update
     */
    where?: LeaveStatusAttachmentWhereInput
    /**
     * Limit how many LeaveStatusAttachments to update.
     */
    limit?: number
  }

  /**
   * LeaveStatusAttachment updateManyAndReturn
   */
  export type LeaveStatusAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update LeaveStatusAttachments.
     */
    data: XOR<LeaveStatusAttachmentUpdateManyMutationInput, LeaveStatusAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which LeaveStatusAttachments to update
     */
    where?: LeaveStatusAttachmentWhereInput
    /**
     * Limit how many LeaveStatusAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveStatusAttachment upsert
   */
  export type LeaveStatusAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveStatusAttachment to update in case it exists.
     */
    where: LeaveStatusAttachmentWhereUniqueInput
    /**
     * In case the LeaveStatusAttachment found by the `where` argument doesn't exist, create a new LeaveStatusAttachment with this data.
     */
    create: XOR<LeaveStatusAttachmentCreateInput, LeaveStatusAttachmentUncheckedCreateInput>
    /**
     * In case the LeaveStatusAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveStatusAttachmentUpdateInput, LeaveStatusAttachmentUncheckedUpdateInput>
  }

  /**
   * LeaveStatusAttachment delete
   */
  export type LeaveStatusAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
    /**
     * Filter which LeaveStatusAttachment to delete.
     */
    where: LeaveStatusAttachmentWhereUniqueInput
  }

  /**
   * LeaveStatusAttachment deleteMany
   */
  export type LeaveStatusAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveStatusAttachments to delete
     */
    where?: LeaveStatusAttachmentWhereInput
    /**
     * Limit how many LeaveStatusAttachments to delete.
     */
    limit?: number
  }

  /**
   * LeaveStatusAttachment without action
   */
  export type LeaveStatusAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveStatusAttachment
     */
    select?: LeaveStatusAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveStatusAttachment
     */
    omit?: LeaveStatusAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveStatusAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Holiday
   */

  export type AggregateHoliday = {
    _count: HolidayCountAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  export type HolidayMinAggregateOutputType = {
    id: string | null
    name: string | null
    date: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HolidayMaxAggregateOutputType = {
    id: string | null
    name: string | null
    date: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HolidayCountAggregateOutputType = {
    id: number
    name: number
    date: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HolidayMinAggregateInputType = {
    id?: true
    name?: true
    date?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HolidayMaxAggregateInputType = {
    id?: true
    name?: true
    date?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HolidayCountAggregateInputType = {
    id?: true
    name?: true
    date?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HolidayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holiday to aggregate.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Holidays
    **/
    _count?: true | HolidayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolidayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolidayMaxAggregateInputType
  }

  export type GetHolidayAggregateType<T extends HolidayAggregateArgs> = {
        [P in keyof T & keyof AggregateHoliday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoliday[P]>
      : GetScalarType<T[P], AggregateHoliday[P]>
  }




  export type HolidayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolidayWhereInput
    orderBy?: HolidayOrderByWithAggregationInput | HolidayOrderByWithAggregationInput[]
    by: HolidayScalarFieldEnum[] | HolidayScalarFieldEnum
    having?: HolidayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolidayCountAggregateInputType | true
    _min?: HolidayMinAggregateInputType
    _max?: HolidayMaxAggregateInputType
  }

  export type HolidayGroupByOutputType = {
    id: string
    name: string
    date: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: HolidayCountAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  type GetHolidayGroupByPayload<T extends HolidayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolidayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolidayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolidayGroupByOutputType[P]>
            : GetScalarType<T[P], HolidayGroupByOutputType[P]>
        }
      >
    >


  export type HolidaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectScalar = {
    id?: boolean
    name?: boolean
    date?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HolidayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "date" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["holiday"]>

  export type $HolidayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Holiday"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      date: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["holiday"]>
    composites: {}
  }

  type HolidayGetPayload<S extends boolean | null | undefined | HolidayDefaultArgs> = $Result.GetResult<Prisma.$HolidayPayload, S>

  type HolidayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HolidayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HolidayCountAggregateInputType | true
    }

  export interface HolidayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Holiday'], meta: { name: 'Holiday' } }
    /**
     * Find zero or one Holiday that matches the filter.
     * @param {HolidayFindUniqueArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HolidayFindUniqueArgs>(args: SelectSubset<T, HolidayFindUniqueArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Holiday that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HolidayFindUniqueOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HolidayFindUniqueOrThrowArgs>(args: SelectSubset<T, HolidayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Holiday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HolidayFindFirstArgs>(args?: SelectSubset<T, HolidayFindFirstArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Holiday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HolidayFindFirstOrThrowArgs>(args?: SelectSubset<T, HolidayFindFirstOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Holidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holidays
     * const holidays = await prisma.holiday.findMany()
     * 
     * // Get first 10 Holidays
     * const holidays = await prisma.holiday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holidayWithIdOnly = await prisma.holiday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HolidayFindManyArgs>(args?: SelectSubset<T, HolidayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Holiday.
     * @param {HolidayCreateArgs} args - Arguments to create a Holiday.
     * @example
     * // Create one Holiday
     * const Holiday = await prisma.holiday.create({
     *   data: {
     *     // ... data to create a Holiday
     *   }
     * })
     * 
     */
    create<T extends HolidayCreateArgs>(args: SelectSubset<T, HolidayCreateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Holidays.
     * @param {HolidayCreateManyArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HolidayCreateManyArgs>(args?: SelectSubset<T, HolidayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Holidays and returns the data saved in the database.
     * @param {HolidayCreateManyAndReturnArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Holidays and only return the `id`
     * const holidayWithIdOnly = await prisma.holiday.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HolidayCreateManyAndReturnArgs>(args?: SelectSubset<T, HolidayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Holiday.
     * @param {HolidayDeleteArgs} args - Arguments to delete one Holiday.
     * @example
     * // Delete one Holiday
     * const Holiday = await prisma.holiday.delete({
     *   where: {
     *     // ... filter to delete one Holiday
     *   }
     * })
     * 
     */
    delete<T extends HolidayDeleteArgs>(args: SelectSubset<T, HolidayDeleteArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Holiday.
     * @param {HolidayUpdateArgs} args - Arguments to update one Holiday.
     * @example
     * // Update one Holiday
     * const holiday = await prisma.holiday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HolidayUpdateArgs>(args: SelectSubset<T, HolidayUpdateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Holidays.
     * @param {HolidayDeleteManyArgs} args - Arguments to filter Holidays to delete.
     * @example
     * // Delete a few Holidays
     * const { count } = await prisma.holiday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HolidayDeleteManyArgs>(args?: SelectSubset<T, HolidayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holidays
     * const holiday = await prisma.holiday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HolidayUpdateManyArgs>(args: SelectSubset<T, HolidayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays and returns the data updated in the database.
     * @param {HolidayUpdateManyAndReturnArgs} args - Arguments to update many Holidays.
     * @example
     * // Update many Holidays
     * const holiday = await prisma.holiday.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Holidays and only return the `id`
     * const holidayWithIdOnly = await prisma.holiday.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HolidayUpdateManyAndReturnArgs>(args: SelectSubset<T, HolidayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Holiday.
     * @param {HolidayUpsertArgs} args - Arguments to update or create a Holiday.
     * @example
     * // Update or create a Holiday
     * const holiday = await prisma.holiday.upsert({
     *   create: {
     *     // ... data to create a Holiday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holiday we want to update
     *   }
     * })
     */
    upsert<T extends HolidayUpsertArgs>(args: SelectSubset<T, HolidayUpsertArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayCountArgs} args - Arguments to filter Holidays to count.
     * @example
     * // Count the number of Holidays
     * const count = await prisma.holiday.count({
     *   where: {
     *     // ... the filter for the Holidays we want to count
     *   }
     * })
    **/
    count<T extends HolidayCountArgs>(
      args?: Subset<T, HolidayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolidayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolidayAggregateArgs>(args: Subset<T, HolidayAggregateArgs>): Prisma.PrismaPromise<GetHolidayAggregateType<T>>

    /**
     * Group by Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HolidayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HolidayGroupByArgs['orderBy'] }
        : { orderBy?: HolidayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HolidayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolidayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Holiday model
   */
  readonly fields: HolidayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Holiday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HolidayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Holiday model
   */ 
  interface HolidayFieldRefs {
    readonly id: FieldRef<"Holiday", 'String'>
    readonly name: FieldRef<"Holiday", 'String'>
    readonly date: FieldRef<"Holiday", 'DateTime'>
    readonly isActive: FieldRef<"Holiday", 'Boolean'>
    readonly createdAt: FieldRef<"Holiday", 'DateTime'>
    readonly updatedAt: FieldRef<"Holiday", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Holiday findUnique
   */
  export type HolidayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findUniqueOrThrow
   */
  export type HolidayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findFirst
   */
  export type HolidayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findFirstOrThrow
   */
  export type HolidayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findMany
   */
  export type HolidayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter, which Holidays to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday create
   */
  export type HolidayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * The data needed to create a Holiday.
     */
    data: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
  }

  /**
   * Holiday createMany
   */
  export type HolidayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Holiday createManyAndReturn
   */
  export type HolidayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Holiday update
   */
  export type HolidayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * The data needed to update a Holiday.
     */
    data: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
    /**
     * Choose, which Holiday to update.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday updateMany
   */
  export type HolidayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Holidays.
     */
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyInput>
    /**
     * Filter which Holidays to update
     */
    where?: HolidayWhereInput
    /**
     * Limit how many Holidays to update.
     */
    limit?: number
  }

  /**
   * Holiday updateManyAndReturn
   */
  export type HolidayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * The data used to update Holidays.
     */
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyInput>
    /**
     * Filter which Holidays to update
     */
    where?: HolidayWhereInput
    /**
     * Limit how many Holidays to update.
     */
    limit?: number
  }

  /**
   * Holiday upsert
   */
  export type HolidayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * The filter to search for the Holiday to update in case it exists.
     */
    where: HolidayWhereUniqueInput
    /**
     * In case the Holiday found by the `where` argument doesn't exist, create a new Holiday with this data.
     */
    create: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
    /**
     * In case the Holiday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
  }

  /**
   * Holiday delete
   */
  export type HolidayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter which Holiday to delete.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday deleteMany
   */
  export type HolidayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holidays to delete
     */
    where?: HolidayWhereInput
    /**
     * Limit how many Holidays to delete.
     */
    limit?: number
  }

  /**
   * Holiday without action
   */
  export type HolidayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Department$usersArgs<ExtArgs>
    JobListing?: boolean | Department$JobListingArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Department$usersArgs<ExtArgs>
    JobListing?: boolean | Department$JobListingArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      JobListing: Prisma.$JobListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Department$usersArgs<ExtArgs> = {}>(args?: Subset<T, Department$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JobListing<T extends Department$JobListingArgs<ExtArgs> = {}>(args?: Subset<T, Department$JobListingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.users
   */
  export type Department$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Department.JobListing
   */
  export type Department$JobListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    where?: JobListingWhereInput
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    cursor?: JobListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobListingScalarFieldEnum | JobListingScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    region: string | null
    postalCode: string | null
    country: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    region: string | null
    postalCode: string | null
    country: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    region: number
    postalCode: number
    country: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    region?: true
    postalCode?: true
    country?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    region?: true
    postalCode?: true
    country?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    region?: true
    postalCode?: true
    country?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    address: string
    city: string
    region: string
    postalCode: string
    country: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Location$usersArgs<ExtArgs>
    JobListing?: boolean | Location$JobListingArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "city" | "region" | "postalCode" | "country" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Location$usersArgs<ExtArgs>
    JobListing?: boolean | Location$JobListingArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      JobListing: Prisma.$JobListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      city: string
      region: string
      postalCode: string
      country: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Location$usersArgs<ExtArgs> = {}>(args?: Subset<T, Location$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JobListing<T extends Location$JobListingArgs<ExtArgs> = {}>(args?: Subset<T, Location$JobListingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly city: FieldRef<"Location", 'String'>
    readonly region: FieldRef<"Location", 'String'>
    readonly postalCode: FieldRef<"Location", 'String'>
    readonly country: FieldRef<"Location", 'String'>
    readonly isActive: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.users
   */
  export type Location$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Location.JobListing
   */
  export type Location$JobListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    where?: JobListingWhereInput
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    cursor?: JobListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobListingScalarFieldEnum | JobListingScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Position
   */

  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionMinAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    title: number
    code: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PositionMinAggregateInputType = {
    id?: true
    title?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    title?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    title?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Position to aggregate.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithAggregationInput | PositionOrderByWithAggregationInput[]
    by: PositionScalarFieldEnum[] | PositionScalarFieldEnum
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }

  export type PositionGroupByOutputType = {
    id: string
    title: string
    code: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PositionCountAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Position$usersArgs<ExtArgs>
    jobListings?: boolean | Position$jobListingsArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["position"]>

  export type PositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["position"]>

  export type PositionSelectScalar = {
    id?: boolean
    title?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "code" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["position"]>
  export type PositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Position$usersArgs<ExtArgs>
    jobListings?: boolean | Position$jobListingsArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Position"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      jobListings: Prisma.$JobListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      code: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["position"]>
    composites: {}
  }

  type PositionGetPayload<S extends boolean | null | undefined | PositionDefaultArgs> = $Result.GetResult<Prisma.$PositionPayload, S>

  type PositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface PositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Position'], meta: { name: 'Position' } }
    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PositionFindUniqueArgs>(args: SelectSubset<T, PositionFindUniqueArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Position that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PositionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PositionFindUniqueOrThrowArgs>(args: SelectSubset<T, PositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PositionFindFirstArgs>(args?: SelectSubset<T, PositionFindFirstArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PositionFindFirstOrThrowArgs>(args?: SelectSubset<T, PositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PositionFindManyArgs>(args?: SelectSubset<T, PositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
     */
    create<T extends PositionCreateArgs>(args: SelectSubset<T, PositionCreateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Positions.
     * @param {PositionCreateManyArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PositionCreateManyArgs>(args?: SelectSubset<T, PositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Positions and returns the data saved in the database.
     * @param {PositionCreateManyAndReturnArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PositionCreateManyAndReturnArgs>(args?: SelectSubset<T, PositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
     */
    delete<T extends PositionDeleteArgs>(args: SelectSubset<T, PositionDeleteArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PositionUpdateArgs>(args: SelectSubset<T, PositionUpdateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PositionDeleteManyArgs>(args?: SelectSubset<T, PositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PositionUpdateManyArgs>(args: SelectSubset<T, PositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions and returns the data updated in the database.
     * @param {PositionUpdateManyAndReturnArgs} args - Arguments to update many Positions.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PositionUpdateManyAndReturnArgs>(args: SelectSubset<T, PositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
     */
    upsert<T extends PositionUpsertArgs>(args: SelectSubset<T, PositionUpsertArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Position model
   */
  readonly fields: PositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Position$usersArgs<ExtArgs> = {}>(args?: Subset<T, Position$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobListings<T extends Position$jobListingsArgs<ExtArgs> = {}>(args?: Subset<T, Position$jobListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Position model
   */ 
  interface PositionFieldRefs {
    readonly id: FieldRef<"Position", 'String'>
    readonly title: FieldRef<"Position", 'String'>
    readonly code: FieldRef<"Position", 'String'>
    readonly isActive: FieldRef<"Position", 'Boolean'>
    readonly createdAt: FieldRef<"Position", 'DateTime'>
    readonly updatedAt: FieldRef<"Position", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Position findUnique
   */
  export type PositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findUniqueOrThrow
   */
  export type PositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findFirst
   */
  export type PositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findFirstOrThrow
   */
  export type PositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findMany
   */
  export type PositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Positions to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position create
   */
  export type PositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to create a Position.
     */
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }

  /**
   * Position createMany
   */
  export type PositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position createManyAndReturn
   */
  export type PositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position update
   */
  export type PositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to update a Position.
     */
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
  }

  /**
   * Position updateManyAndReturn
   */
  export type PositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
  }

  /**
   * Position upsert
   */
  export type PositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The filter to search for the Position to update in case it exists.
     */
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     */
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }

  /**
   * Position delete
   */
  export type PositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter which Position to delete.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Positions to delete
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to delete.
     */
    limit?: number
  }

  /**
   * Position.users
   */
  export type Position$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Position.jobListings
   */
  export type Position$jobListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobListing
     */
    select?: JobListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobListing
     */
    omit?: JobListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobListingInclude<ExtArgs> | null
    where?: JobListingWhereInput
    orderBy?: JobListingOrderByWithRelationInput | JobListingOrderByWithRelationInput[]
    cursor?: JobListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobListingScalarFieldEnum | JobListingScalarFieldEnum[]
  }

  /**
   * Position without action
   */
  export type PositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    vatNumber: string | null
    email: string | null
    phone: string | null
    address: string | null
    status: $Enums.ClientStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    vatNumber: string | null
    email: string | null
    phone: string | null
    address: string | null
    status: $Enums.ClientStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    vatNumber: number
    email: number
    phone: number
    address: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    vatNumber?: true
    email?: true
    phone?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    vatNumber?: true
    email?: true
    phone?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    vatNumber?: true
    email?: true
    phone?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string
    vatNumber: string
    email: string | null
    phone: string | null
    address: string | null
    status: $Enums.ClientStatus
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vatNumber?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projects?: boolean | Client$projectsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vatNumber?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    vatNumber?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    vatNumber?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "vatNumber" | "email" | "phone" | "address" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | Client$projectsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      vatNumber: string
      email: string | null
      phone: string | null
      address: string | null
      status: $Enums.ClientStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends Client$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Client$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly vatNumber: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly status: FieldRef<"Client", 'ClientStatus'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.projects
   */
  export type Client$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    clientId: string | null
    status: $Enums.ProjectStatus | null
    startDate: Date | null
    endDate: Date | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    clientId: string | null
    status: $Enums.ProjectStatus | null
    startDate: Date | null
    endDate: Date | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    clientId: number
    status: number
    startDate: number
    endDate: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    clientId?: true
    status?: true
    startDate?: true
    endDate?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    clientId?: true
    status?: true
    startDate?: true
    endDate?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    clientId?: true
    status?: true
    startDate?: true
    endDate?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    clientId: string
    status: $Enums.ProjectStatus
    startDate: Date
    endDate: Date | null
    managerId: string
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    timeEntries?: boolean | Project$timeEntriesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    clientId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "clientId" | "status" | "startDate" | "endDate" | "managerId" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    timeEntries?: boolean | Project$timeEntriesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      manager: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
      timeEntries: Prisma.$TimeEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      clientId: string
      status: $Enums.ProjectStatus
      startDate: Date
      endDate: Date | null
      managerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeEntries<T extends Project$timeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Project$timeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly clientId: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly managerId: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.timeEntries
   */
  export type Project$timeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    cursor?: TimeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    role: $Enums.ProjectMemberRole | null
    joinedAt: Date | null
    leftAt: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    role: $Enums.ProjectMemberRole | null
    joinedAt: Date | null
    leftAt: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    role: number
    joinedAt: number
    leftAt: number
    _all: number
  }


  export type ProjectMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
    leftAt?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
    leftAt?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
    leftAt?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    role: $Enums.ProjectMemberRole
    joinedAt: Date
    leftAt: Date | null
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    leftAt?: boolean
  }

  export type ProjectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "role" | "joinedAt" | "leftAt", ExtArgs["result"]["projectMember"]>
  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      role: $Enums.ProjectMemberRole
      joinedAt: Date
      leftAt: Date | null
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers and returns the data updated in the database.
     * @param {ProjectMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectMembers.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */ 
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'String'>
    readonly projectId: FieldRef<"ProjectMember", 'String'>
    readonly userId: FieldRef<"ProjectMember", 'String'>
    readonly role: FieldRef<"ProjectMember", 'ProjectMemberRole'>
    readonly joinedAt: FieldRef<"ProjectMember", 'DateTime'>
    readonly leftAt: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectMember updateManyAndReturn
   */
  export type ProjectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model TimeEntry
   */

  export type AggregateTimeEntry = {
    _count: TimeEntryCountAggregateOutputType | null
    _avg: TimeEntryAvgAggregateOutputType | null
    _sum: TimeEntrySumAggregateOutputType | null
    _min: TimeEntryMinAggregateOutputType | null
    _max: TimeEntryMaxAggregateOutputType | null
  }

  export type TimeEntryAvgAggregateOutputType = {
    duration: number | null
  }

  export type TimeEntrySumAggregateOutputType = {
    duration: number | null
  }

  export type TimeEntryMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    status: $Enums.TimeEntryStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeEntryMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    status: $Enums.TimeEntryStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeEntryCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    description: number
    startTime: number
    endTime: number
    duration: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimeEntryAvgAggregateInputType = {
    duration?: true
  }

  export type TimeEntrySumAggregateInputType = {
    duration?: true
  }

  export type TimeEntryMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    description?: true
    startTime?: true
    endTime?: true
    duration?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeEntryMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    description?: true
    startTime?: true
    endTime?: true
    duration?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeEntryCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    description?: true
    startTime?: true
    endTime?: true
    duration?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimeEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeEntry to aggregate.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeEntries
    **/
    _count?: true | TimeEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeEntryMaxAggregateInputType
  }

  export type GetTimeEntryAggregateType<T extends TimeEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeEntry[P]>
      : GetScalarType<T[P], AggregateTimeEntry[P]>
  }




  export type TimeEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithAggregationInput | TimeEntryOrderByWithAggregationInput[]
    by: TimeEntryScalarFieldEnum[] | TimeEntryScalarFieldEnum
    having?: TimeEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeEntryCountAggregateInputType | true
    _avg?: TimeEntryAvgAggregateInputType
    _sum?: TimeEntrySumAggregateInputType
    _min?: TimeEntryMinAggregateInputType
    _max?: TimeEntryMaxAggregateInputType
  }

  export type TimeEntryGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    description: string
    startTime: Date
    endTime: Date | null
    duration: number
    status: $Enums.TimeEntryStatus
    createdAt: Date
    updatedAt: Date
    _count: TimeEntryCountAggregateOutputType | null
    _avg: TimeEntryAvgAggregateOutputType | null
    _sum: TimeEntrySumAggregateOutputType | null
    _min: TimeEntryMinAggregateOutputType | null
    _max: TimeEntryMaxAggregateOutputType | null
  }

  type GetTimeEntryGroupByPayload<T extends TimeEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeEntryGroupByOutputType[P]>
            : GetScalarType<T[P], TimeEntryGroupByOutputType[P]>
        }
      >
    >


  export type TimeEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeEntry"]>

  export type TimeEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeEntry"]>

  export type TimeEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeEntry"]>

  export type TimeEntrySelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimeEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "description" | "startTime" | "endTime" | "duration" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["timeEntry"]>
  export type TimeEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimeEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimeEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TimeEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeEntry"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      description: string
      startTime: Date
      endTime: Date | null
      duration: number
      status: $Enums.TimeEntryStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timeEntry"]>
    composites: {}
  }

  type TimeEntryGetPayload<S extends boolean | null | undefined | TimeEntryDefaultArgs> = $Result.GetResult<Prisma.$TimeEntryPayload, S>

  type TimeEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeEntryCountAggregateInputType | true
    }

  export interface TimeEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeEntry'], meta: { name: 'TimeEntry' } }
    /**
     * Find zero or one TimeEntry that matches the filter.
     * @param {TimeEntryFindUniqueArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeEntryFindUniqueArgs>(args: SelectSubset<T, TimeEntryFindUniqueArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeEntryFindUniqueOrThrowArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindFirstArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeEntryFindFirstArgs>(args?: SelectSubset<T, TimeEntryFindFirstArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindFirstOrThrowArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeEntries
     * const timeEntries = await prisma.timeEntry.findMany()
     * 
     * // Get first 10 TimeEntries
     * const timeEntries = await prisma.timeEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeEntryWithIdOnly = await prisma.timeEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeEntryFindManyArgs>(args?: SelectSubset<T, TimeEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeEntry.
     * @param {TimeEntryCreateArgs} args - Arguments to create a TimeEntry.
     * @example
     * // Create one TimeEntry
     * const TimeEntry = await prisma.timeEntry.create({
     *   data: {
     *     // ... data to create a TimeEntry
     *   }
     * })
     * 
     */
    create<T extends TimeEntryCreateArgs>(args: SelectSubset<T, TimeEntryCreateArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeEntries.
     * @param {TimeEntryCreateManyArgs} args - Arguments to create many TimeEntries.
     * @example
     * // Create many TimeEntries
     * const timeEntry = await prisma.timeEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeEntryCreateManyArgs>(args?: SelectSubset<T, TimeEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeEntries and returns the data saved in the database.
     * @param {TimeEntryCreateManyAndReturnArgs} args - Arguments to create many TimeEntries.
     * @example
     * // Create many TimeEntries
     * const timeEntry = await prisma.timeEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeEntries and only return the `id`
     * const timeEntryWithIdOnly = await prisma.timeEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeEntry.
     * @param {TimeEntryDeleteArgs} args - Arguments to delete one TimeEntry.
     * @example
     * // Delete one TimeEntry
     * const TimeEntry = await prisma.timeEntry.delete({
     *   where: {
     *     // ... filter to delete one TimeEntry
     *   }
     * })
     * 
     */
    delete<T extends TimeEntryDeleteArgs>(args: SelectSubset<T, TimeEntryDeleteArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeEntry.
     * @param {TimeEntryUpdateArgs} args - Arguments to update one TimeEntry.
     * @example
     * // Update one TimeEntry
     * const timeEntry = await prisma.timeEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeEntryUpdateArgs>(args: SelectSubset<T, TimeEntryUpdateArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeEntries.
     * @param {TimeEntryDeleteManyArgs} args - Arguments to filter TimeEntries to delete.
     * @example
     * // Delete a few TimeEntries
     * const { count } = await prisma.timeEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeEntryDeleteManyArgs>(args?: SelectSubset<T, TimeEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeEntries
     * const timeEntry = await prisma.timeEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeEntryUpdateManyArgs>(args: SelectSubset<T, TimeEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeEntries and returns the data updated in the database.
     * @param {TimeEntryUpdateManyAndReturnArgs} args - Arguments to update many TimeEntries.
     * @example
     * // Update many TimeEntries
     * const timeEntry = await prisma.timeEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeEntries and only return the `id`
     * const timeEntryWithIdOnly = await prisma.timeEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeEntry.
     * @param {TimeEntryUpsertArgs} args - Arguments to update or create a TimeEntry.
     * @example
     * // Update or create a TimeEntry
     * const timeEntry = await prisma.timeEntry.upsert({
     *   create: {
     *     // ... data to create a TimeEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeEntry we want to update
     *   }
     * })
     */
    upsert<T extends TimeEntryUpsertArgs>(args: SelectSubset<T, TimeEntryUpsertArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryCountArgs} args - Arguments to filter TimeEntries to count.
     * @example
     * // Count the number of TimeEntries
     * const count = await prisma.timeEntry.count({
     *   where: {
     *     // ... the filter for the TimeEntries we want to count
     *   }
     * })
    **/
    count<T extends TimeEntryCountArgs>(
      args?: Subset<T, TimeEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeEntryAggregateArgs>(args: Subset<T, TimeEntryAggregateArgs>): Prisma.PrismaPromise<GetTimeEntryAggregateType<T>>

    /**
     * Group by TimeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeEntryGroupByArgs['orderBy'] }
        : { orderBy?: TimeEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeEntry model
   */
  readonly fields: TimeEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeEntry model
   */ 
  interface TimeEntryFieldRefs {
    readonly id: FieldRef<"TimeEntry", 'String'>
    readonly projectId: FieldRef<"TimeEntry", 'String'>
    readonly userId: FieldRef<"TimeEntry", 'String'>
    readonly description: FieldRef<"TimeEntry", 'String'>
    readonly startTime: FieldRef<"TimeEntry", 'DateTime'>
    readonly endTime: FieldRef<"TimeEntry", 'DateTime'>
    readonly duration: FieldRef<"TimeEntry", 'Int'>
    readonly status: FieldRef<"TimeEntry", 'TimeEntryStatus'>
    readonly createdAt: FieldRef<"TimeEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimeEntry findUnique
   */
  export type TimeEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry findUniqueOrThrow
   */
  export type TimeEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry findFirst
   */
  export type TimeEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeEntries.
     */
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry findFirstOrThrow
   */
  export type TimeEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeEntries.
     */
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry findMany
   */
  export type TimeEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntries to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry create
   */
  export type TimeEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeEntry.
     */
    data: XOR<TimeEntryCreateInput, TimeEntryUncheckedCreateInput>
  }

  /**
   * TimeEntry createMany
   */
  export type TimeEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeEntries.
     */
    data: TimeEntryCreateManyInput | TimeEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeEntry createManyAndReturn
   */
  export type TimeEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * The data used to create many TimeEntries.
     */
    data: TimeEntryCreateManyInput | TimeEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeEntry update
   */
  export type TimeEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeEntry.
     */
    data: XOR<TimeEntryUpdateInput, TimeEntryUncheckedUpdateInput>
    /**
     * Choose, which TimeEntry to update.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry updateMany
   */
  export type TimeEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeEntries.
     */
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyInput>
    /**
     * Filter which TimeEntries to update
     */
    where?: TimeEntryWhereInput
    /**
     * Limit how many TimeEntries to update.
     */
    limit?: number
  }

  /**
   * TimeEntry updateManyAndReturn
   */
  export type TimeEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * The data used to update TimeEntries.
     */
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyInput>
    /**
     * Filter which TimeEntries to update
     */
    where?: TimeEntryWhereInput
    /**
     * Limit how many TimeEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeEntry upsert
   */
  export type TimeEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeEntry to update in case it exists.
     */
    where: TimeEntryWhereUniqueInput
    /**
     * In case the TimeEntry found by the `where` argument doesn't exist, create a new TimeEntry with this data.
     */
    create: XOR<TimeEntryCreateInput, TimeEntryUncheckedCreateInput>
    /**
     * In case the TimeEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeEntryUpdateInput, TimeEntryUncheckedUpdateInput>
  }

  /**
   * TimeEntry delete
   */
  export type TimeEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter which TimeEntry to delete.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry deleteMany
   */
  export type TimeEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeEntries to delete
     */
    where?: TimeEntryWhereInput
    /**
     * Limit how many TimeEntries to delete.
     */
    limit?: number
  }

  /**
   * TimeEntry without action
   */
  export type TimeEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeEntry
     */
    omit?: TimeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    changedBy: string | null
    publishedBy: string | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    changedBy: string | null
    publishedBy: string | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    content: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    changedBy: number
    publishedBy: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    changedBy?: true
    publishedBy?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    changedBy?: true
    publishedBy?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    changedBy?: true
    publishedBy?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    content: string
    publishedAt: Date
    createdAt: Date
    updatedAt: Date
    changedBy: string
    publishedBy: string
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    changedBy?: boolean
    publishedBy?: boolean
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
    publishedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    changedBy?: boolean
    publishedBy?: boolean
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
    publishedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    changedBy?: boolean
    publishedBy?: boolean
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
    publishedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    changedBy?: boolean
    publishedBy?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "publishedAt" | "createdAt" | "updatedAt" | "changedBy" | "publishedBy", ExtArgs["result"]["announcement"]>
  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
    publishedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
    publishedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changedByUser?: boolean | UserDefaultArgs<ExtArgs>
    publishedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      changedByUser: Prisma.$UserPayload<ExtArgs>
      publishedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      publishedAt: Date
      createdAt: Date
      updatedAt: Date
      changedBy: string
      publishedBy: string
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    changedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publishedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */ 
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly publishedAt: FieldRef<"Announcement", 'DateTime'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
    readonly updatedAt: FieldRef<"Announcement", 'DateTime'>
    readonly changedBy: FieldRef<"Announcement", 'String'>
    readonly publishedBy: FieldRef<"Announcement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement updateManyAndReturn
   */
  export type AnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model TimeSchedule
   */

  export type AggregateTimeSchedule = {
    _count: TimeScheduleCountAggregateOutputType | null
    _min: TimeScheduleMinAggregateOutputType | null
    _max: TimeScheduleMaxAggregateOutputType | null
  }

  export type TimeScheduleMinAggregateOutputType = {
    id: string | null
    name: string | null
    startTime: string | null
    endTime: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeScheduleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startTime: string | null
    endTime: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeScheduleCountAggregateOutputType = {
    id: number
    name: number
    startTime: number
    endTime: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimeScheduleMinAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeScheduleMaxAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeScheduleCountAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimeScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSchedule to aggregate.
     */
    where?: TimeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSchedules to fetch.
     */
    orderBy?: TimeScheduleOrderByWithRelationInput | TimeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSchedules
    **/
    _count?: true | TimeScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeScheduleMaxAggregateInputType
  }

  export type GetTimeScheduleAggregateType<T extends TimeScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSchedule[P]>
      : GetScalarType<T[P], AggregateTimeSchedule[P]>
  }




  export type TimeScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeScheduleWhereInput
    orderBy?: TimeScheduleOrderByWithAggregationInput | TimeScheduleOrderByWithAggregationInput[]
    by: TimeScheduleScalarFieldEnum[] | TimeScheduleScalarFieldEnum
    having?: TimeScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeScheduleCountAggregateInputType | true
    _min?: TimeScheduleMinAggregateInputType
    _max?: TimeScheduleMaxAggregateInputType
  }

  export type TimeScheduleGroupByOutputType = {
    id: string
    name: string
    startTime: string
    endTime: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TimeScheduleCountAggregateOutputType | null
    _min: TimeScheduleMinAggregateOutputType | null
    _max: TimeScheduleMaxAggregateOutputType | null
  }

  type GetTimeScheduleGroupByPayload<T extends TimeScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], TimeScheduleGroupByOutputType[P]>
        }
      >
    >


  export type TimeScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shifts?: boolean | TimeSchedule$shiftsArgs<ExtArgs>
    _count?: boolean | TimeScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSchedule"]>

  export type TimeScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["timeSchedule"]>

  export type TimeScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["timeSchedule"]>

  export type TimeScheduleSelectScalar = {
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimeScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startTime" | "endTime" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["timeSchedule"]>
  export type TimeScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | TimeSchedule$shiftsArgs<ExtArgs>
    _count?: boolean | TimeScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TimeScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TimeScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TimeSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeSchedule"
    objects: {
      shifts: Prisma.$ShiftEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startTime: string
      endTime: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timeSchedule"]>
    composites: {}
  }

  type TimeScheduleGetPayload<S extends boolean | null | undefined | TimeScheduleDefaultArgs> = $Result.GetResult<Prisma.$TimeSchedulePayload, S>

  type TimeScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeScheduleCountAggregateInputType | true
    }

  export interface TimeScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeSchedule'], meta: { name: 'TimeSchedule' } }
    /**
     * Find zero or one TimeSchedule that matches the filter.
     * @param {TimeScheduleFindUniqueArgs} args - Arguments to find a TimeSchedule
     * @example
     * // Get one TimeSchedule
     * const timeSchedule = await prisma.timeSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeScheduleFindUniqueArgs>(args: SelectSubset<T, TimeScheduleFindUniqueArgs<ExtArgs>>): Prisma__TimeScheduleClient<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeScheduleFindUniqueOrThrowArgs} args - Arguments to find a TimeSchedule
     * @example
     * // Get one TimeSchedule
     * const timeSchedule = await prisma.timeSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeScheduleClient<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeScheduleFindFirstArgs} args - Arguments to find a TimeSchedule
     * @example
     * // Get one TimeSchedule
     * const timeSchedule = await prisma.timeSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeScheduleFindFirstArgs>(args?: SelectSubset<T, TimeScheduleFindFirstArgs<ExtArgs>>): Prisma__TimeScheduleClient<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeScheduleFindFirstOrThrowArgs} args - Arguments to find a TimeSchedule
     * @example
     * // Get one TimeSchedule
     * const timeSchedule = await prisma.timeSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeScheduleClient<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSchedules
     * const timeSchedules = await prisma.timeSchedule.findMany()
     * 
     * // Get first 10 TimeSchedules
     * const timeSchedules = await prisma.timeSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeScheduleWithIdOnly = await prisma.timeSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeScheduleFindManyArgs>(args?: SelectSubset<T, TimeScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeSchedule.
     * @param {TimeScheduleCreateArgs} args - Arguments to create a TimeSchedule.
     * @example
     * // Create one TimeSchedule
     * const TimeSchedule = await prisma.timeSchedule.create({
     *   data: {
     *     // ... data to create a TimeSchedule
     *   }
     * })
     * 
     */
    create<T extends TimeScheduleCreateArgs>(args: SelectSubset<T, TimeScheduleCreateArgs<ExtArgs>>): Prisma__TimeScheduleClient<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeSchedules.
     * @param {TimeScheduleCreateManyArgs} args - Arguments to create many TimeSchedules.
     * @example
     * // Create many TimeSchedules
     * const timeSchedule = await prisma.timeSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeScheduleCreateManyArgs>(args?: SelectSubset<T, TimeScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeSchedules and returns the data saved in the database.
     * @param {TimeScheduleCreateManyAndReturnArgs} args - Arguments to create many TimeSchedules.
     * @example
     * // Create many TimeSchedules
     * const timeSchedule = await prisma.timeSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeSchedules and only return the `id`
     * const timeScheduleWithIdOnly = await prisma.timeSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeSchedule.
     * @param {TimeScheduleDeleteArgs} args - Arguments to delete one TimeSchedule.
     * @example
     * // Delete one TimeSchedule
     * const TimeSchedule = await prisma.timeSchedule.delete({
     *   where: {
     *     // ... filter to delete one TimeSchedule
     *   }
     * })
     * 
     */
    delete<T extends TimeScheduleDeleteArgs>(args: SelectSubset<T, TimeScheduleDeleteArgs<ExtArgs>>): Prisma__TimeScheduleClient<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeSchedule.
     * @param {TimeScheduleUpdateArgs} args - Arguments to update one TimeSchedule.
     * @example
     * // Update one TimeSchedule
     * const timeSchedule = await prisma.timeSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeScheduleUpdateArgs>(args: SelectSubset<T, TimeScheduleUpdateArgs<ExtArgs>>): Prisma__TimeScheduleClient<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeSchedules.
     * @param {TimeScheduleDeleteManyArgs} args - Arguments to filter TimeSchedules to delete.
     * @example
     * // Delete a few TimeSchedules
     * const { count } = await prisma.timeSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeScheduleDeleteManyArgs>(args?: SelectSubset<T, TimeScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSchedules
     * const timeSchedule = await prisma.timeSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeScheduleUpdateManyArgs>(args: SelectSubset<T, TimeScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSchedules and returns the data updated in the database.
     * @param {TimeScheduleUpdateManyAndReturnArgs} args - Arguments to update many TimeSchedules.
     * @example
     * // Update many TimeSchedules
     * const timeSchedule = await prisma.timeSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeSchedules and only return the `id`
     * const timeScheduleWithIdOnly = await prisma.timeSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeSchedule.
     * @param {TimeScheduleUpsertArgs} args - Arguments to update or create a TimeSchedule.
     * @example
     * // Update or create a TimeSchedule
     * const timeSchedule = await prisma.timeSchedule.upsert({
     *   create: {
     *     // ... data to create a TimeSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSchedule we want to update
     *   }
     * })
     */
    upsert<T extends TimeScheduleUpsertArgs>(args: SelectSubset<T, TimeScheduleUpsertArgs<ExtArgs>>): Prisma__TimeScheduleClient<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeScheduleCountArgs} args - Arguments to filter TimeSchedules to count.
     * @example
     * // Count the number of TimeSchedules
     * const count = await prisma.timeSchedule.count({
     *   where: {
     *     // ... the filter for the TimeSchedules we want to count
     *   }
     * })
    **/
    count<T extends TimeScheduleCountArgs>(
      args?: Subset<T, TimeScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeScheduleAggregateArgs>(args: Subset<T, TimeScheduleAggregateArgs>): Prisma.PrismaPromise<GetTimeScheduleAggregateType<T>>

    /**
     * Group by TimeSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeScheduleGroupByArgs['orderBy'] }
        : { orderBy?: TimeScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeSchedule model
   */
  readonly fields: TimeScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shifts<T extends TimeSchedule$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, TimeSchedule$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeSchedule model
   */ 
  interface TimeScheduleFieldRefs {
    readonly id: FieldRef<"TimeSchedule", 'String'>
    readonly name: FieldRef<"TimeSchedule", 'String'>
    readonly startTime: FieldRef<"TimeSchedule", 'String'>
    readonly endTime: FieldRef<"TimeSchedule", 'String'>
    readonly isActive: FieldRef<"TimeSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"TimeSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimeSchedule findUnique
   */
  export type TimeScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TimeSchedule to fetch.
     */
    where: TimeScheduleWhereUniqueInput
  }

  /**
   * TimeSchedule findUniqueOrThrow
   */
  export type TimeScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TimeSchedule to fetch.
     */
    where: TimeScheduleWhereUniqueInput
  }

  /**
   * TimeSchedule findFirst
   */
  export type TimeScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TimeSchedule to fetch.
     */
    where?: TimeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSchedules to fetch.
     */
    orderBy?: TimeScheduleOrderByWithRelationInput | TimeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSchedules.
     */
    cursor?: TimeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSchedules.
     */
    distinct?: TimeScheduleScalarFieldEnum | TimeScheduleScalarFieldEnum[]
  }

  /**
   * TimeSchedule findFirstOrThrow
   */
  export type TimeScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TimeSchedule to fetch.
     */
    where?: TimeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSchedules to fetch.
     */
    orderBy?: TimeScheduleOrderByWithRelationInput | TimeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSchedules.
     */
    cursor?: TimeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSchedules.
     */
    distinct?: TimeScheduleScalarFieldEnum | TimeScheduleScalarFieldEnum[]
  }

  /**
   * TimeSchedule findMany
   */
  export type TimeScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TimeSchedules to fetch.
     */
    where?: TimeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSchedules to fetch.
     */
    orderBy?: TimeScheduleOrderByWithRelationInput | TimeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSchedules.
     */
    cursor?: TimeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSchedules.
     */
    skip?: number
    distinct?: TimeScheduleScalarFieldEnum | TimeScheduleScalarFieldEnum[]
  }

  /**
   * TimeSchedule create
   */
  export type TimeScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeSchedule.
     */
    data: XOR<TimeScheduleCreateInput, TimeScheduleUncheckedCreateInput>
  }

  /**
   * TimeSchedule createMany
   */
  export type TimeScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeSchedules.
     */
    data: TimeScheduleCreateManyInput | TimeScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeSchedule createManyAndReturn
   */
  export type TimeScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many TimeSchedules.
     */
    data: TimeScheduleCreateManyInput | TimeScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeSchedule update
   */
  export type TimeScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeSchedule.
     */
    data: XOR<TimeScheduleUpdateInput, TimeScheduleUncheckedUpdateInput>
    /**
     * Choose, which TimeSchedule to update.
     */
    where: TimeScheduleWhereUniqueInput
  }

  /**
   * TimeSchedule updateMany
   */
  export type TimeScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeSchedules.
     */
    data: XOR<TimeScheduleUpdateManyMutationInput, TimeScheduleUncheckedUpdateManyInput>
    /**
     * Filter which TimeSchedules to update
     */
    where?: TimeScheduleWhereInput
    /**
     * Limit how many TimeSchedules to update.
     */
    limit?: number
  }

  /**
   * TimeSchedule updateManyAndReturn
   */
  export type TimeScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * The data used to update TimeSchedules.
     */
    data: XOR<TimeScheduleUpdateManyMutationInput, TimeScheduleUncheckedUpdateManyInput>
    /**
     * Filter which TimeSchedules to update
     */
    where?: TimeScheduleWhereInput
    /**
     * Limit how many TimeSchedules to update.
     */
    limit?: number
  }

  /**
   * TimeSchedule upsert
   */
  export type TimeScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeSchedule to update in case it exists.
     */
    where: TimeScheduleWhereUniqueInput
    /**
     * In case the TimeSchedule found by the `where` argument doesn't exist, create a new TimeSchedule with this data.
     */
    create: XOR<TimeScheduleCreateInput, TimeScheduleUncheckedCreateInput>
    /**
     * In case the TimeSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeScheduleUpdateInput, TimeScheduleUncheckedUpdateInput>
  }

  /**
   * TimeSchedule delete
   */
  export type TimeScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeScheduleInclude<ExtArgs> | null
    /**
     * Filter which TimeSchedule to delete.
     */
    where: TimeScheduleWhereUniqueInput
  }

  /**
   * TimeSchedule deleteMany
   */
  export type TimeScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSchedules to delete
     */
    where?: TimeScheduleWhereInput
    /**
     * Limit how many TimeSchedules to delete.
     */
    limit?: number
  }

  /**
   * TimeSchedule.shifts
   */
  export type TimeSchedule$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    where?: ShiftEntryWhereInput
    orderBy?: ShiftEntryOrderByWithRelationInput | ShiftEntryOrderByWithRelationInput[]
    cursor?: ShiftEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftEntryScalarFieldEnum | ShiftEntryScalarFieldEnum[]
  }

  /**
   * TimeSchedule without action
   */
  export type TimeScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSchedule
     */
    select?: TimeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSchedule
     */
    omit?: TimeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ShiftEntry
   */

  export type AggregateShiftEntry = {
    _count: ShiftEntryCountAggregateOutputType | null
    _min: ShiftEntryMinAggregateOutputType | null
    _max: ShiftEntryMaxAggregateOutputType | null
  }

  export type ShiftEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    scheduleId: string | null
    date: Date | null
    status: $Enums.ShiftStatus | null
    isNightShift: boolean | null
    workplaceType: $Enums.WorkplaceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    scheduleId: string | null
    date: Date | null
    status: $Enums.ShiftStatus | null
    isNightShift: boolean | null
    workplaceType: $Enums.WorkplaceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftEntryCountAggregateOutputType = {
    id: number
    userId: number
    scheduleId: number
    date: number
    status: number
    isNightShift: number
    workplaceType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftEntryMinAggregateInputType = {
    id?: true
    userId?: true
    scheduleId?: true
    date?: true
    status?: true
    isNightShift?: true
    workplaceType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    scheduleId?: true
    date?: true
    status?: true
    isNightShift?: true
    workplaceType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftEntryCountAggregateInputType = {
    id?: true
    userId?: true
    scheduleId?: true
    date?: true
    status?: true
    isNightShift?: true
    workplaceType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftEntry to aggregate.
     */
    where?: ShiftEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftEntries to fetch.
     */
    orderBy?: ShiftEntryOrderByWithRelationInput | ShiftEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftEntries
    **/
    _count?: true | ShiftEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftEntryMaxAggregateInputType
  }

  export type GetShiftEntryAggregateType<T extends ShiftEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftEntry[P]>
      : GetScalarType<T[P], AggregateShiftEntry[P]>
  }




  export type ShiftEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftEntryWhereInput
    orderBy?: ShiftEntryOrderByWithAggregationInput | ShiftEntryOrderByWithAggregationInput[]
    by: ShiftEntryScalarFieldEnum[] | ShiftEntryScalarFieldEnum
    having?: ShiftEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftEntryCountAggregateInputType | true
    _min?: ShiftEntryMinAggregateInputType
    _max?: ShiftEntryMaxAggregateInputType
  }

  export type ShiftEntryGroupByOutputType = {
    id: string
    userId: string
    scheduleId: string
    date: Date
    status: $Enums.ShiftStatus
    isNightShift: boolean
    workplaceType: $Enums.WorkplaceType
    createdAt: Date
    updatedAt: Date
    _count: ShiftEntryCountAggregateOutputType | null
    _min: ShiftEntryMinAggregateOutputType | null
    _max: ShiftEntryMaxAggregateOutputType | null
  }

  type GetShiftEntryGroupByPayload<T extends ShiftEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftEntryGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftEntryGroupByOutputType[P]>
        }
      >
    >


  export type ShiftEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    date?: boolean
    status?: boolean
    isNightShift?: boolean
    workplaceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | TimeScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftEntry"]>

  export type ShiftEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    date?: boolean
    status?: boolean
    isNightShift?: boolean
    workplaceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | TimeScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftEntry"]>

  export type ShiftEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    date?: boolean
    status?: boolean
    isNightShift?: boolean
    workplaceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | TimeScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftEntry"]>

  export type ShiftEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    date?: boolean
    status?: boolean
    isNightShift?: boolean
    workplaceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "scheduleId" | "date" | "status" | "isNightShift" | "workplaceType" | "createdAt" | "updatedAt", ExtArgs["result"]["shiftEntry"]>
  export type ShiftEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | TimeScheduleDefaultArgs<ExtArgs>
  }
  export type ShiftEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | TimeScheduleDefaultArgs<ExtArgs>
  }
  export type ShiftEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedule?: boolean | TimeScheduleDefaultArgs<ExtArgs>
  }

  export type $ShiftEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      schedule: Prisma.$TimeSchedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      scheduleId: string
      date: Date
      status: $Enums.ShiftStatus
      isNightShift: boolean
      workplaceType: $Enums.WorkplaceType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shiftEntry"]>
    composites: {}
  }

  type ShiftEntryGetPayload<S extends boolean | null | undefined | ShiftEntryDefaultArgs> = $Result.GetResult<Prisma.$ShiftEntryPayload, S>

  type ShiftEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftEntryCountAggregateInputType | true
    }

  export interface ShiftEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftEntry'], meta: { name: 'ShiftEntry' } }
    /**
     * Find zero or one ShiftEntry that matches the filter.
     * @param {ShiftEntryFindUniqueArgs} args - Arguments to find a ShiftEntry
     * @example
     * // Get one ShiftEntry
     * const shiftEntry = await prisma.shiftEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftEntryFindUniqueArgs>(args: SelectSubset<T, ShiftEntryFindUniqueArgs<ExtArgs>>): Prisma__ShiftEntryClient<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShiftEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftEntryFindUniqueOrThrowArgs} args - Arguments to find a ShiftEntry
     * @example
     * // Get one ShiftEntry
     * const shiftEntry = await prisma.shiftEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftEntryClient<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftEntryFindFirstArgs} args - Arguments to find a ShiftEntry
     * @example
     * // Get one ShiftEntry
     * const shiftEntry = await prisma.shiftEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftEntryFindFirstArgs>(args?: SelectSubset<T, ShiftEntryFindFirstArgs<ExtArgs>>): Prisma__ShiftEntryClient<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftEntryFindFirstOrThrowArgs} args - Arguments to find a ShiftEntry
     * @example
     * // Get one ShiftEntry
     * const shiftEntry = await prisma.shiftEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftEntryClient<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShiftEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftEntries
     * const shiftEntries = await prisma.shiftEntry.findMany()
     * 
     * // Get first 10 ShiftEntries
     * const shiftEntries = await prisma.shiftEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftEntryWithIdOnly = await prisma.shiftEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftEntryFindManyArgs>(args?: SelectSubset<T, ShiftEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShiftEntry.
     * @param {ShiftEntryCreateArgs} args - Arguments to create a ShiftEntry.
     * @example
     * // Create one ShiftEntry
     * const ShiftEntry = await prisma.shiftEntry.create({
     *   data: {
     *     // ... data to create a ShiftEntry
     *   }
     * })
     * 
     */
    create<T extends ShiftEntryCreateArgs>(args: SelectSubset<T, ShiftEntryCreateArgs<ExtArgs>>): Prisma__ShiftEntryClient<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShiftEntries.
     * @param {ShiftEntryCreateManyArgs} args - Arguments to create many ShiftEntries.
     * @example
     * // Create many ShiftEntries
     * const shiftEntry = await prisma.shiftEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftEntryCreateManyArgs>(args?: SelectSubset<T, ShiftEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShiftEntries and returns the data saved in the database.
     * @param {ShiftEntryCreateManyAndReturnArgs} args - Arguments to create many ShiftEntries.
     * @example
     * // Create many ShiftEntries
     * const shiftEntry = await prisma.shiftEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShiftEntries and only return the `id`
     * const shiftEntryWithIdOnly = await prisma.shiftEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShiftEntry.
     * @param {ShiftEntryDeleteArgs} args - Arguments to delete one ShiftEntry.
     * @example
     * // Delete one ShiftEntry
     * const ShiftEntry = await prisma.shiftEntry.delete({
     *   where: {
     *     // ... filter to delete one ShiftEntry
     *   }
     * })
     * 
     */
    delete<T extends ShiftEntryDeleteArgs>(args: SelectSubset<T, ShiftEntryDeleteArgs<ExtArgs>>): Prisma__ShiftEntryClient<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShiftEntry.
     * @param {ShiftEntryUpdateArgs} args - Arguments to update one ShiftEntry.
     * @example
     * // Update one ShiftEntry
     * const shiftEntry = await prisma.shiftEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftEntryUpdateArgs>(args: SelectSubset<T, ShiftEntryUpdateArgs<ExtArgs>>): Prisma__ShiftEntryClient<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShiftEntries.
     * @param {ShiftEntryDeleteManyArgs} args - Arguments to filter ShiftEntries to delete.
     * @example
     * // Delete a few ShiftEntries
     * const { count } = await prisma.shiftEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftEntryDeleteManyArgs>(args?: SelectSubset<T, ShiftEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftEntries
     * const shiftEntry = await prisma.shiftEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftEntryUpdateManyArgs>(args: SelectSubset<T, ShiftEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftEntries and returns the data updated in the database.
     * @param {ShiftEntryUpdateManyAndReturnArgs} args - Arguments to update many ShiftEntries.
     * @example
     * // Update many ShiftEntries
     * const shiftEntry = await prisma.shiftEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShiftEntries and only return the `id`
     * const shiftEntryWithIdOnly = await prisma.shiftEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShiftEntry.
     * @param {ShiftEntryUpsertArgs} args - Arguments to update or create a ShiftEntry.
     * @example
     * // Update or create a ShiftEntry
     * const shiftEntry = await prisma.shiftEntry.upsert({
     *   create: {
     *     // ... data to create a ShiftEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftEntry we want to update
     *   }
     * })
     */
    upsert<T extends ShiftEntryUpsertArgs>(args: SelectSubset<T, ShiftEntryUpsertArgs<ExtArgs>>): Prisma__ShiftEntryClient<$Result.GetResult<Prisma.$ShiftEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShiftEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftEntryCountArgs} args - Arguments to filter ShiftEntries to count.
     * @example
     * // Count the number of ShiftEntries
     * const count = await prisma.shiftEntry.count({
     *   where: {
     *     // ... the filter for the ShiftEntries we want to count
     *   }
     * })
    **/
    count<T extends ShiftEntryCountArgs>(
      args?: Subset<T, ShiftEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftEntryAggregateArgs>(args: Subset<T, ShiftEntryAggregateArgs>): Prisma.PrismaPromise<GetShiftEntryAggregateType<T>>

    /**
     * Group by ShiftEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftEntryGroupByArgs['orderBy'] }
        : { orderBy?: ShiftEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftEntry model
   */
  readonly fields: ShiftEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schedule<T extends TimeScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimeScheduleDefaultArgs<ExtArgs>>): Prisma__TimeScheduleClient<$Result.GetResult<Prisma.$TimeSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftEntry model
   */ 
  interface ShiftEntryFieldRefs {
    readonly id: FieldRef<"ShiftEntry", 'String'>
    readonly userId: FieldRef<"ShiftEntry", 'String'>
    readonly scheduleId: FieldRef<"ShiftEntry", 'String'>
    readonly date: FieldRef<"ShiftEntry", 'DateTime'>
    readonly status: FieldRef<"ShiftEntry", 'ShiftStatus'>
    readonly isNightShift: FieldRef<"ShiftEntry", 'Boolean'>
    readonly workplaceType: FieldRef<"ShiftEntry", 'WorkplaceType'>
    readonly createdAt: FieldRef<"ShiftEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"ShiftEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShiftEntry findUnique
   */
  export type ShiftEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    /**
     * Filter, which ShiftEntry to fetch.
     */
    where: ShiftEntryWhereUniqueInput
  }

  /**
   * ShiftEntry findUniqueOrThrow
   */
  export type ShiftEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    /**
     * Filter, which ShiftEntry to fetch.
     */
    where: ShiftEntryWhereUniqueInput
  }

  /**
   * ShiftEntry findFirst
   */
  export type ShiftEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    /**
     * Filter, which ShiftEntry to fetch.
     */
    where?: ShiftEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftEntries to fetch.
     */
    orderBy?: ShiftEntryOrderByWithRelationInput | ShiftEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftEntries.
     */
    cursor?: ShiftEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftEntries.
     */
    distinct?: ShiftEntryScalarFieldEnum | ShiftEntryScalarFieldEnum[]
  }

  /**
   * ShiftEntry findFirstOrThrow
   */
  export type ShiftEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    /**
     * Filter, which ShiftEntry to fetch.
     */
    where?: ShiftEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftEntries to fetch.
     */
    orderBy?: ShiftEntryOrderByWithRelationInput | ShiftEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftEntries.
     */
    cursor?: ShiftEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftEntries.
     */
    distinct?: ShiftEntryScalarFieldEnum | ShiftEntryScalarFieldEnum[]
  }

  /**
   * ShiftEntry findMany
   */
  export type ShiftEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    /**
     * Filter, which ShiftEntries to fetch.
     */
    where?: ShiftEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftEntries to fetch.
     */
    orderBy?: ShiftEntryOrderByWithRelationInput | ShiftEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftEntries.
     */
    cursor?: ShiftEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftEntries.
     */
    skip?: number
    distinct?: ShiftEntryScalarFieldEnum | ShiftEntryScalarFieldEnum[]
  }

  /**
   * ShiftEntry create
   */
  export type ShiftEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftEntry.
     */
    data: XOR<ShiftEntryCreateInput, ShiftEntryUncheckedCreateInput>
  }

  /**
   * ShiftEntry createMany
   */
  export type ShiftEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftEntries.
     */
    data: ShiftEntryCreateManyInput | ShiftEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShiftEntry createManyAndReturn
   */
  export type ShiftEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * The data used to create many ShiftEntries.
     */
    data: ShiftEntryCreateManyInput | ShiftEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftEntry update
   */
  export type ShiftEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftEntry.
     */
    data: XOR<ShiftEntryUpdateInput, ShiftEntryUncheckedUpdateInput>
    /**
     * Choose, which ShiftEntry to update.
     */
    where: ShiftEntryWhereUniqueInput
  }

  /**
   * ShiftEntry updateMany
   */
  export type ShiftEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftEntries.
     */
    data: XOR<ShiftEntryUpdateManyMutationInput, ShiftEntryUncheckedUpdateManyInput>
    /**
     * Filter which ShiftEntries to update
     */
    where?: ShiftEntryWhereInput
    /**
     * Limit how many ShiftEntries to update.
     */
    limit?: number
  }

  /**
   * ShiftEntry updateManyAndReturn
   */
  export type ShiftEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * The data used to update ShiftEntries.
     */
    data: XOR<ShiftEntryUpdateManyMutationInput, ShiftEntryUncheckedUpdateManyInput>
    /**
     * Filter which ShiftEntries to update
     */
    where?: ShiftEntryWhereInput
    /**
     * Limit how many ShiftEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftEntry upsert
   */
  export type ShiftEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftEntry to update in case it exists.
     */
    where: ShiftEntryWhereUniqueInput
    /**
     * In case the ShiftEntry found by the `where` argument doesn't exist, create a new ShiftEntry with this data.
     */
    create: XOR<ShiftEntryCreateInput, ShiftEntryUncheckedCreateInput>
    /**
     * In case the ShiftEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftEntryUpdateInput, ShiftEntryUncheckedUpdateInput>
  }

  /**
   * ShiftEntry delete
   */
  export type ShiftEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
    /**
     * Filter which ShiftEntry to delete.
     */
    where: ShiftEntryWhereUniqueInput
  }

  /**
   * ShiftEntry deleteMany
   */
  export type ShiftEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftEntries to delete
     */
    where?: ShiftEntryWhereInput
    /**
     * Limit how many ShiftEntries to delete.
     */
    limit?: number
  }

  /**
   * ShiftEntry without action
   */
  export type ShiftEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftEntry
     */
    select?: ShiftEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftEntry
     */
    omit?: ShiftEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftEntryInclude<ExtArgs> | null
  }


  /**
   * Model CompanySettings
   */

  export type AggregateCompanySettings = {
    _count: CompanySettingsCountAggregateOutputType | null
    _avg: CompanySettingsAvgAggregateOutputType | null
    _sum: CompanySettingsSumAggregateOutputType | null
    _min: CompanySettingsMinAggregateOutputType | null
    _max: CompanySettingsMaxAggregateOutputType | null
  }

  export type CompanySettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanySettingsSumAggregateOutputType = {
    id: number | null
  }

  export type CompanySettingsMinAggregateOutputType = {
    id: number | null
    name: string | null
    logoUrl: string | null
    url: string | null
    address: string | null
    postalCode: string | null
    city: string | null
    region: string | null
    country: string | null
    phone: string | null
    email: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanySettingsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    logoUrl: string | null
    url: string | null
    address: string | null
    postalCode: string | null
    city: string | null
    region: string | null
    country: string | null
    phone: string | null
    email: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanySettingsCountAggregateOutputType = {
    id: number
    name: number
    logoUrl: number
    url: number
    address: number
    postalCode: number
    city: number
    region: number
    country: number
    phone: number
    email: number
    timezone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanySettingsAvgAggregateInputType = {
    id?: true
  }

  export type CompanySettingsSumAggregateInputType = {
    id?: true
  }

  export type CompanySettingsMinAggregateInputType = {
    id?: true
    name?: true
    logoUrl?: true
    url?: true
    address?: true
    postalCode?: true
    city?: true
    region?: true
    country?: true
    phone?: true
    email?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanySettingsMaxAggregateInputType = {
    id?: true
    name?: true
    logoUrl?: true
    url?: true
    address?: true
    postalCode?: true
    city?: true
    region?: true
    country?: true
    phone?: true
    email?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanySettingsCountAggregateInputType = {
    id?: true
    name?: true
    logoUrl?: true
    url?: true
    address?: true
    postalCode?: true
    city?: true
    region?: true
    country?: true
    phone?: true
    email?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanySettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanySettings to aggregate.
     */
    where?: CompanySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingsOrderByWithRelationInput | CompanySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanySettings
    **/
    _count?: true | CompanySettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanySettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanySettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanySettingsMaxAggregateInputType
  }

  export type GetCompanySettingsAggregateType<T extends CompanySettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanySettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanySettings[P]>
      : GetScalarType<T[P], AggregateCompanySettings[P]>
  }




  export type CompanySettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanySettingsWhereInput
    orderBy?: CompanySettingsOrderByWithAggregationInput | CompanySettingsOrderByWithAggregationInput[]
    by: CompanySettingsScalarFieldEnum[] | CompanySettingsScalarFieldEnum
    having?: CompanySettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanySettingsCountAggregateInputType | true
    _avg?: CompanySettingsAvgAggregateInputType
    _sum?: CompanySettingsSumAggregateInputType
    _min?: CompanySettingsMinAggregateInputType
    _max?: CompanySettingsMaxAggregateInputType
  }

  export type CompanySettingsGroupByOutputType = {
    id: number
    name: string
    logoUrl: string | null
    url: string | null
    address: string
    postalCode: string
    city: string
    region: string
    country: string
    phone: string | null
    email: string | null
    timezone: string
    createdAt: Date
    updatedAt: Date
    _count: CompanySettingsCountAggregateOutputType | null
    _avg: CompanySettingsAvgAggregateOutputType | null
    _sum: CompanySettingsSumAggregateOutputType | null
    _min: CompanySettingsMinAggregateOutputType | null
    _max: CompanySettingsMaxAggregateOutputType | null
  }

  type GetCompanySettingsGroupByPayload<T extends CompanySettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanySettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanySettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanySettingsGroupByOutputType[P]>
            : GetScalarType<T[P], CompanySettingsGroupByOutputType[P]>
        }
      >
    >


  export type CompanySettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    url?: boolean
    address?: boolean
    postalCode?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companySettings"]>

  export type CompanySettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    url?: boolean
    address?: boolean
    postalCode?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companySettings"]>

  export type CompanySettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    url?: boolean
    address?: boolean
    postalCode?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companySettings"]>

  export type CompanySettingsSelectScalar = {
    id?: boolean
    name?: boolean
    logoUrl?: boolean
    url?: boolean
    address?: boolean
    postalCode?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanySettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "logoUrl" | "url" | "address" | "postalCode" | "city" | "region" | "country" | "phone" | "email" | "timezone" | "createdAt" | "updatedAt", ExtArgs["result"]["companySettings"]>

  export type $CompanySettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanySettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      logoUrl: string | null
      url: string | null
      address: string
      postalCode: string
      city: string
      region: string
      country: string
      phone: string | null
      email: string | null
      timezone: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companySettings"]>
    composites: {}
  }

  type CompanySettingsGetPayload<S extends boolean | null | undefined | CompanySettingsDefaultArgs> = $Result.GetResult<Prisma.$CompanySettingsPayload, S>

  type CompanySettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanySettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanySettingsCountAggregateInputType | true
    }

  export interface CompanySettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanySettings'], meta: { name: 'CompanySettings' } }
    /**
     * Find zero or one CompanySettings that matches the filter.
     * @param {CompanySettingsFindUniqueArgs} args - Arguments to find a CompanySettings
     * @example
     * // Get one CompanySettings
     * const companySettings = await prisma.companySettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanySettingsFindUniqueArgs>(args: SelectSubset<T, CompanySettingsFindUniqueArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanySettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanySettingsFindUniqueOrThrowArgs} args - Arguments to find a CompanySettings
     * @example
     * // Get one CompanySettings
     * const companySettings = await prisma.companySettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanySettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanySettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsFindFirstArgs} args - Arguments to find a CompanySettings
     * @example
     * // Get one CompanySettings
     * const companySettings = await prisma.companySettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanySettingsFindFirstArgs>(args?: SelectSubset<T, CompanySettingsFindFirstArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanySettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsFindFirstOrThrowArgs} args - Arguments to find a CompanySettings
     * @example
     * // Get one CompanySettings
     * const companySettings = await prisma.companySettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanySettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanySettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanySettings
     * const companySettings = await prisma.companySettings.findMany()
     * 
     * // Get first 10 CompanySettings
     * const companySettings = await prisma.companySettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companySettingsWithIdOnly = await prisma.companySettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanySettingsFindManyArgs>(args?: SelectSubset<T, CompanySettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanySettings.
     * @param {CompanySettingsCreateArgs} args - Arguments to create a CompanySettings.
     * @example
     * // Create one CompanySettings
     * const CompanySettings = await prisma.companySettings.create({
     *   data: {
     *     // ... data to create a CompanySettings
     *   }
     * })
     * 
     */
    create<T extends CompanySettingsCreateArgs>(args: SelectSubset<T, CompanySettingsCreateArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanySettings.
     * @param {CompanySettingsCreateManyArgs} args - Arguments to create many CompanySettings.
     * @example
     * // Create many CompanySettings
     * const companySettings = await prisma.companySettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanySettingsCreateManyArgs>(args?: SelectSubset<T, CompanySettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanySettings and returns the data saved in the database.
     * @param {CompanySettingsCreateManyAndReturnArgs} args - Arguments to create many CompanySettings.
     * @example
     * // Create many CompanySettings
     * const companySettings = await prisma.companySettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanySettings and only return the `id`
     * const companySettingsWithIdOnly = await prisma.companySettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanySettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanySettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanySettings.
     * @param {CompanySettingsDeleteArgs} args - Arguments to delete one CompanySettings.
     * @example
     * // Delete one CompanySettings
     * const CompanySettings = await prisma.companySettings.delete({
     *   where: {
     *     // ... filter to delete one CompanySettings
     *   }
     * })
     * 
     */
    delete<T extends CompanySettingsDeleteArgs>(args: SelectSubset<T, CompanySettingsDeleteArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanySettings.
     * @param {CompanySettingsUpdateArgs} args - Arguments to update one CompanySettings.
     * @example
     * // Update one CompanySettings
     * const companySettings = await prisma.companySettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanySettingsUpdateArgs>(args: SelectSubset<T, CompanySettingsUpdateArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanySettings.
     * @param {CompanySettingsDeleteManyArgs} args - Arguments to filter CompanySettings to delete.
     * @example
     * // Delete a few CompanySettings
     * const { count } = await prisma.companySettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanySettingsDeleteManyArgs>(args?: SelectSubset<T, CompanySettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanySettings
     * const companySettings = await prisma.companySettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanySettingsUpdateManyArgs>(args: SelectSubset<T, CompanySettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanySettings and returns the data updated in the database.
     * @param {CompanySettingsUpdateManyAndReturnArgs} args - Arguments to update many CompanySettings.
     * @example
     * // Update many CompanySettings
     * const companySettings = await prisma.companySettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanySettings and only return the `id`
     * const companySettingsWithIdOnly = await prisma.companySettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanySettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanySettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanySettings.
     * @param {CompanySettingsUpsertArgs} args - Arguments to update or create a CompanySettings.
     * @example
     * // Update or create a CompanySettings
     * const companySettings = await prisma.companySettings.upsert({
     *   create: {
     *     // ... data to create a CompanySettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanySettings we want to update
     *   }
     * })
     */
    upsert<T extends CompanySettingsUpsertArgs>(args: SelectSubset<T, CompanySettingsUpsertArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsCountArgs} args - Arguments to filter CompanySettings to count.
     * @example
     * // Count the number of CompanySettings
     * const count = await prisma.companySettings.count({
     *   where: {
     *     // ... the filter for the CompanySettings we want to count
     *   }
     * })
    **/
    count<T extends CompanySettingsCountArgs>(
      args?: Subset<T, CompanySettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanySettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanySettingsAggregateArgs>(args: Subset<T, CompanySettingsAggregateArgs>): Prisma.PrismaPromise<GetCompanySettingsAggregateType<T>>

    /**
     * Group by CompanySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanySettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanySettingsGroupByArgs['orderBy'] }
        : { orderBy?: CompanySettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanySettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanySettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanySettings model
   */
  readonly fields: CompanySettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanySettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanySettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanySettings model
   */ 
  interface CompanySettingsFieldRefs {
    readonly id: FieldRef<"CompanySettings", 'Int'>
    readonly name: FieldRef<"CompanySettings", 'String'>
    readonly logoUrl: FieldRef<"CompanySettings", 'String'>
    readonly url: FieldRef<"CompanySettings", 'String'>
    readonly address: FieldRef<"CompanySettings", 'String'>
    readonly postalCode: FieldRef<"CompanySettings", 'String'>
    readonly city: FieldRef<"CompanySettings", 'String'>
    readonly region: FieldRef<"CompanySettings", 'String'>
    readonly country: FieldRef<"CompanySettings", 'String'>
    readonly phone: FieldRef<"CompanySettings", 'String'>
    readonly email: FieldRef<"CompanySettings", 'String'>
    readonly timezone: FieldRef<"CompanySettings", 'String'>
    readonly createdAt: FieldRef<"CompanySettings", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanySettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanySettings findUnique
   */
  export type CompanySettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where: CompanySettingsWhereUniqueInput
  }

  /**
   * CompanySettings findUniqueOrThrow
   */
  export type CompanySettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where: CompanySettingsWhereUniqueInput
  }

  /**
   * CompanySettings findFirst
   */
  export type CompanySettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where?: CompanySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingsOrderByWithRelationInput | CompanySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanySettings.
     */
    cursor?: CompanySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanySettings.
     */
    distinct?: CompanySettingsScalarFieldEnum | CompanySettingsScalarFieldEnum[]
  }

  /**
   * CompanySettings findFirstOrThrow
   */
  export type CompanySettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where?: CompanySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingsOrderByWithRelationInput | CompanySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanySettings.
     */
    cursor?: CompanySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanySettings.
     */
    distinct?: CompanySettingsScalarFieldEnum | CompanySettingsScalarFieldEnum[]
  }

  /**
   * CompanySettings findMany
   */
  export type CompanySettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where?: CompanySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingsOrderByWithRelationInput | CompanySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanySettings.
     */
    cursor?: CompanySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    distinct?: CompanySettingsScalarFieldEnum | CompanySettingsScalarFieldEnum[]
  }

  /**
   * CompanySettings create
   */
  export type CompanySettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a CompanySettings.
     */
    data: XOR<CompanySettingsCreateInput, CompanySettingsUncheckedCreateInput>
  }

  /**
   * CompanySettings createMany
   */
  export type CompanySettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanySettings.
     */
    data: CompanySettingsCreateManyInput | CompanySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanySettings createManyAndReturn
   */
  export type CompanySettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * The data used to create many CompanySettings.
     */
    data: CompanySettingsCreateManyInput | CompanySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanySettings update
   */
  export type CompanySettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a CompanySettings.
     */
    data: XOR<CompanySettingsUpdateInput, CompanySettingsUncheckedUpdateInput>
    /**
     * Choose, which CompanySettings to update.
     */
    where: CompanySettingsWhereUniqueInput
  }

  /**
   * CompanySettings updateMany
   */
  export type CompanySettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanySettings.
     */
    data: XOR<CompanySettingsUpdateManyMutationInput, CompanySettingsUncheckedUpdateManyInput>
    /**
     * Filter which CompanySettings to update
     */
    where?: CompanySettingsWhereInput
    /**
     * Limit how many CompanySettings to update.
     */
    limit?: number
  }

  /**
   * CompanySettings updateManyAndReturn
   */
  export type CompanySettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * The data used to update CompanySettings.
     */
    data: XOR<CompanySettingsUpdateManyMutationInput, CompanySettingsUncheckedUpdateManyInput>
    /**
     * Filter which CompanySettings to update
     */
    where?: CompanySettingsWhereInput
    /**
     * Limit how many CompanySettings to update.
     */
    limit?: number
  }

  /**
   * CompanySettings upsert
   */
  export type CompanySettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the CompanySettings to update in case it exists.
     */
    where: CompanySettingsWhereUniqueInput
    /**
     * In case the CompanySettings found by the `where` argument doesn't exist, create a new CompanySettings with this data.
     */
    create: XOR<CompanySettingsCreateInput, CompanySettingsUncheckedCreateInput>
    /**
     * In case the CompanySettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanySettingsUpdateInput, CompanySettingsUncheckedUpdateInput>
  }

  /**
   * CompanySettings delete
   */
  export type CompanySettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter which CompanySettings to delete.
     */
    where: CompanySettingsWhereUniqueInput
  }

  /**
   * CompanySettings deleteMany
   */
  export type CompanySettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanySettings to delete
     */
    where?: CompanySettingsWhereInput
    /**
     * Limit how many CompanySettings to delete.
     */
    limit?: number
  }

  /**
   * CompanySettings without action
   */
  export type CompanySettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
  }


  /**
   * Model CareerSettings
   */

  export type AggregateCareerSettings = {
    _count: CareerSettingsCountAggregateOutputType | null
    _avg: CareerSettingsAvgAggregateOutputType | null
    _sum: CareerSettingsSumAggregateOutputType | null
    _min: CareerSettingsMinAggregateOutputType | null
    _max: CareerSettingsMaxAggregateOutputType | null
  }

  export type CareerSettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type CareerSettingsSumAggregateOutputType = {
    id: number | null
  }

  export type CareerSettingsMinAggregateOutputType = {
    id: number | null
    logoUrl: string | null
    headerButtonText: string | null
    headerButtonUrl: string | null
    headerButtonBgColor: string | null
    headerButtonTextColor: string | null
    bannerText: string | null
    bannerBgColor: string | null
    bannerTextColor: string | null
    showCvBanner: boolean | null
    cvBannerUrl: string | null
    cvBannerTitle: string | null
    cvBannerSubtitle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CareerSettingsMaxAggregateOutputType = {
    id: number | null
    logoUrl: string | null
    headerButtonText: string | null
    headerButtonUrl: string | null
    headerButtonBgColor: string | null
    headerButtonTextColor: string | null
    bannerText: string | null
    bannerBgColor: string | null
    bannerTextColor: string | null
    showCvBanner: boolean | null
    cvBannerUrl: string | null
    cvBannerTitle: string | null
    cvBannerSubtitle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CareerSettingsCountAggregateOutputType = {
    id: number
    logoUrl: number
    headerButtonText: number
    headerButtonUrl: number
    headerButtonBgColor: number
    headerButtonTextColor: number
    bannerText: number
    bannerBgColor: number
    bannerTextColor: number
    showCvBanner: number
    cvBannerUrl: number
    cvBannerTitle: number
    cvBannerSubtitle: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CareerSettingsAvgAggregateInputType = {
    id?: true
  }

  export type CareerSettingsSumAggregateInputType = {
    id?: true
  }

  export type CareerSettingsMinAggregateInputType = {
    id?: true
    logoUrl?: true
    headerButtonText?: true
    headerButtonUrl?: true
    headerButtonBgColor?: true
    headerButtonTextColor?: true
    bannerText?: true
    bannerBgColor?: true
    bannerTextColor?: true
    showCvBanner?: true
    cvBannerUrl?: true
    cvBannerTitle?: true
    cvBannerSubtitle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CareerSettingsMaxAggregateInputType = {
    id?: true
    logoUrl?: true
    headerButtonText?: true
    headerButtonUrl?: true
    headerButtonBgColor?: true
    headerButtonTextColor?: true
    bannerText?: true
    bannerBgColor?: true
    bannerTextColor?: true
    showCvBanner?: true
    cvBannerUrl?: true
    cvBannerTitle?: true
    cvBannerSubtitle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CareerSettingsCountAggregateInputType = {
    id?: true
    logoUrl?: true
    headerButtonText?: true
    headerButtonUrl?: true
    headerButtonBgColor?: true
    headerButtonTextColor?: true
    bannerText?: true
    bannerBgColor?: true
    bannerTextColor?: true
    showCvBanner?: true
    cvBannerUrl?: true
    cvBannerTitle?: true
    cvBannerSubtitle?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CareerSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareerSettings to aggregate.
     */
    where?: CareerSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerSettings to fetch.
     */
    orderBy?: CareerSettingsOrderByWithRelationInput | CareerSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CareerSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CareerSettings
    **/
    _count?: true | CareerSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CareerSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CareerSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerSettingsMaxAggregateInputType
  }

  export type GetCareerSettingsAggregateType<T extends CareerSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateCareerSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareerSettings[P]>
      : GetScalarType<T[P], AggregateCareerSettings[P]>
  }




  export type CareerSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerSettingsWhereInput
    orderBy?: CareerSettingsOrderByWithAggregationInput | CareerSettingsOrderByWithAggregationInput[]
    by: CareerSettingsScalarFieldEnum[] | CareerSettingsScalarFieldEnum
    having?: CareerSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerSettingsCountAggregateInputType | true
    _avg?: CareerSettingsAvgAggregateInputType
    _sum?: CareerSettingsSumAggregateInputType
    _min?: CareerSettingsMinAggregateInputType
    _max?: CareerSettingsMaxAggregateInputType
  }

  export type CareerSettingsGroupByOutputType = {
    id: number
    logoUrl: string | null
    headerButtonText: string | null
    headerButtonUrl: string | null
    headerButtonBgColor: string | null
    headerButtonTextColor: string | null
    bannerText: string | null
    bannerBgColor: string | null
    bannerTextColor: string | null
    showCvBanner: boolean
    cvBannerUrl: string | null
    cvBannerTitle: string | null
    cvBannerSubtitle: string | null
    createdAt: Date
    updatedAt: Date
    _count: CareerSettingsCountAggregateOutputType | null
    _avg: CareerSettingsAvgAggregateOutputType | null
    _sum: CareerSettingsSumAggregateOutputType | null
    _min: CareerSettingsMinAggregateOutputType | null
    _max: CareerSettingsMaxAggregateOutputType | null
  }

  type GetCareerSettingsGroupByPayload<T extends CareerSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareerSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], CareerSettingsGroupByOutputType[P]>
        }
      >
    >


  export type CareerSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logoUrl?: boolean
    headerButtonText?: boolean
    headerButtonUrl?: boolean
    headerButtonBgColor?: boolean
    headerButtonTextColor?: boolean
    bannerText?: boolean
    bannerBgColor?: boolean
    bannerTextColor?: boolean
    showCvBanner?: boolean
    cvBannerUrl?: boolean
    cvBannerTitle?: boolean
    cvBannerSubtitle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["careerSettings"]>

  export type CareerSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logoUrl?: boolean
    headerButtonText?: boolean
    headerButtonUrl?: boolean
    headerButtonBgColor?: boolean
    headerButtonTextColor?: boolean
    bannerText?: boolean
    bannerBgColor?: boolean
    bannerTextColor?: boolean
    showCvBanner?: boolean
    cvBannerUrl?: boolean
    cvBannerTitle?: boolean
    cvBannerSubtitle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["careerSettings"]>

  export type CareerSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logoUrl?: boolean
    headerButtonText?: boolean
    headerButtonUrl?: boolean
    headerButtonBgColor?: boolean
    headerButtonTextColor?: boolean
    bannerText?: boolean
    bannerBgColor?: boolean
    bannerTextColor?: boolean
    showCvBanner?: boolean
    cvBannerUrl?: boolean
    cvBannerTitle?: boolean
    cvBannerSubtitle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["careerSettings"]>

  export type CareerSettingsSelectScalar = {
    id?: boolean
    logoUrl?: boolean
    headerButtonText?: boolean
    headerButtonUrl?: boolean
    headerButtonBgColor?: boolean
    headerButtonTextColor?: boolean
    bannerText?: boolean
    bannerBgColor?: boolean
    bannerTextColor?: boolean
    showCvBanner?: boolean
    cvBannerUrl?: boolean
    cvBannerTitle?: boolean
    cvBannerSubtitle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CareerSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logoUrl" | "headerButtonText" | "headerButtonUrl" | "headerButtonBgColor" | "headerButtonTextColor" | "bannerText" | "bannerBgColor" | "bannerTextColor" | "showCvBanner" | "cvBannerUrl" | "cvBannerTitle" | "cvBannerSubtitle" | "createdAt" | "updatedAt", ExtArgs["result"]["careerSettings"]>

  export type $CareerSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CareerSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logoUrl: string | null
      headerButtonText: string | null
      headerButtonUrl: string | null
      headerButtonBgColor: string | null
      headerButtonTextColor: string | null
      bannerText: string | null
      bannerBgColor: string | null
      bannerTextColor: string | null
      showCvBanner: boolean
      cvBannerUrl: string | null
      cvBannerTitle: string | null
      cvBannerSubtitle: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["careerSettings"]>
    composites: {}
  }

  type CareerSettingsGetPayload<S extends boolean | null | undefined | CareerSettingsDefaultArgs> = $Result.GetResult<Prisma.$CareerSettingsPayload, S>

  type CareerSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CareerSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CareerSettingsCountAggregateInputType | true
    }

  export interface CareerSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CareerSettings'], meta: { name: 'CareerSettings' } }
    /**
     * Find zero or one CareerSettings that matches the filter.
     * @param {CareerSettingsFindUniqueArgs} args - Arguments to find a CareerSettings
     * @example
     * // Get one CareerSettings
     * const careerSettings = await prisma.careerSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CareerSettingsFindUniqueArgs>(args: SelectSubset<T, CareerSettingsFindUniqueArgs<ExtArgs>>): Prisma__CareerSettingsClient<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CareerSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CareerSettingsFindUniqueOrThrowArgs} args - Arguments to find a CareerSettings
     * @example
     * // Get one CareerSettings
     * const careerSettings = await prisma.careerSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CareerSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, CareerSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CareerSettingsClient<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CareerSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerSettingsFindFirstArgs} args - Arguments to find a CareerSettings
     * @example
     * // Get one CareerSettings
     * const careerSettings = await prisma.careerSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CareerSettingsFindFirstArgs>(args?: SelectSubset<T, CareerSettingsFindFirstArgs<ExtArgs>>): Prisma__CareerSettingsClient<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CareerSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerSettingsFindFirstOrThrowArgs} args - Arguments to find a CareerSettings
     * @example
     * // Get one CareerSettings
     * const careerSettings = await prisma.careerSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CareerSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, CareerSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CareerSettingsClient<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CareerSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CareerSettings
     * const careerSettings = await prisma.careerSettings.findMany()
     * 
     * // Get first 10 CareerSettings
     * const careerSettings = await prisma.careerSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careerSettingsWithIdOnly = await prisma.careerSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CareerSettingsFindManyArgs>(args?: SelectSubset<T, CareerSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CareerSettings.
     * @param {CareerSettingsCreateArgs} args - Arguments to create a CareerSettings.
     * @example
     * // Create one CareerSettings
     * const CareerSettings = await prisma.careerSettings.create({
     *   data: {
     *     // ... data to create a CareerSettings
     *   }
     * })
     * 
     */
    create<T extends CareerSettingsCreateArgs>(args: SelectSubset<T, CareerSettingsCreateArgs<ExtArgs>>): Prisma__CareerSettingsClient<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CareerSettings.
     * @param {CareerSettingsCreateManyArgs} args - Arguments to create many CareerSettings.
     * @example
     * // Create many CareerSettings
     * const careerSettings = await prisma.careerSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CareerSettingsCreateManyArgs>(args?: SelectSubset<T, CareerSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CareerSettings and returns the data saved in the database.
     * @param {CareerSettingsCreateManyAndReturnArgs} args - Arguments to create many CareerSettings.
     * @example
     * // Create many CareerSettings
     * const careerSettings = await prisma.careerSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CareerSettings and only return the `id`
     * const careerSettingsWithIdOnly = await prisma.careerSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CareerSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, CareerSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CareerSettings.
     * @param {CareerSettingsDeleteArgs} args - Arguments to delete one CareerSettings.
     * @example
     * // Delete one CareerSettings
     * const CareerSettings = await prisma.careerSettings.delete({
     *   where: {
     *     // ... filter to delete one CareerSettings
     *   }
     * })
     * 
     */
    delete<T extends CareerSettingsDeleteArgs>(args: SelectSubset<T, CareerSettingsDeleteArgs<ExtArgs>>): Prisma__CareerSettingsClient<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CareerSettings.
     * @param {CareerSettingsUpdateArgs} args - Arguments to update one CareerSettings.
     * @example
     * // Update one CareerSettings
     * const careerSettings = await prisma.careerSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CareerSettingsUpdateArgs>(args: SelectSubset<T, CareerSettingsUpdateArgs<ExtArgs>>): Prisma__CareerSettingsClient<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CareerSettings.
     * @param {CareerSettingsDeleteManyArgs} args - Arguments to filter CareerSettings to delete.
     * @example
     * // Delete a few CareerSettings
     * const { count } = await prisma.careerSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CareerSettingsDeleteManyArgs>(args?: SelectSubset<T, CareerSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CareerSettings
     * const careerSettings = await prisma.careerSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CareerSettingsUpdateManyArgs>(args: SelectSubset<T, CareerSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerSettings and returns the data updated in the database.
     * @param {CareerSettingsUpdateManyAndReturnArgs} args - Arguments to update many CareerSettings.
     * @example
     * // Update many CareerSettings
     * const careerSettings = await prisma.careerSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CareerSettings and only return the `id`
     * const careerSettingsWithIdOnly = await prisma.careerSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CareerSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, CareerSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CareerSettings.
     * @param {CareerSettingsUpsertArgs} args - Arguments to update or create a CareerSettings.
     * @example
     * // Update or create a CareerSettings
     * const careerSettings = await prisma.careerSettings.upsert({
     *   create: {
     *     // ... data to create a CareerSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CareerSettings we want to update
     *   }
     * })
     */
    upsert<T extends CareerSettingsUpsertArgs>(args: SelectSubset<T, CareerSettingsUpsertArgs<ExtArgs>>): Prisma__CareerSettingsClient<$Result.GetResult<Prisma.$CareerSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CareerSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerSettingsCountArgs} args - Arguments to filter CareerSettings to count.
     * @example
     * // Count the number of CareerSettings
     * const count = await prisma.careerSettings.count({
     *   where: {
     *     // ... the filter for the CareerSettings we want to count
     *   }
     * })
    **/
    count<T extends CareerSettingsCountArgs>(
      args?: Subset<T, CareerSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CareerSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerSettingsAggregateArgs>(args: Subset<T, CareerSettingsAggregateArgs>): Prisma.PrismaPromise<GetCareerSettingsAggregateType<T>>

    /**
     * Group by CareerSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareerSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareerSettingsGroupByArgs['orderBy'] }
        : { orderBy?: CareerSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareerSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CareerSettings model
   */
  readonly fields: CareerSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CareerSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CareerSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CareerSettings model
   */ 
  interface CareerSettingsFieldRefs {
    readonly id: FieldRef<"CareerSettings", 'Int'>
    readonly logoUrl: FieldRef<"CareerSettings", 'String'>
    readonly headerButtonText: FieldRef<"CareerSettings", 'String'>
    readonly headerButtonUrl: FieldRef<"CareerSettings", 'String'>
    readonly headerButtonBgColor: FieldRef<"CareerSettings", 'String'>
    readonly headerButtonTextColor: FieldRef<"CareerSettings", 'String'>
    readonly bannerText: FieldRef<"CareerSettings", 'String'>
    readonly bannerBgColor: FieldRef<"CareerSettings", 'String'>
    readonly bannerTextColor: FieldRef<"CareerSettings", 'String'>
    readonly showCvBanner: FieldRef<"CareerSettings", 'Boolean'>
    readonly cvBannerUrl: FieldRef<"CareerSettings", 'String'>
    readonly cvBannerTitle: FieldRef<"CareerSettings", 'String'>
    readonly cvBannerSubtitle: FieldRef<"CareerSettings", 'String'>
    readonly createdAt: FieldRef<"CareerSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"CareerSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CareerSettings findUnique
   */
  export type CareerSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * Filter, which CareerSettings to fetch.
     */
    where: CareerSettingsWhereUniqueInput
  }

  /**
   * CareerSettings findUniqueOrThrow
   */
  export type CareerSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * Filter, which CareerSettings to fetch.
     */
    where: CareerSettingsWhereUniqueInput
  }

  /**
   * CareerSettings findFirst
   */
  export type CareerSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * Filter, which CareerSettings to fetch.
     */
    where?: CareerSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerSettings to fetch.
     */
    orderBy?: CareerSettingsOrderByWithRelationInput | CareerSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareerSettings.
     */
    cursor?: CareerSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareerSettings.
     */
    distinct?: CareerSettingsScalarFieldEnum | CareerSettingsScalarFieldEnum[]
  }

  /**
   * CareerSettings findFirstOrThrow
   */
  export type CareerSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * Filter, which CareerSettings to fetch.
     */
    where?: CareerSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerSettings to fetch.
     */
    orderBy?: CareerSettingsOrderByWithRelationInput | CareerSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareerSettings.
     */
    cursor?: CareerSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareerSettings.
     */
    distinct?: CareerSettingsScalarFieldEnum | CareerSettingsScalarFieldEnum[]
  }

  /**
   * CareerSettings findMany
   */
  export type CareerSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * Filter, which CareerSettings to fetch.
     */
    where?: CareerSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerSettings to fetch.
     */
    orderBy?: CareerSettingsOrderByWithRelationInput | CareerSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CareerSettings.
     */
    cursor?: CareerSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerSettings.
     */
    skip?: number
    distinct?: CareerSettingsScalarFieldEnum | CareerSettingsScalarFieldEnum[]
  }

  /**
   * CareerSettings create
   */
  export type CareerSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a CareerSettings.
     */
    data: XOR<CareerSettingsCreateInput, CareerSettingsUncheckedCreateInput>
  }

  /**
   * CareerSettings createMany
   */
  export type CareerSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CareerSettings.
     */
    data: CareerSettingsCreateManyInput | CareerSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CareerSettings createManyAndReturn
   */
  export type CareerSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many CareerSettings.
     */
    data: CareerSettingsCreateManyInput | CareerSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CareerSettings update
   */
  export type CareerSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a CareerSettings.
     */
    data: XOR<CareerSettingsUpdateInput, CareerSettingsUncheckedUpdateInput>
    /**
     * Choose, which CareerSettings to update.
     */
    where: CareerSettingsWhereUniqueInput
  }

  /**
   * CareerSettings updateMany
   */
  export type CareerSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CareerSettings.
     */
    data: XOR<CareerSettingsUpdateManyMutationInput, CareerSettingsUncheckedUpdateManyInput>
    /**
     * Filter which CareerSettings to update
     */
    where?: CareerSettingsWhereInput
    /**
     * Limit how many CareerSettings to update.
     */
    limit?: number
  }

  /**
   * CareerSettings updateManyAndReturn
   */
  export type CareerSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * The data used to update CareerSettings.
     */
    data: XOR<CareerSettingsUpdateManyMutationInput, CareerSettingsUncheckedUpdateManyInput>
    /**
     * Filter which CareerSettings to update
     */
    where?: CareerSettingsWhereInput
    /**
     * Limit how many CareerSettings to update.
     */
    limit?: number
  }

  /**
   * CareerSettings upsert
   */
  export type CareerSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the CareerSettings to update in case it exists.
     */
    where: CareerSettingsWhereUniqueInput
    /**
     * In case the CareerSettings found by the `where` argument doesn't exist, create a new CareerSettings with this data.
     */
    create: XOR<CareerSettingsCreateInput, CareerSettingsUncheckedCreateInput>
    /**
     * In case the CareerSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CareerSettingsUpdateInput, CareerSettingsUncheckedUpdateInput>
  }

  /**
   * CareerSettings delete
   */
  export type CareerSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
    /**
     * Filter which CareerSettings to delete.
     */
    where: CareerSettingsWhereUniqueInput
  }

  /**
   * CareerSettings deleteMany
   */
  export type CareerSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareerSettings to delete
     */
    where?: CareerSettingsWhereInput
    /**
     * Limit how many CareerSettings to delete.
     */
    limit?: number
  }

  /**
   * CareerSettings without action
   */
  export type CareerSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerSettings
     */
    select?: CareerSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerSettings
     */
    omit?: CareerSettingsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    password: 'password',
    status: 'status',
    role: 'role',
    employmentType: 'employmentType',
    jobStartDate: 'jobStartDate',
    jobEndDate: 'jobEndDate',
    departmentId: 'departmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    managerId: 'managerId',
    positionId: 'positionId',
    locationId: 'locationId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserStatusHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    comment: 'comment',
    createdAt: 'createdAt',
    changedById: 'changedById'
  };

  export type UserStatusHistoryScalarFieldEnum = (typeof UserStatusHistoryScalarFieldEnum)[keyof typeof UserStatusHistoryScalarFieldEnum]


  export const CandidateNoteScalarFieldEnum: {
    id: 'id',
    candidateId: 'candidateId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type CandidateNoteScalarFieldEnum = (typeof CandidateNoteScalarFieldEnum)[keyof typeof CandidateNoteScalarFieldEnum]


  export const JobListingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    employmentType: 'employmentType',
    workplaceType: 'workplaceType',
    referralSource: 'referralSource',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    departmentId: 'departmentId',
    locationId: 'locationId',
    keywords: 'keywords',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    positionId: 'positionId'
  };

  export type JobListingScalarFieldEnum = (typeof JobListingScalarFieldEnum)[keyof typeof JobListingScalarFieldEnum]


  export const CandidateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    surname: 'surname',
    email: 'email',
    phone: 'phone',
    linkedin: 'linkedin',
    github: 'github',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CandidateScalarFieldEnum = (typeof CandidateScalarFieldEnum)[keyof typeof CandidateScalarFieldEnum]


  export const JobApplicationScalarFieldEnum: {
    id: 'id',
    candidateId: 'candidateId',
    resumeKey: 'resumeKey',
    additionalNotes: 'additionalNotes',
    referralSource: 'referralSource',
    status: 'status',
    jobListingId: 'jobListingId',
    createdAt: 'createdAt'
  };

  export type JobApplicationScalarFieldEnum = (typeof JobApplicationScalarFieldEnum)[keyof typeof JobApplicationScalarFieldEnum]


  export const CvAnalysisScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    totalScore: 'totalScore',
    technicalScore: 'technicalScore',
    experienceScore: 'experienceScore',
    educationScore: 'educationScore',
    cvQualityScore: 'cvQualityScore',
    softSkillsScore: 'softSkillsScore',
    analysis: 'analysis',
    parsedContent: 'parsedContent',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CvAnalysisScalarFieldEnum = (typeof CvAnalysisScalarFieldEnum)[keyof typeof CvAnalysisScalarFieldEnum]


  export const JobApplicationHistoryScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    status: 'status',
    comment: 'comment',
    createdAt: 'createdAt',
    changedByUserId: 'changedByUserId'
  };

  export type JobApplicationHistoryScalarFieldEnum = (typeof JobApplicationHistoryScalarFieldEnum)[keyof typeof JobApplicationHistoryScalarFieldEnum]


  export const PersonalInfoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amka: 'amka',
    afm: 'afm',
    doy: 'doy',
    middleName: 'middleName',
    birthDate: 'birthDate',
    birthPlace: 'birthPlace',
    maritalStatus: 'maritalStatus',
    numberOfChildren: 'numberOfChildren',
    citizenship: 'citizenship',
    nationality: 'nationality',
    gender: 'gender',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    educationLevel: 'educationLevel',
    educationTitle: 'educationTitle',
    educationInstitution: 'educationInstitution',
    graduationYear: 'graduationYear'
  };

  export type PersonalInfoScalarFieldEnum = (typeof PersonalInfoScalarFieldEnum)[keyof typeof PersonalInfoScalarFieldEnum]


  export const IdentificationDocumentScalarFieldEnum: {
    id: 'id',
    personalInfoId: 'personalInfoId',
    type: 'type',
    documentNumber: 'documentNumber',
    issueDate: 'issueDate',
    expiryDate: 'expiryDate',
    issuingAuthority: 'issuingAuthority',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IdentificationDocumentScalarFieldEnum = (typeof IdentificationDocumentScalarFieldEnum)[keyof typeof IdentificationDocumentScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    personalInfoId: 'personalInfoId',
    type: 'type',
    street: 'street',
    streetNumber: 'streetNumber',
    city: 'city',
    region: 'region',
    postalCode: 'postalCode',
    country: 'country',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    key: 'key',
    uploadedAt: 'uploadedAt',
    dependentMemberId: 'dependentMemberId',
    languageSkillId: 'languageSkillId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentVerificationScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    status: 'status',
    reviewedById: 'reviewedById',
    comments: 'comments',
    reviewedAt: 'reviewedAt',
    userId: 'userId'
  };

  export type DocumentVerificationScalarFieldEnum = (typeof DocumentVerificationScalarFieldEnum)[keyof typeof DocumentVerificationScalarFieldEnum]


  export const OnboardingProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    applicationId: 'applicationId',
    currentPhase: 'currentPhase',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    status: 'status',
    hireDate: 'hireDate',
    hiringManagerId: 'hiringManagerId'
  };

  export type OnboardingProgressScalarFieldEnum = (typeof OnboardingProgressScalarFieldEnum)[keyof typeof OnboardingProgressScalarFieldEnum]


  export const OnboardingInvitationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    otp: 'otp',
    otpExpiresAt: 'otpExpiresAt',
    applicationId: 'applicationId',
    expiresAt: 'expiresAt',
    verifiedAt: 'verifiedAt',
    lastAccessedAt: 'lastAccessedAt',
    sessionToken: 'sessionToken',
    sessionExpiresAt: 'sessionExpiresAt',
    createdAt: 'createdAt'
  };

  export type OnboardingInvitationScalarFieldEnum = (typeof OnboardingInvitationScalarFieldEnum)[keyof typeof OnboardingInvitationScalarFieldEnum]


  export const EmergencyContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    relationship: 'relationship',
    primaryPhone: 'primaryPhone',
    secondaryPhone: 'secondaryPhone',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmergencyContactScalarFieldEnum = (typeof EmergencyContactScalarFieldEnum)[keyof typeof EmergencyContactScalarFieldEnum]


  export const DependentMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    middleName: 'middleName',
    birthDate: 'birthDate',
    relationship: 'relationship',
    isStudent: 'isStudent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DependentMemberScalarFieldEnum = (typeof DependentMemberScalarFieldEnum)[keyof typeof DependentMemberScalarFieldEnum]


  export const UserEmailScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    type: 'type',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserEmailScalarFieldEnum = (typeof UserEmailScalarFieldEnum)[keyof typeof UserEmailScalarFieldEnum]


  export const UserPhoneScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    phoneNumber: 'phoneNumber',
    countryCode: 'countryCode',
    type: 'type',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPhoneScalarFieldEnum = (typeof UserPhoneScalarFieldEnum)[keyof typeof UserPhoneScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    personalInfoId: 'personalInfoId',
    bank: 'bank',
    iban: 'iban',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    onboardingId: 'onboardingId',
    draftKey: 'draftKey',
    signedKey: 'signedKey',
    uploadedAt: 'uploadedAt',
    signedAt: 'signedAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const LanguageSkillScalarFieldEnum: {
    id: 'id',
    personalInfoId: 'personalInfoId',
    language: 'language',
    proficiency: 'proficiency',
    certificate: 'certificate',
    issueDate: 'issueDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LanguageSkillScalarFieldEnum = (typeof LanguageSkillScalarFieldEnum)[keyof typeof LanguageSkillScalarFieldEnum]


  export const RequestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    requesterId: 'requesterId',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequestScalarFieldEnum = (typeof RequestScalarFieldEnum)[keyof typeof RequestScalarFieldEnum]


  export const RequestStatusHistoryScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    status: 'status',
    comment: 'comment',
    changedBy: 'changedBy',
    createdAt: 'createdAt'
  };

  export type RequestStatusHistoryScalarFieldEnum = (typeof RequestStatusHistoryScalarFieldEnum)[keyof typeof RequestStatusHistoryScalarFieldEnum]


  export const StatusAttachmentScalarFieldEnum: {
    id: 'id',
    historyId: 'historyId',
    fileName: 'fileName',
    fileKey: 'fileKey',
    fileType: 'fileType',
    uploadedAt: 'uploadedAt'
  };

  export type StatusAttachmentScalarFieldEnum = (typeof StatusAttachmentScalarFieldEnum)[keyof typeof StatusAttachmentScalarFieldEnum]


  export const RequestAttachmentScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    fileName: 'fileName',
    fileKey: 'fileKey',
    fileType: 'fileType',
    uploadedAt: 'uploadedAt'
  };

  export type RequestAttachmentScalarFieldEnum = (typeof RequestAttachmentScalarFieldEnum)[keyof typeof RequestAttachmentScalarFieldEnum]


  export const LeaveRequestScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    managerId: 'managerId',
    type: 'type',
    startDate: 'startDate',
    endDate: 'endDate',
    duration: 'duration',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


  export const LeaveAttachmentScalarFieldEnum: {
    id: 'id',
    leaveId: 'leaveId',
    fileName: 'fileName',
    fileKey: 'fileKey',
    fileType: 'fileType',
    uploadedAt: 'uploadedAt'
  };

  export type LeaveAttachmentScalarFieldEnum = (typeof LeaveAttachmentScalarFieldEnum)[keyof typeof LeaveAttachmentScalarFieldEnum]


  export const LeaveStatusHistoryScalarFieldEnum: {
    id: 'id',
    leaveId: 'leaveId',
    status: 'status',
    comment: 'comment',
    changedById: 'changedById',
    createdAt: 'createdAt'
  };

  export type LeaveStatusHistoryScalarFieldEnum = (typeof LeaveStatusHistoryScalarFieldEnum)[keyof typeof LeaveStatusHistoryScalarFieldEnum]


  export const LeaveStatusAttachmentScalarFieldEnum: {
    id: 'id',
    historyId: 'historyId',
    fileName: 'fileName',
    fileKey: 'fileKey',
    fileType: 'fileType',
    uploadedAt: 'uploadedAt'
  };

  export type LeaveStatusAttachmentScalarFieldEnum = (typeof LeaveStatusAttachmentScalarFieldEnum)[keyof typeof LeaveStatusAttachmentScalarFieldEnum]


  export const HolidayScalarFieldEnum: {
    id: 'id',
    name: 'name',
    date: 'date',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HolidayScalarFieldEnum = (typeof HolidayScalarFieldEnum)[keyof typeof HolidayScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    region: 'region',
    postalCode: 'postalCode',
    country: 'country',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    code: 'code',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    vatNumber: 'vatNumber',
    email: 'email',
    phone: 'phone',
    address: 'address',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    clientId: 'clientId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const TimeEntryScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimeEntryScalarFieldEnum = (typeof TimeEntryScalarFieldEnum)[keyof typeof TimeEntryScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    changedBy: 'changedBy',
    publishedBy: 'publishedBy'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const TimeScheduleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimeScheduleScalarFieldEnum = (typeof TimeScheduleScalarFieldEnum)[keyof typeof TimeScheduleScalarFieldEnum]


  export const ShiftEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    scheduleId: 'scheduleId',
    date: 'date',
    status: 'status',
    isNightShift: 'isNightShift',
    workplaceType: 'workplaceType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftEntryScalarFieldEnum = (typeof ShiftEntryScalarFieldEnum)[keyof typeof ShiftEntryScalarFieldEnum]


  export const CompanySettingsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logoUrl: 'logoUrl',
    url: 'url',
    address: 'address',
    postalCode: 'postalCode',
    city: 'city',
    region: 'region',
    country: 'country',
    phone: 'phone',
    email: 'email',
    timezone: 'timezone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanySettingsScalarFieldEnum = (typeof CompanySettingsScalarFieldEnum)[keyof typeof CompanySettingsScalarFieldEnum]


  export const CareerSettingsScalarFieldEnum: {
    id: 'id',
    logoUrl: 'logoUrl',
    headerButtonText: 'headerButtonText',
    headerButtonUrl: 'headerButtonUrl',
    headerButtonBgColor: 'headerButtonBgColor',
    headerButtonTextColor: 'headerButtonTextColor',
    bannerText: 'bannerText',
    bannerBgColor: 'bannerBgColor',
    bannerTextColor: 'bannerTextColor',
    showCvBanner: 'showCvBanner',
    cvBannerUrl: 'cvBannerUrl',
    cvBannerTitle: 'cvBannerTitle',
    cvBannerSubtitle: 'cvBannerSubtitle',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CareerSettingsScalarFieldEnum = (typeof CareerSettingsScalarFieldEnum)[keyof typeof CareerSettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'EmploymentType'
   */
  export type EnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType'>
    


  /**
   * Reference to a field of type 'EmploymentType[]'
   */
  export type ListEnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType[]'>
    


  /**
   * Reference to a field of type 'WorkplaceType'
   */
  export type EnumWorkplaceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkplaceType'>
    


  /**
   * Reference to a field of type 'WorkplaceType[]'
   */
  export type ListEnumWorkplaceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkplaceType[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'MaritalStatus'
   */
  export type EnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus'>
    


  /**
   * Reference to a field of type 'MaritalStatus[]'
   */
  export type ListEnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'EducationLevel'
   */
  export type EnumEducationLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EducationLevel'>
    


  /**
   * Reference to a field of type 'EducationLevel[]'
   */
  export type ListEnumEducationLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EducationLevel[]'>
    


  /**
   * Reference to a field of type 'IdentificationDocumentType'
   */
  export type EnumIdentificationDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentificationDocumentType'>
    


  /**
   * Reference to a field of type 'IdentificationDocumentType[]'
   */
  export type ListEnumIdentificationDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentificationDocumentType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AddressType'
   */
  export type EnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType'>
    


  /**
   * Reference to a field of type 'AddressType[]'
   */
  export type ListEnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus[]'
   */
  export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    


  /**
   * Reference to a field of type 'Phase'
   */
  export type EnumPhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Phase'>
    


  /**
   * Reference to a field of type 'Phase[]'
   */
  export type ListEnumPhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Phase[]'>
    


  /**
   * Reference to a field of type 'OnboardingStatus'
   */
  export type EnumOnboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingStatus'>
    


  /**
   * Reference to a field of type 'OnboardingStatus[]'
   */
  export type ListEnumOnboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingStatus[]'>
    


  /**
   * Reference to a field of type 'EmailType'
   */
  export type EnumEmailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailType'>
    


  /**
   * Reference to a field of type 'EmailType[]'
   */
  export type ListEnumEmailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailType[]'>
    


  /**
   * Reference to a field of type 'PhoneType'
   */
  export type EnumPhoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhoneType'>
    


  /**
   * Reference to a field of type 'PhoneType[]'
   */
  export type ListEnumPhoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhoneType[]'>
    


  /**
   * Reference to a field of type 'GreekBank'
   */
  export type EnumGreekBankFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GreekBank'>
    


  /**
   * Reference to a field of type 'GreekBank[]'
   */
  export type ListEnumGreekBankFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GreekBank[]'>
    


  /**
   * Reference to a field of type 'ContractStatus'
   */
  export type EnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus'>
    


  /**
   * Reference to a field of type 'ContractStatus[]'
   */
  export type ListEnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus[]'>
    


  /**
   * Reference to a field of type 'Language'
   */
  export type EnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language'>
    


  /**
   * Reference to a field of type 'Language[]'
   */
  export type ListEnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language[]'>
    


  /**
   * Reference to a field of type 'Proficiency'
   */
  export type EnumProficiencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Proficiency'>
    


  /**
   * Reference to a field of type 'Proficiency[]'
   */
  export type ListEnumProficiencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Proficiency[]'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus[]'
   */
  export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    


  /**
   * Reference to a field of type 'LeaveType'
   */
  export type EnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType'>
    


  /**
   * Reference to a field of type 'LeaveType[]'
   */
  export type ListEnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType[]'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'LeaveStatus[]'
   */
  export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


  /**
   * Reference to a field of type 'ClientStatus'
   */
  export type EnumClientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientStatus'>
    


  /**
   * Reference to a field of type 'ClientStatus[]'
   */
  export type ListEnumClientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientStatus[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'ProjectMemberRole'
   */
  export type EnumProjectMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectMemberRole'>
    


  /**
   * Reference to a field of type 'ProjectMemberRole[]'
   */
  export type ListEnumProjectMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectMemberRole[]'>
    


  /**
   * Reference to a field of type 'TimeEntryStatus'
   */
  export type EnumTimeEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeEntryStatus'>
    


  /**
   * Reference to a field of type 'TimeEntryStatus[]'
   */
  export type ListEnumTimeEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeEntryStatus[]'>
    


  /**
   * Reference to a field of type 'ShiftStatus'
   */
  export type EnumShiftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShiftStatus'>
    


  /**
   * Reference to a field of type 'ShiftStatus[]'
   */
  export type ListEnumShiftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShiftStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFilter<"User"> | $Enums.EmploymentType
    jobStartDate?: DateTimeNullableFilter<"User"> | Date | string | null
    jobEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    managerId?: StringNullableFilter<"User"> | string | null
    positionId?: StringNullableFilter<"User"> | string | null
    locationId?: StringNullableFilter<"User"> | string | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    candidateNotes?: CandidateNoteListRelationFilter
    jobApplicationHistory?: JobApplicationHistoryListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    statusHistory?: UserStatusHistoryListRelationFilter
    statusChangesBy?: UserStatusHistoryListRelationFilter
    personalInfo?: XOR<PersonalInfoNullableScalarRelationFilter, PersonalInfoWhereInput> | null
    documents?: DocumentListRelationFilter
    documentReviews?: DocumentVerificationListRelationFilter
    DocumentVerification?: DocumentVerificationListRelationFilter
    OnboardingProgress?: XOR<OnboardingProgressNullableScalarRelationFilter, OnboardingProgressWhereInput> | null
    emergencyContacts?: EmergencyContactListRelationFilter
    dependentMembers?: DependentMemberListRelationFilter
    emails?: UserEmailListRelationFilter
    phones?: UserPhoneListRelationFilter
    managedOnboardings?: OnboardingProgressListRelationFilter
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    employees?: UserListRelationFilter
    requestsMade?: RequestListRelationFilter
    requestsToManage?: RequestListRelationFilter
    requestHistory?: RequestStatusHistoryListRelationFilter
    leavesRequested?: LeaveRequestListRelationFilter
    leavesToApprove?: LeaveRequestListRelationFilter
    leaveStatusHistory?: LeaveStatusHistoryListRelationFilter
    managedProjects?: ProjectListRelationFilter
    projectMemberships?: ProjectMemberListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
    shifts?: ShiftEntryListRelationFilter
    announcementsChanged?: AnnouncementListRelationFilter
    announcementsPublished?: AnnouncementListRelationFilter
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    status?: SortOrder
    role?: SortOrder
    employmentType?: SortOrder
    jobStartDate?: SortOrderInput | SortOrder
    jobEndDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    department?: DepartmentOrderByWithRelationInput
    candidateNotes?: CandidateNoteOrderByRelationAggregateInput
    jobApplicationHistory?: JobApplicationHistoryOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    statusHistory?: UserStatusHistoryOrderByRelationAggregateInput
    statusChangesBy?: UserStatusHistoryOrderByRelationAggregateInput
    personalInfo?: PersonalInfoOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    documentReviews?: DocumentVerificationOrderByRelationAggregateInput
    DocumentVerification?: DocumentVerificationOrderByRelationAggregateInput
    OnboardingProgress?: OnboardingProgressOrderByWithRelationInput
    emergencyContacts?: EmergencyContactOrderByRelationAggregateInput
    dependentMembers?: DependentMemberOrderByRelationAggregateInput
    emails?: UserEmailOrderByRelationAggregateInput
    phones?: UserPhoneOrderByRelationAggregateInput
    managedOnboardings?: OnboardingProgressOrderByRelationAggregateInput
    manager?: UserOrderByWithRelationInput
    employees?: UserOrderByRelationAggregateInput
    requestsMade?: RequestOrderByRelationAggregateInput
    requestsToManage?: RequestOrderByRelationAggregateInput
    requestHistory?: RequestStatusHistoryOrderByRelationAggregateInput
    leavesRequested?: LeaveRequestOrderByRelationAggregateInput
    leavesToApprove?: LeaveRequestOrderByRelationAggregateInput
    leaveStatusHistory?: LeaveStatusHistoryOrderByRelationAggregateInput
    managedProjects?: ProjectOrderByRelationAggregateInput
    projectMemberships?: ProjectMemberOrderByRelationAggregateInput
    timeEntries?: TimeEntryOrderByRelationAggregateInput
    shifts?: ShiftEntryOrderByRelationAggregateInput
    announcementsChanged?: AnnouncementOrderByRelationAggregateInput
    announcementsPublished?: AnnouncementOrderByRelationAggregateInput
    position?: PositionOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFilter<"User"> | $Enums.EmploymentType
    jobStartDate?: DateTimeNullableFilter<"User"> | Date | string | null
    jobEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    managerId?: StringNullableFilter<"User"> | string | null
    positionId?: StringNullableFilter<"User"> | string | null
    locationId?: StringNullableFilter<"User"> | string | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    candidateNotes?: CandidateNoteListRelationFilter
    jobApplicationHistory?: JobApplicationHistoryListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    statusHistory?: UserStatusHistoryListRelationFilter
    statusChangesBy?: UserStatusHistoryListRelationFilter
    personalInfo?: XOR<PersonalInfoNullableScalarRelationFilter, PersonalInfoWhereInput> | null
    documents?: DocumentListRelationFilter
    documentReviews?: DocumentVerificationListRelationFilter
    DocumentVerification?: DocumentVerificationListRelationFilter
    OnboardingProgress?: XOR<OnboardingProgressNullableScalarRelationFilter, OnboardingProgressWhereInput> | null
    emergencyContacts?: EmergencyContactListRelationFilter
    dependentMembers?: DependentMemberListRelationFilter
    emails?: UserEmailListRelationFilter
    phones?: UserPhoneListRelationFilter
    managedOnboardings?: OnboardingProgressListRelationFilter
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    employees?: UserListRelationFilter
    requestsMade?: RequestListRelationFilter
    requestsToManage?: RequestListRelationFilter
    requestHistory?: RequestStatusHistoryListRelationFilter
    leavesRequested?: LeaveRequestListRelationFilter
    leavesToApprove?: LeaveRequestListRelationFilter
    leaveStatusHistory?: LeaveStatusHistoryListRelationFilter
    managedProjects?: ProjectListRelationFilter
    projectMemberships?: ProjectMemberListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
    shifts?: ShiftEntryListRelationFilter
    announcementsChanged?: AnnouncementListRelationFilter
    announcementsPublished?: AnnouncementListRelationFilter
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    status?: SortOrder
    role?: SortOrder
    employmentType?: SortOrder
    jobStartDate?: SortOrderInput | SortOrder
    jobEndDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    employmentType?: EnumEmploymentTypeWithAggregatesFilter<"User"> | $Enums.EmploymentType
    jobStartDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    jobEndDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    departmentId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    managerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    positionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserStatusHistoryWhereInput = {
    AND?: UserStatusHistoryWhereInput | UserStatusHistoryWhereInput[]
    OR?: UserStatusHistoryWhereInput[]
    NOT?: UserStatusHistoryWhereInput | UserStatusHistoryWhereInput[]
    id?: IntFilter<"UserStatusHistory"> | number
    userId?: StringFilter<"UserStatusHistory"> | string
    status?: EnumUserStatusFilter<"UserStatusHistory"> | $Enums.UserStatus
    comment?: StringNullableFilter<"UserStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"UserStatusHistory"> | Date | string
    changedById?: StringFilter<"UserStatusHistory"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    changedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    changedById?: SortOrder
    user?: UserOrderByWithRelationInput
    changedBy?: UserOrderByWithRelationInput
  }

  export type UserStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserStatusHistoryWhereInput | UserStatusHistoryWhereInput[]
    OR?: UserStatusHistoryWhereInput[]
    NOT?: UserStatusHistoryWhereInput | UserStatusHistoryWhereInput[]
    userId?: StringFilter<"UserStatusHistory"> | string
    status?: EnumUserStatusFilter<"UserStatusHistory"> | $Enums.UserStatus
    comment?: StringNullableFilter<"UserStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"UserStatusHistory"> | Date | string
    changedById?: StringFilter<"UserStatusHistory"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    changedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    changedById?: SortOrder
    _count?: UserStatusHistoryCountOrderByAggregateInput
    _avg?: UserStatusHistoryAvgOrderByAggregateInput
    _max?: UserStatusHistoryMaxOrderByAggregateInput
    _min?: UserStatusHistoryMinOrderByAggregateInput
    _sum?: UserStatusHistorySumOrderByAggregateInput
  }

  export type UserStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: UserStatusHistoryScalarWhereWithAggregatesInput | UserStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: UserStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: UserStatusHistoryScalarWhereWithAggregatesInput | UserStatusHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserStatusHistory"> | number
    userId?: StringWithAggregatesFilter<"UserStatusHistory"> | string
    status?: EnumUserStatusWithAggregatesFilter<"UserStatusHistory"> | $Enums.UserStatus
    comment?: StringNullableWithAggregatesFilter<"UserStatusHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserStatusHistory"> | Date | string
    changedById?: StringWithAggregatesFilter<"UserStatusHistory"> | string
  }

  export type CandidateNoteWhereInput = {
    AND?: CandidateNoteWhereInput | CandidateNoteWhereInput[]
    OR?: CandidateNoteWhereInput[]
    NOT?: CandidateNoteWhereInput | CandidateNoteWhereInput[]
    id?: IntFilter<"CandidateNote"> | number
    candidateId?: StringFilter<"CandidateNote"> | string
    content?: StringFilter<"CandidateNote"> | string
    createdAt?: DateTimeFilter<"CandidateNote"> | Date | string
    updatedAt?: DateTimeFilter<"CandidateNote"> | Date | string
    userId?: StringFilter<"CandidateNote"> | string
    candidate?: XOR<CandidateScalarRelationFilter, CandidateWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CandidateNoteOrderByWithRelationInput = {
    id?: SortOrder
    candidateId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    candidate?: CandidateOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type CandidateNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CandidateNoteWhereInput | CandidateNoteWhereInput[]
    OR?: CandidateNoteWhereInput[]
    NOT?: CandidateNoteWhereInput | CandidateNoteWhereInput[]
    candidateId?: StringFilter<"CandidateNote"> | string
    content?: StringFilter<"CandidateNote"> | string
    createdAt?: DateTimeFilter<"CandidateNote"> | Date | string
    updatedAt?: DateTimeFilter<"CandidateNote"> | Date | string
    userId?: StringFilter<"CandidateNote"> | string
    candidate?: XOR<CandidateScalarRelationFilter, CandidateWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CandidateNoteOrderByWithAggregationInput = {
    id?: SortOrder
    candidateId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: CandidateNoteCountOrderByAggregateInput
    _avg?: CandidateNoteAvgOrderByAggregateInput
    _max?: CandidateNoteMaxOrderByAggregateInput
    _min?: CandidateNoteMinOrderByAggregateInput
    _sum?: CandidateNoteSumOrderByAggregateInput
  }

  export type CandidateNoteScalarWhereWithAggregatesInput = {
    AND?: CandidateNoteScalarWhereWithAggregatesInput | CandidateNoteScalarWhereWithAggregatesInput[]
    OR?: CandidateNoteScalarWhereWithAggregatesInput[]
    NOT?: CandidateNoteScalarWhereWithAggregatesInput | CandidateNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CandidateNote"> | number
    candidateId?: StringWithAggregatesFilter<"CandidateNote"> | string
    content?: StringWithAggregatesFilter<"CandidateNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CandidateNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CandidateNote"> | Date | string
    userId?: StringWithAggregatesFilter<"CandidateNote"> | string
  }

  export type JobListingWhereInput = {
    AND?: JobListingWhereInput | JobListingWhereInput[]
    OR?: JobListingWhereInput[]
    NOT?: JobListingWhereInput | JobListingWhereInput[]
    id?: IntFilter<"JobListing"> | number
    title?: StringFilter<"JobListing"> | string
    description?: StringFilter<"JobListing"> | string
    employmentType?: EnumEmploymentTypeFilter<"JobListing"> | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFilter<"JobListing"> | $Enums.WorkplaceType
    referralSource?: StringNullableFilter<"JobListing"> | string | null
    startDate?: DateTimeFilter<"JobListing"> | Date | string
    endDate?: DateTimeNullableFilter<"JobListing"> | Date | string | null
    status?: EnumJobStatusFilter<"JobListing"> | $Enums.JobStatus
    departmentId?: StringNullableFilter<"JobListing"> | string | null
    locationId?: StringNullableFilter<"JobListing"> | string | null
    keywords?: StringNullableListFilter<"JobListing">
    createdAt?: DateTimeFilter<"JobListing"> | Date | string
    updatedAt?: DateTimeFilter<"JobListing"> | Date | string
    positionId?: StringNullableFilter<"JobListing"> | string | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    applications?: JobApplicationListRelationFilter
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
  }

  export type JobListingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    employmentType?: SortOrder
    workplaceType?: SortOrder
    referralSource?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    positionId?: SortOrderInput | SortOrder
    department?: DepartmentOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    applications?: JobApplicationOrderByRelationAggregateInput
    position?: PositionOrderByWithRelationInput
  }

  export type JobListingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobListingWhereInput | JobListingWhereInput[]
    OR?: JobListingWhereInput[]
    NOT?: JobListingWhereInput | JobListingWhereInput[]
    title?: StringFilter<"JobListing"> | string
    description?: StringFilter<"JobListing"> | string
    employmentType?: EnumEmploymentTypeFilter<"JobListing"> | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFilter<"JobListing"> | $Enums.WorkplaceType
    referralSource?: StringNullableFilter<"JobListing"> | string | null
    startDate?: DateTimeFilter<"JobListing"> | Date | string
    endDate?: DateTimeNullableFilter<"JobListing"> | Date | string | null
    status?: EnumJobStatusFilter<"JobListing"> | $Enums.JobStatus
    departmentId?: StringNullableFilter<"JobListing"> | string | null
    locationId?: StringNullableFilter<"JobListing"> | string | null
    keywords?: StringNullableListFilter<"JobListing">
    createdAt?: DateTimeFilter<"JobListing"> | Date | string
    updatedAt?: DateTimeFilter<"JobListing"> | Date | string
    positionId?: StringNullableFilter<"JobListing"> | string | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    applications?: JobApplicationListRelationFilter
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
  }, "id">

  export type JobListingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    employmentType?: SortOrder
    workplaceType?: SortOrder
    referralSource?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    positionId?: SortOrderInput | SortOrder
    _count?: JobListingCountOrderByAggregateInput
    _avg?: JobListingAvgOrderByAggregateInput
    _max?: JobListingMaxOrderByAggregateInput
    _min?: JobListingMinOrderByAggregateInput
    _sum?: JobListingSumOrderByAggregateInput
  }

  export type JobListingScalarWhereWithAggregatesInput = {
    AND?: JobListingScalarWhereWithAggregatesInput | JobListingScalarWhereWithAggregatesInput[]
    OR?: JobListingScalarWhereWithAggregatesInput[]
    NOT?: JobListingScalarWhereWithAggregatesInput | JobListingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JobListing"> | number
    title?: StringWithAggregatesFilter<"JobListing"> | string
    description?: StringWithAggregatesFilter<"JobListing"> | string
    employmentType?: EnumEmploymentTypeWithAggregatesFilter<"JobListing"> | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeWithAggregatesFilter<"JobListing"> | $Enums.WorkplaceType
    referralSource?: StringNullableWithAggregatesFilter<"JobListing"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"JobListing"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"JobListing"> | Date | string | null
    status?: EnumJobStatusWithAggregatesFilter<"JobListing"> | $Enums.JobStatus
    departmentId?: StringNullableWithAggregatesFilter<"JobListing"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"JobListing"> | string | null
    keywords?: StringNullableListFilter<"JobListing">
    createdAt?: DateTimeWithAggregatesFilter<"JobListing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobListing"> | Date | string
    positionId?: StringNullableWithAggregatesFilter<"JobListing"> | string | null
  }

  export type CandidateWhereInput = {
    AND?: CandidateWhereInput | CandidateWhereInput[]
    OR?: CandidateWhereInput[]
    NOT?: CandidateWhereInput | CandidateWhereInput[]
    id?: StringFilter<"Candidate"> | string
    name?: StringFilter<"Candidate"> | string
    surname?: StringFilter<"Candidate"> | string
    email?: StringFilter<"Candidate"> | string
    phone?: StringFilter<"Candidate"> | string
    linkedin?: StringNullableFilter<"Candidate"> | string | null
    github?: StringNullableFilter<"Candidate"> | string | null
    createdAt?: DateTimeFilter<"Candidate"> | Date | string
    updatedAt?: DateTimeFilter<"Candidate"> | Date | string
    applications?: JobApplicationListRelationFilter
    notes?: CandidateNoteListRelationFilter
  }

  export type CandidateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    linkedin?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applications?: JobApplicationOrderByRelationAggregateInput
    notes?: CandidateNoteOrderByRelationAggregateInput
  }

  export type CandidateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CandidateWhereInput | CandidateWhereInput[]
    OR?: CandidateWhereInput[]
    NOT?: CandidateWhereInput | CandidateWhereInput[]
    name?: StringFilter<"Candidate"> | string
    surname?: StringFilter<"Candidate"> | string
    phone?: StringFilter<"Candidate"> | string
    linkedin?: StringNullableFilter<"Candidate"> | string | null
    github?: StringNullableFilter<"Candidate"> | string | null
    createdAt?: DateTimeFilter<"Candidate"> | Date | string
    updatedAt?: DateTimeFilter<"Candidate"> | Date | string
    applications?: JobApplicationListRelationFilter
    notes?: CandidateNoteListRelationFilter
  }, "id" | "email">

  export type CandidateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    linkedin?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CandidateCountOrderByAggregateInput
    _max?: CandidateMaxOrderByAggregateInput
    _min?: CandidateMinOrderByAggregateInput
  }

  export type CandidateScalarWhereWithAggregatesInput = {
    AND?: CandidateScalarWhereWithAggregatesInput | CandidateScalarWhereWithAggregatesInput[]
    OR?: CandidateScalarWhereWithAggregatesInput[]
    NOT?: CandidateScalarWhereWithAggregatesInput | CandidateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Candidate"> | string
    name?: StringWithAggregatesFilter<"Candidate"> | string
    surname?: StringWithAggregatesFilter<"Candidate"> | string
    email?: StringWithAggregatesFilter<"Candidate"> | string
    phone?: StringWithAggregatesFilter<"Candidate"> | string
    linkedin?: StringNullableWithAggregatesFilter<"Candidate"> | string | null
    github?: StringNullableWithAggregatesFilter<"Candidate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Candidate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Candidate"> | Date | string
  }

  export type JobApplicationWhereInput = {
    AND?: JobApplicationWhereInput | JobApplicationWhereInput[]
    OR?: JobApplicationWhereInput[]
    NOT?: JobApplicationWhereInput | JobApplicationWhereInput[]
    id?: IntFilter<"JobApplication"> | number
    candidateId?: StringFilter<"JobApplication"> | string
    resumeKey?: StringNullableFilter<"JobApplication"> | string | null
    additionalNotes?: StringNullableFilter<"JobApplication"> | string | null
    referralSource?: StringNullableFilter<"JobApplication"> | string | null
    status?: EnumApplicationStatusFilter<"JobApplication"> | $Enums.ApplicationStatus
    jobListingId?: IntFilter<"JobApplication"> | number
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
    candidate?: XOR<CandidateScalarRelationFilter, CandidateWhereInput>
    jobListing?: XOR<JobListingScalarRelationFilter, JobListingWhereInput>
    history?: JobApplicationHistoryListRelationFilter
    cvAnalysis?: XOR<CvAnalysisNullableScalarRelationFilter, CvAnalysisWhereInput> | null
    OnboardingProgress?: XOR<OnboardingProgressNullableScalarRelationFilter, OnboardingProgressWhereInput> | null
    OnboardingInvitation?: XOR<OnboardingInvitationNullableScalarRelationFilter, OnboardingInvitationWhereInput> | null
  }

  export type JobApplicationOrderByWithRelationInput = {
    id?: SortOrder
    candidateId?: SortOrder
    resumeKey?: SortOrderInput | SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    referralSource?: SortOrderInput | SortOrder
    status?: SortOrder
    jobListingId?: SortOrder
    createdAt?: SortOrder
    candidate?: CandidateOrderByWithRelationInput
    jobListing?: JobListingOrderByWithRelationInput
    history?: JobApplicationHistoryOrderByRelationAggregateInput
    cvAnalysis?: CvAnalysisOrderByWithRelationInput
    OnboardingProgress?: OnboardingProgressOrderByWithRelationInput
    OnboardingInvitation?: OnboardingInvitationOrderByWithRelationInput
  }

  export type JobApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobApplicationWhereInput | JobApplicationWhereInput[]
    OR?: JobApplicationWhereInput[]
    NOT?: JobApplicationWhereInput | JobApplicationWhereInput[]
    candidateId?: StringFilter<"JobApplication"> | string
    resumeKey?: StringNullableFilter<"JobApplication"> | string | null
    additionalNotes?: StringNullableFilter<"JobApplication"> | string | null
    referralSource?: StringNullableFilter<"JobApplication"> | string | null
    status?: EnumApplicationStatusFilter<"JobApplication"> | $Enums.ApplicationStatus
    jobListingId?: IntFilter<"JobApplication"> | number
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
    candidate?: XOR<CandidateScalarRelationFilter, CandidateWhereInput>
    jobListing?: XOR<JobListingScalarRelationFilter, JobListingWhereInput>
    history?: JobApplicationHistoryListRelationFilter
    cvAnalysis?: XOR<CvAnalysisNullableScalarRelationFilter, CvAnalysisWhereInput> | null
    OnboardingProgress?: XOR<OnboardingProgressNullableScalarRelationFilter, OnboardingProgressWhereInput> | null
    OnboardingInvitation?: XOR<OnboardingInvitationNullableScalarRelationFilter, OnboardingInvitationWhereInput> | null
  }, "id">

  export type JobApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    candidateId?: SortOrder
    resumeKey?: SortOrderInput | SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    referralSource?: SortOrderInput | SortOrder
    status?: SortOrder
    jobListingId?: SortOrder
    createdAt?: SortOrder
    _count?: JobApplicationCountOrderByAggregateInput
    _avg?: JobApplicationAvgOrderByAggregateInput
    _max?: JobApplicationMaxOrderByAggregateInput
    _min?: JobApplicationMinOrderByAggregateInput
    _sum?: JobApplicationSumOrderByAggregateInput
  }

  export type JobApplicationScalarWhereWithAggregatesInput = {
    AND?: JobApplicationScalarWhereWithAggregatesInput | JobApplicationScalarWhereWithAggregatesInput[]
    OR?: JobApplicationScalarWhereWithAggregatesInput[]
    NOT?: JobApplicationScalarWhereWithAggregatesInput | JobApplicationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JobApplication"> | number
    candidateId?: StringWithAggregatesFilter<"JobApplication"> | string
    resumeKey?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    additionalNotes?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    referralSource?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    status?: EnumApplicationStatusWithAggregatesFilter<"JobApplication"> | $Enums.ApplicationStatus
    jobListingId?: IntWithAggregatesFilter<"JobApplication"> | number
    createdAt?: DateTimeWithAggregatesFilter<"JobApplication"> | Date | string
  }

  export type CvAnalysisWhereInput = {
    AND?: CvAnalysisWhereInput | CvAnalysisWhereInput[]
    OR?: CvAnalysisWhereInput[]
    NOT?: CvAnalysisWhereInput | CvAnalysisWhereInput[]
    id?: IntFilter<"CvAnalysis"> | number
    applicationId?: IntFilter<"CvAnalysis"> | number
    totalScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    technicalScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    experienceScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    educationScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    cvQualityScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    softSkillsScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    analysis?: StringNullableFilter<"CvAnalysis"> | string | null
    parsedContent?: JsonNullableFilter<"CvAnalysis">
    error?: StringNullableFilter<"CvAnalysis"> | string | null
    createdAt?: DateTimeFilter<"CvAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"CvAnalysis"> | Date | string
    application?: XOR<JobApplicationScalarRelationFilter, JobApplicationWhereInput>
  }

  export type CvAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    totalScore?: SortOrderInput | SortOrder
    technicalScore?: SortOrderInput | SortOrder
    experienceScore?: SortOrderInput | SortOrder
    educationScore?: SortOrderInput | SortOrder
    cvQualityScore?: SortOrderInput | SortOrder
    softSkillsScore?: SortOrderInput | SortOrder
    analysis?: SortOrderInput | SortOrder
    parsedContent?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    application?: JobApplicationOrderByWithRelationInput
  }

  export type CvAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    applicationId?: number
    AND?: CvAnalysisWhereInput | CvAnalysisWhereInput[]
    OR?: CvAnalysisWhereInput[]
    NOT?: CvAnalysisWhereInput | CvAnalysisWhereInput[]
    totalScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    technicalScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    experienceScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    educationScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    cvQualityScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    softSkillsScore?: FloatNullableFilter<"CvAnalysis"> | number | null
    analysis?: StringNullableFilter<"CvAnalysis"> | string | null
    parsedContent?: JsonNullableFilter<"CvAnalysis">
    error?: StringNullableFilter<"CvAnalysis"> | string | null
    createdAt?: DateTimeFilter<"CvAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"CvAnalysis"> | Date | string
    application?: XOR<JobApplicationScalarRelationFilter, JobApplicationWhereInput>
  }, "id" | "applicationId">

  export type CvAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    totalScore?: SortOrderInput | SortOrder
    technicalScore?: SortOrderInput | SortOrder
    experienceScore?: SortOrderInput | SortOrder
    educationScore?: SortOrderInput | SortOrder
    cvQualityScore?: SortOrderInput | SortOrder
    softSkillsScore?: SortOrderInput | SortOrder
    analysis?: SortOrderInput | SortOrder
    parsedContent?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CvAnalysisCountOrderByAggregateInput
    _avg?: CvAnalysisAvgOrderByAggregateInput
    _max?: CvAnalysisMaxOrderByAggregateInput
    _min?: CvAnalysisMinOrderByAggregateInput
    _sum?: CvAnalysisSumOrderByAggregateInput
  }

  export type CvAnalysisScalarWhereWithAggregatesInput = {
    AND?: CvAnalysisScalarWhereWithAggregatesInput | CvAnalysisScalarWhereWithAggregatesInput[]
    OR?: CvAnalysisScalarWhereWithAggregatesInput[]
    NOT?: CvAnalysisScalarWhereWithAggregatesInput | CvAnalysisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CvAnalysis"> | number
    applicationId?: IntWithAggregatesFilter<"CvAnalysis"> | number
    totalScore?: FloatNullableWithAggregatesFilter<"CvAnalysis"> | number | null
    technicalScore?: FloatNullableWithAggregatesFilter<"CvAnalysis"> | number | null
    experienceScore?: FloatNullableWithAggregatesFilter<"CvAnalysis"> | number | null
    educationScore?: FloatNullableWithAggregatesFilter<"CvAnalysis"> | number | null
    cvQualityScore?: FloatNullableWithAggregatesFilter<"CvAnalysis"> | number | null
    softSkillsScore?: FloatNullableWithAggregatesFilter<"CvAnalysis"> | number | null
    analysis?: StringNullableWithAggregatesFilter<"CvAnalysis"> | string | null
    parsedContent?: JsonNullableWithAggregatesFilter<"CvAnalysis">
    error?: StringNullableWithAggregatesFilter<"CvAnalysis"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CvAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CvAnalysis"> | Date | string
  }

  export type JobApplicationHistoryWhereInput = {
    AND?: JobApplicationHistoryWhereInput | JobApplicationHistoryWhereInput[]
    OR?: JobApplicationHistoryWhereInput[]
    NOT?: JobApplicationHistoryWhereInput | JobApplicationHistoryWhereInput[]
    id?: IntFilter<"JobApplicationHistory"> | number
    applicationId?: IntFilter<"JobApplicationHistory"> | number
    status?: EnumApplicationStatusFilter<"JobApplicationHistory"> | $Enums.ApplicationStatus
    comment?: StringNullableFilter<"JobApplicationHistory"> | string | null
    createdAt?: DateTimeFilter<"JobApplicationHistory"> | Date | string
    changedByUserId?: StringNullableFilter<"JobApplicationHistory"> | string | null
    application?: XOR<JobApplicationScalarRelationFilter, JobApplicationWhereInput>
    changedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type JobApplicationHistoryOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    changedByUserId?: SortOrderInput | SortOrder
    application?: JobApplicationOrderByWithRelationInput
    changedBy?: UserOrderByWithRelationInput
  }

  export type JobApplicationHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobApplicationHistoryWhereInput | JobApplicationHistoryWhereInput[]
    OR?: JobApplicationHistoryWhereInput[]
    NOT?: JobApplicationHistoryWhereInput | JobApplicationHistoryWhereInput[]
    applicationId?: IntFilter<"JobApplicationHistory"> | number
    status?: EnumApplicationStatusFilter<"JobApplicationHistory"> | $Enums.ApplicationStatus
    comment?: StringNullableFilter<"JobApplicationHistory"> | string | null
    createdAt?: DateTimeFilter<"JobApplicationHistory"> | Date | string
    changedByUserId?: StringNullableFilter<"JobApplicationHistory"> | string | null
    application?: XOR<JobApplicationScalarRelationFilter, JobApplicationWhereInput>
    changedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type JobApplicationHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    changedByUserId?: SortOrderInput | SortOrder
    _count?: JobApplicationHistoryCountOrderByAggregateInput
    _avg?: JobApplicationHistoryAvgOrderByAggregateInput
    _max?: JobApplicationHistoryMaxOrderByAggregateInput
    _min?: JobApplicationHistoryMinOrderByAggregateInput
    _sum?: JobApplicationHistorySumOrderByAggregateInput
  }

  export type JobApplicationHistoryScalarWhereWithAggregatesInput = {
    AND?: JobApplicationHistoryScalarWhereWithAggregatesInput | JobApplicationHistoryScalarWhereWithAggregatesInput[]
    OR?: JobApplicationHistoryScalarWhereWithAggregatesInput[]
    NOT?: JobApplicationHistoryScalarWhereWithAggregatesInput | JobApplicationHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JobApplicationHistory"> | number
    applicationId?: IntWithAggregatesFilter<"JobApplicationHistory"> | number
    status?: EnumApplicationStatusWithAggregatesFilter<"JobApplicationHistory"> | $Enums.ApplicationStatus
    comment?: StringNullableWithAggregatesFilter<"JobApplicationHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JobApplicationHistory"> | Date | string
    changedByUserId?: StringNullableWithAggregatesFilter<"JobApplicationHistory"> | string | null
  }

  export type PersonalInfoWhereInput = {
    AND?: PersonalInfoWhereInput | PersonalInfoWhereInput[]
    OR?: PersonalInfoWhereInput[]
    NOT?: PersonalInfoWhereInput | PersonalInfoWhereInput[]
    id?: IntFilter<"PersonalInfo"> | number
    userId?: StringFilter<"PersonalInfo"> | string
    amka?: StringNullableFilter<"PersonalInfo"> | string | null
    afm?: StringNullableFilter<"PersonalInfo"> | string | null
    doy?: StringNullableFilter<"PersonalInfo"> | string | null
    middleName?: StringNullableFilter<"PersonalInfo"> | string | null
    birthDate?: DateTimeFilter<"PersonalInfo"> | Date | string
    birthPlace?: StringFilter<"PersonalInfo"> | string
    maritalStatus?: EnumMaritalStatusFilter<"PersonalInfo"> | $Enums.MaritalStatus
    numberOfChildren?: IntFilter<"PersonalInfo"> | number
    citizenship?: StringNullableFilter<"PersonalInfo"> | string | null
    nationality?: StringNullableFilter<"PersonalInfo"> | string | null
    gender?: EnumGenderNullableFilter<"PersonalInfo"> | $Enums.Gender | null
    createdAt?: DateTimeFilter<"PersonalInfo"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalInfo"> | Date | string
    educationLevel?: EnumEducationLevelNullableFilter<"PersonalInfo"> | $Enums.EducationLevel | null
    educationTitle?: StringNullableFilter<"PersonalInfo"> | string | null
    educationInstitution?: StringNullableFilter<"PersonalInfo"> | string | null
    graduationYear?: IntNullableFilter<"PersonalInfo"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    identificationDocuments?: IdentificationDocumentListRelationFilter
    addresses?: AddressListRelationFilter
    bankAccounts?: BankAccountListRelationFilter
    languageSkills?: LanguageSkillListRelationFilter
  }

  export type PersonalInfoOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amka?: SortOrderInput | SortOrder
    afm?: SortOrderInput | SortOrder
    doy?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    maritalStatus?: SortOrder
    numberOfChildren?: SortOrder
    citizenship?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    educationLevel?: SortOrderInput | SortOrder
    educationTitle?: SortOrderInput | SortOrder
    educationInstitution?: SortOrderInput | SortOrder
    graduationYear?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    identificationDocuments?: IdentificationDocumentOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
    bankAccounts?: BankAccountOrderByRelationAggregateInput
    languageSkills?: LanguageSkillOrderByRelationAggregateInput
  }

  export type PersonalInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: string
    amka?: string
    afm?: string
    AND?: PersonalInfoWhereInput | PersonalInfoWhereInput[]
    OR?: PersonalInfoWhereInput[]
    NOT?: PersonalInfoWhereInput | PersonalInfoWhereInput[]
    doy?: StringNullableFilter<"PersonalInfo"> | string | null
    middleName?: StringNullableFilter<"PersonalInfo"> | string | null
    birthDate?: DateTimeFilter<"PersonalInfo"> | Date | string
    birthPlace?: StringFilter<"PersonalInfo"> | string
    maritalStatus?: EnumMaritalStatusFilter<"PersonalInfo"> | $Enums.MaritalStatus
    numberOfChildren?: IntFilter<"PersonalInfo"> | number
    citizenship?: StringNullableFilter<"PersonalInfo"> | string | null
    nationality?: StringNullableFilter<"PersonalInfo"> | string | null
    gender?: EnumGenderNullableFilter<"PersonalInfo"> | $Enums.Gender | null
    createdAt?: DateTimeFilter<"PersonalInfo"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalInfo"> | Date | string
    educationLevel?: EnumEducationLevelNullableFilter<"PersonalInfo"> | $Enums.EducationLevel | null
    educationTitle?: StringNullableFilter<"PersonalInfo"> | string | null
    educationInstitution?: StringNullableFilter<"PersonalInfo"> | string | null
    graduationYear?: IntNullableFilter<"PersonalInfo"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    identificationDocuments?: IdentificationDocumentListRelationFilter
    addresses?: AddressListRelationFilter
    bankAccounts?: BankAccountListRelationFilter
    languageSkills?: LanguageSkillListRelationFilter
  }, "id" | "userId" | "amka" | "afm">

  export type PersonalInfoOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amka?: SortOrderInput | SortOrder
    afm?: SortOrderInput | SortOrder
    doy?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    maritalStatus?: SortOrder
    numberOfChildren?: SortOrder
    citizenship?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    educationLevel?: SortOrderInput | SortOrder
    educationTitle?: SortOrderInput | SortOrder
    educationInstitution?: SortOrderInput | SortOrder
    graduationYear?: SortOrderInput | SortOrder
    _count?: PersonalInfoCountOrderByAggregateInput
    _avg?: PersonalInfoAvgOrderByAggregateInput
    _max?: PersonalInfoMaxOrderByAggregateInput
    _min?: PersonalInfoMinOrderByAggregateInput
    _sum?: PersonalInfoSumOrderByAggregateInput
  }

  export type PersonalInfoScalarWhereWithAggregatesInput = {
    AND?: PersonalInfoScalarWhereWithAggregatesInput | PersonalInfoScalarWhereWithAggregatesInput[]
    OR?: PersonalInfoScalarWhereWithAggregatesInput[]
    NOT?: PersonalInfoScalarWhereWithAggregatesInput | PersonalInfoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PersonalInfo"> | number
    userId?: StringWithAggregatesFilter<"PersonalInfo"> | string
    amka?: StringNullableWithAggregatesFilter<"PersonalInfo"> | string | null
    afm?: StringNullableWithAggregatesFilter<"PersonalInfo"> | string | null
    doy?: StringNullableWithAggregatesFilter<"PersonalInfo"> | string | null
    middleName?: StringNullableWithAggregatesFilter<"PersonalInfo"> | string | null
    birthDate?: DateTimeWithAggregatesFilter<"PersonalInfo"> | Date | string
    birthPlace?: StringWithAggregatesFilter<"PersonalInfo"> | string
    maritalStatus?: EnumMaritalStatusWithAggregatesFilter<"PersonalInfo"> | $Enums.MaritalStatus
    numberOfChildren?: IntWithAggregatesFilter<"PersonalInfo"> | number
    citizenship?: StringNullableWithAggregatesFilter<"PersonalInfo"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"PersonalInfo"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"PersonalInfo"> | $Enums.Gender | null
    createdAt?: DateTimeWithAggregatesFilter<"PersonalInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PersonalInfo"> | Date | string
    educationLevel?: EnumEducationLevelNullableWithAggregatesFilter<"PersonalInfo"> | $Enums.EducationLevel | null
    educationTitle?: StringNullableWithAggregatesFilter<"PersonalInfo"> | string | null
    educationInstitution?: StringNullableWithAggregatesFilter<"PersonalInfo"> | string | null
    graduationYear?: IntNullableWithAggregatesFilter<"PersonalInfo"> | number | null
  }

  export type IdentificationDocumentWhereInput = {
    AND?: IdentificationDocumentWhereInput | IdentificationDocumentWhereInput[]
    OR?: IdentificationDocumentWhereInput[]
    NOT?: IdentificationDocumentWhereInput | IdentificationDocumentWhereInput[]
    id?: IntFilter<"IdentificationDocument"> | number
    personalInfoId?: IntFilter<"IdentificationDocument"> | number
    type?: EnumIdentificationDocumentTypeFilter<"IdentificationDocument"> | $Enums.IdentificationDocumentType
    documentNumber?: StringFilter<"IdentificationDocument"> | string
    issueDate?: DateTimeFilter<"IdentificationDocument"> | Date | string
    expiryDate?: DateTimeNullableFilter<"IdentificationDocument"> | Date | string | null
    issuingAuthority?: StringFilter<"IdentificationDocument"> | string
    isPrimary?: BoolFilter<"IdentificationDocument"> | boolean
    createdAt?: DateTimeFilter<"IdentificationDocument"> | Date | string
    updatedAt?: DateTimeFilter<"IdentificationDocument"> | Date | string
    personalInfo?: XOR<PersonalInfoScalarRelationFilter, PersonalInfoWhereInput>
  }

  export type IdentificationDocumentOrderByWithRelationInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    type?: SortOrder
    documentNumber?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    issuingAuthority?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalInfo?: PersonalInfoOrderByWithRelationInput
  }

  export type IdentificationDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    personalInfoId_documentNumber?: IdentificationDocumentPersonalInfoIdDocumentNumberCompoundUniqueInput
    AND?: IdentificationDocumentWhereInput | IdentificationDocumentWhereInput[]
    OR?: IdentificationDocumentWhereInput[]
    NOT?: IdentificationDocumentWhereInput | IdentificationDocumentWhereInput[]
    personalInfoId?: IntFilter<"IdentificationDocument"> | number
    type?: EnumIdentificationDocumentTypeFilter<"IdentificationDocument"> | $Enums.IdentificationDocumentType
    documentNumber?: StringFilter<"IdentificationDocument"> | string
    issueDate?: DateTimeFilter<"IdentificationDocument"> | Date | string
    expiryDate?: DateTimeNullableFilter<"IdentificationDocument"> | Date | string | null
    issuingAuthority?: StringFilter<"IdentificationDocument"> | string
    isPrimary?: BoolFilter<"IdentificationDocument"> | boolean
    createdAt?: DateTimeFilter<"IdentificationDocument"> | Date | string
    updatedAt?: DateTimeFilter<"IdentificationDocument"> | Date | string
    personalInfo?: XOR<PersonalInfoScalarRelationFilter, PersonalInfoWhereInput>
  }, "id" | "personalInfoId_documentNumber">

  export type IdentificationDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    type?: SortOrder
    documentNumber?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    issuingAuthority?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IdentificationDocumentCountOrderByAggregateInput
    _avg?: IdentificationDocumentAvgOrderByAggregateInput
    _max?: IdentificationDocumentMaxOrderByAggregateInput
    _min?: IdentificationDocumentMinOrderByAggregateInput
    _sum?: IdentificationDocumentSumOrderByAggregateInput
  }

  export type IdentificationDocumentScalarWhereWithAggregatesInput = {
    AND?: IdentificationDocumentScalarWhereWithAggregatesInput | IdentificationDocumentScalarWhereWithAggregatesInput[]
    OR?: IdentificationDocumentScalarWhereWithAggregatesInput[]
    NOT?: IdentificationDocumentScalarWhereWithAggregatesInput | IdentificationDocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IdentificationDocument"> | number
    personalInfoId?: IntWithAggregatesFilter<"IdentificationDocument"> | number
    type?: EnumIdentificationDocumentTypeWithAggregatesFilter<"IdentificationDocument"> | $Enums.IdentificationDocumentType
    documentNumber?: StringWithAggregatesFilter<"IdentificationDocument"> | string
    issueDate?: DateTimeWithAggregatesFilter<"IdentificationDocument"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"IdentificationDocument"> | Date | string | null
    issuingAuthority?: StringWithAggregatesFilter<"IdentificationDocument"> | string
    isPrimary?: BoolWithAggregatesFilter<"IdentificationDocument"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"IdentificationDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IdentificationDocument"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: IntFilter<"Address"> | number
    personalInfoId?: IntFilter<"Address"> | number
    type?: EnumAddressTypeFilter<"Address"> | $Enums.AddressType
    street?: StringFilter<"Address"> | string
    streetNumber?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    region?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    isPrimary?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    personalInfo?: XOR<PersonalInfoScalarRelationFilter, PersonalInfoWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    type?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalInfo?: PersonalInfoOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    personalInfoId?: IntFilter<"Address"> | number
    type?: EnumAddressTypeFilter<"Address"> | $Enums.AddressType
    street?: StringFilter<"Address"> | string
    streetNumber?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    region?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    isPrimary?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    personalInfo?: XOR<PersonalInfoScalarRelationFilter, PersonalInfoWhereInput>
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    type?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Address"> | number
    personalInfoId?: IntWithAggregatesFilter<"Address"> | number
    type?: EnumAddressTypeWithAggregatesFilter<"Address"> | $Enums.AddressType
    street?: StringWithAggregatesFilter<"Address"> | string
    streetNumber?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    region?: StringWithAggregatesFilter<"Address"> | string
    postalCode?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    isPrimary?: BoolWithAggregatesFilter<"Address"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: IntFilter<"Document"> | number
    userId?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    key?: StringFilter<"Document"> | string
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    dependentMemberId?: IntNullableFilter<"Document"> | number | null
    languageSkillId?: IntNullableFilter<"Document"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    dependentMember?: XOR<DependentMemberNullableScalarRelationFilter, DependentMemberWhereInput> | null
    verification?: XOR<DocumentVerificationNullableScalarRelationFilter, DocumentVerificationWhereInput> | null
    languageSkill?: XOR<LanguageSkillNullableScalarRelationFilter, LanguageSkillWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    uploadedAt?: SortOrder
    dependentMemberId?: SortOrderInput | SortOrder
    languageSkillId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    dependentMember?: DependentMemberOrderByWithRelationInput
    verification?: DocumentVerificationOrderByWithRelationInput
    languageSkill?: LanguageSkillOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    userId?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    key?: StringFilter<"Document"> | string
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    dependentMemberId?: IntNullableFilter<"Document"> | number | null
    languageSkillId?: IntNullableFilter<"Document"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    dependentMember?: XOR<DependentMemberNullableScalarRelationFilter, DependentMemberWhereInput> | null
    verification?: XOR<DocumentVerificationNullableScalarRelationFilter, DocumentVerificationWhereInput> | null
    languageSkill?: XOR<LanguageSkillNullableScalarRelationFilter, LanguageSkillWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    uploadedAt?: SortOrder
    dependentMemberId?: SortOrderInput | SortOrder
    languageSkillId?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Document"> | number
    userId?: StringWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    key?: StringWithAggregatesFilter<"Document"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    dependentMemberId?: IntNullableWithAggregatesFilter<"Document"> | number | null
    languageSkillId?: IntNullableWithAggregatesFilter<"Document"> | number | null
  }

  export type DocumentVerificationWhereInput = {
    AND?: DocumentVerificationWhereInput | DocumentVerificationWhereInput[]
    OR?: DocumentVerificationWhereInput[]
    NOT?: DocumentVerificationWhereInput | DocumentVerificationWhereInput[]
    id?: IntFilter<"DocumentVerification"> | number
    documentId?: IntFilter<"DocumentVerification"> | number
    status?: EnumVerificationStatusFilter<"DocumentVerification"> | $Enums.VerificationStatus
    reviewedById?: StringFilter<"DocumentVerification"> | string
    comments?: StringNullableFilter<"DocumentVerification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"DocumentVerification"> | Date | string | null
    userId?: StringNullableFilter<"DocumentVerification"> | string | null
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    reviewedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DocumentVerificationOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    comments?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    document?: DocumentOrderByWithRelationInput
    reviewedBy?: UserOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type DocumentVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    documentId?: number
    AND?: DocumentVerificationWhereInput | DocumentVerificationWhereInput[]
    OR?: DocumentVerificationWhereInput[]
    NOT?: DocumentVerificationWhereInput | DocumentVerificationWhereInput[]
    status?: EnumVerificationStatusFilter<"DocumentVerification"> | $Enums.VerificationStatus
    reviewedById?: StringFilter<"DocumentVerification"> | string
    comments?: StringNullableFilter<"DocumentVerification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"DocumentVerification"> | Date | string | null
    userId?: StringNullableFilter<"DocumentVerification"> | string | null
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    reviewedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "documentId">

  export type DocumentVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    comments?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: DocumentVerificationCountOrderByAggregateInput
    _avg?: DocumentVerificationAvgOrderByAggregateInput
    _max?: DocumentVerificationMaxOrderByAggregateInput
    _min?: DocumentVerificationMinOrderByAggregateInput
    _sum?: DocumentVerificationSumOrderByAggregateInput
  }

  export type DocumentVerificationScalarWhereWithAggregatesInput = {
    AND?: DocumentVerificationScalarWhereWithAggregatesInput | DocumentVerificationScalarWhereWithAggregatesInput[]
    OR?: DocumentVerificationScalarWhereWithAggregatesInput[]
    NOT?: DocumentVerificationScalarWhereWithAggregatesInput | DocumentVerificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DocumentVerification"> | number
    documentId?: IntWithAggregatesFilter<"DocumentVerification"> | number
    status?: EnumVerificationStatusWithAggregatesFilter<"DocumentVerification"> | $Enums.VerificationStatus
    reviewedById?: StringWithAggregatesFilter<"DocumentVerification"> | string
    comments?: StringNullableWithAggregatesFilter<"DocumentVerification"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"DocumentVerification"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"DocumentVerification"> | string | null
  }

  export type OnboardingProgressWhereInput = {
    AND?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    OR?: OnboardingProgressWhereInput[]
    NOT?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    id?: IntFilter<"OnboardingProgress"> | number
    userId?: StringFilter<"OnboardingProgress"> | string
    applicationId?: IntFilter<"OnboardingProgress"> | number
    currentPhase?: EnumPhaseFilter<"OnboardingProgress"> | $Enums.Phase
    startedAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"OnboardingProgress"> | Date | string | null
    status?: EnumOnboardingStatusFilter<"OnboardingProgress"> | $Enums.OnboardingStatus
    hireDate?: DateTimeFilter<"OnboardingProgress"> | Date | string
    hiringManagerId?: StringFilter<"OnboardingProgress"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    application?: XOR<JobApplicationScalarRelationFilter, JobApplicationWhereInput>
    hiringManager?: XOR<UserScalarRelationFilter, UserWhereInput>
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
  }

  export type OnboardingProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    applicationId?: SortOrder
    currentPhase?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    hireDate?: SortOrder
    hiringManagerId?: SortOrder
    user?: UserOrderByWithRelationInput
    application?: JobApplicationOrderByWithRelationInput
    hiringManager?: UserOrderByWithRelationInput
    contract?: ContractOrderByWithRelationInput
  }

  export type OnboardingProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: string
    applicationId?: number
    AND?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    OR?: OnboardingProgressWhereInput[]
    NOT?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    currentPhase?: EnumPhaseFilter<"OnboardingProgress"> | $Enums.Phase
    startedAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"OnboardingProgress"> | Date | string | null
    status?: EnumOnboardingStatusFilter<"OnboardingProgress"> | $Enums.OnboardingStatus
    hireDate?: DateTimeFilter<"OnboardingProgress"> | Date | string
    hiringManagerId?: StringFilter<"OnboardingProgress"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    application?: XOR<JobApplicationScalarRelationFilter, JobApplicationWhereInput>
    hiringManager?: XOR<UserScalarRelationFilter, UserWhereInput>
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
  }, "id" | "userId" | "applicationId">

  export type OnboardingProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    applicationId?: SortOrder
    currentPhase?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    hireDate?: SortOrder
    hiringManagerId?: SortOrder
    _count?: OnboardingProgressCountOrderByAggregateInput
    _avg?: OnboardingProgressAvgOrderByAggregateInput
    _max?: OnboardingProgressMaxOrderByAggregateInput
    _min?: OnboardingProgressMinOrderByAggregateInput
    _sum?: OnboardingProgressSumOrderByAggregateInput
  }

  export type OnboardingProgressScalarWhereWithAggregatesInput = {
    AND?: OnboardingProgressScalarWhereWithAggregatesInput | OnboardingProgressScalarWhereWithAggregatesInput[]
    OR?: OnboardingProgressScalarWhereWithAggregatesInput[]
    NOT?: OnboardingProgressScalarWhereWithAggregatesInput | OnboardingProgressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OnboardingProgress"> | number
    userId?: StringWithAggregatesFilter<"OnboardingProgress"> | string
    applicationId?: IntWithAggregatesFilter<"OnboardingProgress"> | number
    currentPhase?: EnumPhaseWithAggregatesFilter<"OnboardingProgress"> | $Enums.Phase
    startedAt?: DateTimeWithAggregatesFilter<"OnboardingProgress"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"OnboardingProgress"> | Date | string | null
    status?: EnumOnboardingStatusWithAggregatesFilter<"OnboardingProgress"> | $Enums.OnboardingStatus
    hireDate?: DateTimeWithAggregatesFilter<"OnboardingProgress"> | Date | string
    hiringManagerId?: StringWithAggregatesFilter<"OnboardingProgress"> | string
  }

  export type OnboardingInvitationWhereInput = {
    AND?: OnboardingInvitationWhereInput | OnboardingInvitationWhereInput[]
    OR?: OnboardingInvitationWhereInput[]
    NOT?: OnboardingInvitationWhereInput | OnboardingInvitationWhereInput[]
    id?: StringFilter<"OnboardingInvitation"> | string
    email?: StringFilter<"OnboardingInvitation"> | string
    token?: StringFilter<"OnboardingInvitation"> | string
    otp?: StringNullableFilter<"OnboardingInvitation"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"OnboardingInvitation"> | Date | string | null
    applicationId?: IntFilter<"OnboardingInvitation"> | number
    expiresAt?: DateTimeFilter<"OnboardingInvitation"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"OnboardingInvitation"> | Date | string | null
    lastAccessedAt?: DateTimeFilter<"OnboardingInvitation"> | Date | string
    sessionToken?: StringNullableFilter<"OnboardingInvitation"> | string | null
    sessionExpiresAt?: DateTimeNullableFilter<"OnboardingInvitation"> | Date | string | null
    createdAt?: DateTimeFilter<"OnboardingInvitation"> | Date | string
    application?: XOR<JobApplicationScalarRelationFilter, JobApplicationWhereInput>
  }

  export type OnboardingInvitationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    applicationId?: SortOrder
    expiresAt?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    lastAccessedAt?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    sessionExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    application?: JobApplicationOrderByWithRelationInput
  }

  export type OnboardingInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    applicationId?: number
    sessionToken?: string
    AND?: OnboardingInvitationWhereInput | OnboardingInvitationWhereInput[]
    OR?: OnboardingInvitationWhereInput[]
    NOT?: OnboardingInvitationWhereInput | OnboardingInvitationWhereInput[]
    email?: StringFilter<"OnboardingInvitation"> | string
    otp?: StringNullableFilter<"OnboardingInvitation"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"OnboardingInvitation"> | Date | string | null
    expiresAt?: DateTimeFilter<"OnboardingInvitation"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"OnboardingInvitation"> | Date | string | null
    lastAccessedAt?: DateTimeFilter<"OnboardingInvitation"> | Date | string
    sessionExpiresAt?: DateTimeNullableFilter<"OnboardingInvitation"> | Date | string | null
    createdAt?: DateTimeFilter<"OnboardingInvitation"> | Date | string
    application?: XOR<JobApplicationScalarRelationFilter, JobApplicationWhereInput>
  }, "id" | "token" | "applicationId" | "sessionToken">

  export type OnboardingInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    applicationId?: SortOrder
    expiresAt?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    lastAccessedAt?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    sessionExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OnboardingInvitationCountOrderByAggregateInput
    _avg?: OnboardingInvitationAvgOrderByAggregateInput
    _max?: OnboardingInvitationMaxOrderByAggregateInput
    _min?: OnboardingInvitationMinOrderByAggregateInput
    _sum?: OnboardingInvitationSumOrderByAggregateInput
  }

  export type OnboardingInvitationScalarWhereWithAggregatesInput = {
    AND?: OnboardingInvitationScalarWhereWithAggregatesInput | OnboardingInvitationScalarWhereWithAggregatesInput[]
    OR?: OnboardingInvitationScalarWhereWithAggregatesInput[]
    NOT?: OnboardingInvitationScalarWhereWithAggregatesInput | OnboardingInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OnboardingInvitation"> | string
    email?: StringWithAggregatesFilter<"OnboardingInvitation"> | string
    token?: StringWithAggregatesFilter<"OnboardingInvitation"> | string
    otp?: StringNullableWithAggregatesFilter<"OnboardingInvitation"> | string | null
    otpExpiresAt?: DateTimeNullableWithAggregatesFilter<"OnboardingInvitation"> | Date | string | null
    applicationId?: IntWithAggregatesFilter<"OnboardingInvitation"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"OnboardingInvitation"> | Date | string
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"OnboardingInvitation"> | Date | string | null
    lastAccessedAt?: DateTimeWithAggregatesFilter<"OnboardingInvitation"> | Date | string
    sessionToken?: StringNullableWithAggregatesFilter<"OnboardingInvitation"> | string | null
    sessionExpiresAt?: DateTimeNullableWithAggregatesFilter<"OnboardingInvitation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OnboardingInvitation"> | Date | string
  }

  export type EmergencyContactWhereInput = {
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    id?: IntFilter<"EmergencyContact"> | number
    userId?: StringFilter<"EmergencyContact"> | string
    fullName?: StringFilter<"EmergencyContact"> | string
    relationship?: StringFilter<"EmergencyContact"> | string
    primaryPhone?: StringFilter<"EmergencyContact"> | string
    secondaryPhone?: StringNullableFilter<"EmergencyContact"> | string | null
    email?: StringNullableFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmergencyContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    relationship?: SortOrder
    primaryPhone?: SortOrder
    secondaryPhone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmergencyContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    OR?: EmergencyContactWhereInput[]
    NOT?: EmergencyContactWhereInput | EmergencyContactWhereInput[]
    userId?: StringFilter<"EmergencyContact"> | string
    fullName?: StringFilter<"EmergencyContact"> | string
    relationship?: StringFilter<"EmergencyContact"> | string
    primaryPhone?: StringFilter<"EmergencyContact"> | string
    secondaryPhone?: StringNullableFilter<"EmergencyContact"> | string | null
    email?: StringNullableFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type EmergencyContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    relationship?: SortOrder
    primaryPhone?: SortOrder
    secondaryPhone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmergencyContactCountOrderByAggregateInput
    _avg?: EmergencyContactAvgOrderByAggregateInput
    _max?: EmergencyContactMaxOrderByAggregateInput
    _min?: EmergencyContactMinOrderByAggregateInput
    _sum?: EmergencyContactSumOrderByAggregateInput
  }

  export type EmergencyContactScalarWhereWithAggregatesInput = {
    AND?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    OR?: EmergencyContactScalarWhereWithAggregatesInput[]
    NOT?: EmergencyContactScalarWhereWithAggregatesInput | EmergencyContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmergencyContact"> | number
    userId?: StringWithAggregatesFilter<"EmergencyContact"> | string
    fullName?: StringWithAggregatesFilter<"EmergencyContact"> | string
    relationship?: StringWithAggregatesFilter<"EmergencyContact"> | string
    primaryPhone?: StringWithAggregatesFilter<"EmergencyContact"> | string
    secondaryPhone?: StringNullableWithAggregatesFilter<"EmergencyContact"> | string | null
    email?: StringNullableWithAggregatesFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmergencyContact"> | Date | string
  }

  export type DependentMemberWhereInput = {
    AND?: DependentMemberWhereInput | DependentMemberWhereInput[]
    OR?: DependentMemberWhereInput[]
    NOT?: DependentMemberWhereInput | DependentMemberWhereInput[]
    id?: IntFilter<"DependentMember"> | number
    userId?: StringFilter<"DependentMember"> | string
    firstName?: StringFilter<"DependentMember"> | string
    lastName?: StringFilter<"DependentMember"> | string
    middleName?: StringNullableFilter<"DependentMember"> | string | null
    birthDate?: DateTimeFilter<"DependentMember"> | Date | string
    relationship?: StringFilter<"DependentMember"> | string
    isStudent?: BoolFilter<"DependentMember"> | boolean
    createdAt?: DateTimeFilter<"DependentMember"> | Date | string
    updatedAt?: DateTimeFilter<"DependentMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Document?: DocumentListRelationFilter
  }

  export type DependentMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    relationship?: SortOrder
    isStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    Document?: DocumentOrderByRelationAggregateInput
  }

  export type DependentMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DependentMemberWhereInput | DependentMemberWhereInput[]
    OR?: DependentMemberWhereInput[]
    NOT?: DependentMemberWhereInput | DependentMemberWhereInput[]
    userId?: StringFilter<"DependentMember"> | string
    firstName?: StringFilter<"DependentMember"> | string
    lastName?: StringFilter<"DependentMember"> | string
    middleName?: StringNullableFilter<"DependentMember"> | string | null
    birthDate?: DateTimeFilter<"DependentMember"> | Date | string
    relationship?: StringFilter<"DependentMember"> | string
    isStudent?: BoolFilter<"DependentMember"> | boolean
    createdAt?: DateTimeFilter<"DependentMember"> | Date | string
    updatedAt?: DateTimeFilter<"DependentMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Document?: DocumentListRelationFilter
  }, "id">

  export type DependentMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    relationship?: SortOrder
    isStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DependentMemberCountOrderByAggregateInput
    _avg?: DependentMemberAvgOrderByAggregateInput
    _max?: DependentMemberMaxOrderByAggregateInput
    _min?: DependentMemberMinOrderByAggregateInput
    _sum?: DependentMemberSumOrderByAggregateInput
  }

  export type DependentMemberScalarWhereWithAggregatesInput = {
    AND?: DependentMemberScalarWhereWithAggregatesInput | DependentMemberScalarWhereWithAggregatesInput[]
    OR?: DependentMemberScalarWhereWithAggregatesInput[]
    NOT?: DependentMemberScalarWhereWithAggregatesInput | DependentMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DependentMember"> | number
    userId?: StringWithAggregatesFilter<"DependentMember"> | string
    firstName?: StringWithAggregatesFilter<"DependentMember"> | string
    lastName?: StringWithAggregatesFilter<"DependentMember"> | string
    middleName?: StringNullableWithAggregatesFilter<"DependentMember"> | string | null
    birthDate?: DateTimeWithAggregatesFilter<"DependentMember"> | Date | string
    relationship?: StringWithAggregatesFilter<"DependentMember"> | string
    isStudent?: BoolWithAggregatesFilter<"DependentMember"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DependentMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DependentMember"> | Date | string
  }

  export type UserEmailWhereInput = {
    AND?: UserEmailWhereInput | UserEmailWhereInput[]
    OR?: UserEmailWhereInput[]
    NOT?: UserEmailWhereInput | UserEmailWhereInput[]
    id?: IntFilter<"UserEmail"> | number
    userId?: StringFilter<"UserEmail"> | string
    email?: StringFilter<"UserEmail"> | string
    type?: EnumEmailTypeFilter<"UserEmail"> | $Enums.EmailType
    isPrimary?: BoolFilter<"UserEmail"> | boolean
    createdAt?: DateTimeFilter<"UserEmail"> | Date | string
    updatedAt?: DateTimeFilter<"UserEmail"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserEmailOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserEmailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserEmailWhereInput | UserEmailWhereInput[]
    OR?: UserEmailWhereInput[]
    NOT?: UserEmailWhereInput | UserEmailWhereInput[]
    userId?: StringFilter<"UserEmail"> | string
    type?: EnumEmailTypeFilter<"UserEmail"> | $Enums.EmailType
    isPrimary?: BoolFilter<"UserEmail"> | boolean
    createdAt?: DateTimeFilter<"UserEmail"> | Date | string
    updatedAt?: DateTimeFilter<"UserEmail"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "email">

  export type UserEmailOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserEmailCountOrderByAggregateInput
    _avg?: UserEmailAvgOrderByAggregateInput
    _max?: UserEmailMaxOrderByAggregateInput
    _min?: UserEmailMinOrderByAggregateInput
    _sum?: UserEmailSumOrderByAggregateInput
  }

  export type UserEmailScalarWhereWithAggregatesInput = {
    AND?: UserEmailScalarWhereWithAggregatesInput | UserEmailScalarWhereWithAggregatesInput[]
    OR?: UserEmailScalarWhereWithAggregatesInput[]
    NOT?: UserEmailScalarWhereWithAggregatesInput | UserEmailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserEmail"> | number
    userId?: StringWithAggregatesFilter<"UserEmail"> | string
    email?: StringWithAggregatesFilter<"UserEmail"> | string
    type?: EnumEmailTypeWithAggregatesFilter<"UserEmail"> | $Enums.EmailType
    isPrimary?: BoolWithAggregatesFilter<"UserEmail"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserEmail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserEmail"> | Date | string
  }

  export type UserPhoneWhereInput = {
    AND?: UserPhoneWhereInput | UserPhoneWhereInput[]
    OR?: UserPhoneWhereInput[]
    NOT?: UserPhoneWhereInput | UserPhoneWhereInput[]
    id?: IntFilter<"UserPhone"> | number
    userId?: StringFilter<"UserPhone"> | string
    phoneNumber?: StringFilter<"UserPhone"> | string
    countryCode?: StringFilter<"UserPhone"> | string
    type?: EnumPhoneTypeFilter<"UserPhone"> | $Enums.PhoneType
    isPrimary?: BoolFilter<"UserPhone"> | boolean
    createdAt?: DateTimeFilter<"UserPhone"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhone"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPhoneOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPhoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserPhoneWhereInput | UserPhoneWhereInput[]
    OR?: UserPhoneWhereInput[]
    NOT?: UserPhoneWhereInput | UserPhoneWhereInput[]
    userId?: StringFilter<"UserPhone"> | string
    phoneNumber?: StringFilter<"UserPhone"> | string
    countryCode?: StringFilter<"UserPhone"> | string
    type?: EnumPhoneTypeFilter<"UserPhone"> | $Enums.PhoneType
    isPrimary?: BoolFilter<"UserPhone"> | boolean
    createdAt?: DateTimeFilter<"UserPhone"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhone"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserPhoneOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPhoneCountOrderByAggregateInput
    _avg?: UserPhoneAvgOrderByAggregateInput
    _max?: UserPhoneMaxOrderByAggregateInput
    _min?: UserPhoneMinOrderByAggregateInput
    _sum?: UserPhoneSumOrderByAggregateInput
  }

  export type UserPhoneScalarWhereWithAggregatesInput = {
    AND?: UserPhoneScalarWhereWithAggregatesInput | UserPhoneScalarWhereWithAggregatesInput[]
    OR?: UserPhoneScalarWhereWithAggregatesInput[]
    NOT?: UserPhoneScalarWhereWithAggregatesInput | UserPhoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPhone"> | number
    userId?: StringWithAggregatesFilter<"UserPhone"> | string
    phoneNumber?: StringWithAggregatesFilter<"UserPhone"> | string
    countryCode?: StringWithAggregatesFilter<"UserPhone"> | string
    type?: EnumPhoneTypeWithAggregatesFilter<"UserPhone"> | $Enums.PhoneType
    isPrimary?: BoolWithAggregatesFilter<"UserPhone"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserPhone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPhone"> | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: IntFilter<"BankAccount"> | number
    personalInfoId?: IntFilter<"BankAccount"> | number
    bank?: EnumGreekBankFilter<"BankAccount"> | $Enums.GreekBank
    iban?: StringFilter<"BankAccount"> | string
    isPrimary?: BoolFilter<"BankAccount"> | boolean
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    personalInfo?: XOR<PersonalInfoScalarRelationFilter, PersonalInfoWhereInput>
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    bank?: SortOrder
    iban?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalInfo?: PersonalInfoOrderByWithRelationInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    iban?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    personalInfoId?: IntFilter<"BankAccount"> | number
    bank?: EnumGreekBankFilter<"BankAccount"> | $Enums.GreekBank
    isPrimary?: BoolFilter<"BankAccount"> | boolean
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    personalInfo?: XOR<PersonalInfoScalarRelationFilter, PersonalInfoWhereInput>
  }, "id" | "iban">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    bank?: SortOrder
    iban?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BankAccount"> | number
    personalInfoId?: IntWithAggregatesFilter<"BankAccount"> | number
    bank?: EnumGreekBankWithAggregatesFilter<"BankAccount"> | $Enums.GreekBank
    iban?: StringWithAggregatesFilter<"BankAccount"> | string
    isPrimary?: BoolWithAggregatesFilter<"BankAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: IntFilter<"Contract"> | number
    onboardingId?: IntFilter<"Contract"> | number
    draftKey?: StringNullableFilter<"Contract"> | string | null
    signedKey?: StringNullableFilter<"Contract"> | string | null
    uploadedAt?: DateTimeFilter<"Contract"> | Date | string
    signedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    status?: EnumContractStatusFilter<"Contract"> | $Enums.ContractStatus
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    onboarding?: XOR<OnboardingProgressScalarRelationFilter, OnboardingProgressWhereInput>
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    onboardingId?: SortOrder
    draftKey?: SortOrderInput | SortOrder
    signedKey?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    signedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    onboarding?: OnboardingProgressOrderByWithRelationInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    onboardingId?: number
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    draftKey?: StringNullableFilter<"Contract"> | string | null
    signedKey?: StringNullableFilter<"Contract"> | string | null
    uploadedAt?: DateTimeFilter<"Contract"> | Date | string
    signedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    status?: EnumContractStatusFilter<"Contract"> | $Enums.ContractStatus
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    onboarding?: XOR<OnboardingProgressScalarRelationFilter, OnboardingProgressWhereInput>
  }, "id" | "onboardingId">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    onboardingId?: SortOrder
    draftKey?: SortOrderInput | SortOrder
    signedKey?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    signedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contract"> | number
    onboardingId?: IntWithAggregatesFilter<"Contract"> | number
    draftKey?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    signedKey?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    signedAt?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    status?: EnumContractStatusWithAggregatesFilter<"Contract"> | $Enums.ContractStatus
    createdAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
  }

  export type LanguageSkillWhereInput = {
    AND?: LanguageSkillWhereInput | LanguageSkillWhereInput[]
    OR?: LanguageSkillWhereInput[]
    NOT?: LanguageSkillWhereInput | LanguageSkillWhereInput[]
    id?: IntFilter<"LanguageSkill"> | number
    personalInfoId?: IntFilter<"LanguageSkill"> | number
    language?: EnumLanguageFilter<"LanguageSkill"> | $Enums.Language
    proficiency?: EnumProficiencyFilter<"LanguageSkill"> | $Enums.Proficiency
    certificate?: StringNullableFilter<"LanguageSkill"> | string | null
    issueDate?: DateTimeNullableFilter<"LanguageSkill"> | Date | string | null
    createdAt?: DateTimeFilter<"LanguageSkill"> | Date | string
    updatedAt?: DateTimeFilter<"LanguageSkill"> | Date | string
    personalInfo?: XOR<PersonalInfoScalarRelationFilter, PersonalInfoWhereInput>
    documents?: DocumentListRelationFilter
  }

  export type LanguageSkillOrderByWithRelationInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    language?: SortOrder
    proficiency?: SortOrder
    certificate?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalInfo?: PersonalInfoOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type LanguageSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LanguageSkillWhereInput | LanguageSkillWhereInput[]
    OR?: LanguageSkillWhereInput[]
    NOT?: LanguageSkillWhereInput | LanguageSkillWhereInput[]
    personalInfoId?: IntFilter<"LanguageSkill"> | number
    language?: EnumLanguageFilter<"LanguageSkill"> | $Enums.Language
    proficiency?: EnumProficiencyFilter<"LanguageSkill"> | $Enums.Proficiency
    certificate?: StringNullableFilter<"LanguageSkill"> | string | null
    issueDate?: DateTimeNullableFilter<"LanguageSkill"> | Date | string | null
    createdAt?: DateTimeFilter<"LanguageSkill"> | Date | string
    updatedAt?: DateTimeFilter<"LanguageSkill"> | Date | string
    personalInfo?: XOR<PersonalInfoScalarRelationFilter, PersonalInfoWhereInput>
    documents?: DocumentListRelationFilter
  }, "id">

  export type LanguageSkillOrderByWithAggregationInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    language?: SortOrder
    proficiency?: SortOrder
    certificate?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LanguageSkillCountOrderByAggregateInput
    _avg?: LanguageSkillAvgOrderByAggregateInput
    _max?: LanguageSkillMaxOrderByAggregateInput
    _min?: LanguageSkillMinOrderByAggregateInput
    _sum?: LanguageSkillSumOrderByAggregateInput
  }

  export type LanguageSkillScalarWhereWithAggregatesInput = {
    AND?: LanguageSkillScalarWhereWithAggregatesInput | LanguageSkillScalarWhereWithAggregatesInput[]
    OR?: LanguageSkillScalarWhereWithAggregatesInput[]
    NOT?: LanguageSkillScalarWhereWithAggregatesInput | LanguageSkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LanguageSkill"> | number
    personalInfoId?: IntWithAggregatesFilter<"LanguageSkill"> | number
    language?: EnumLanguageWithAggregatesFilter<"LanguageSkill"> | $Enums.Language
    proficiency?: EnumProficiencyWithAggregatesFilter<"LanguageSkill"> | $Enums.Proficiency
    certificate?: StringNullableWithAggregatesFilter<"LanguageSkill"> | string | null
    issueDate?: DateTimeNullableWithAggregatesFilter<"LanguageSkill"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LanguageSkill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LanguageSkill"> | Date | string
  }

  export type RequestWhereInput = {
    AND?: RequestWhereInput | RequestWhereInput[]
    OR?: RequestWhereInput[]
    NOT?: RequestWhereInput | RequestWhereInput[]
    id?: StringFilter<"Request"> | string
    title?: StringFilter<"Request"> | string
    description?: StringFilter<"Request"> | string
    status?: EnumRequestStatusFilter<"Request"> | $Enums.RequestStatus
    requesterId?: StringFilter<"Request"> | string
    managerId?: StringFilter<"Request"> | string
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    requester?: XOR<UserScalarRelationFilter, UserWhereInput>
    manager?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: RequestAttachmentListRelationFilter
    RequestStatusHistory?: RequestStatusHistoryListRelationFilter
  }

  export type RequestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requester?: UserOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    attachments?: RequestAttachmentOrderByRelationAggregateInput
    RequestStatusHistory?: RequestStatusHistoryOrderByRelationAggregateInput
  }

  export type RequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequestWhereInput | RequestWhereInput[]
    OR?: RequestWhereInput[]
    NOT?: RequestWhereInput | RequestWhereInput[]
    title?: StringFilter<"Request"> | string
    description?: StringFilter<"Request"> | string
    status?: EnumRequestStatusFilter<"Request"> | $Enums.RequestStatus
    requesterId?: StringFilter<"Request"> | string
    managerId?: StringFilter<"Request"> | string
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    requester?: XOR<UserScalarRelationFilter, UserWhereInput>
    manager?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: RequestAttachmentListRelationFilter
    RequestStatusHistory?: RequestStatusHistoryListRelationFilter
  }, "id">

  export type RequestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequestCountOrderByAggregateInput
    _max?: RequestMaxOrderByAggregateInput
    _min?: RequestMinOrderByAggregateInput
  }

  export type RequestScalarWhereWithAggregatesInput = {
    AND?: RequestScalarWhereWithAggregatesInput | RequestScalarWhereWithAggregatesInput[]
    OR?: RequestScalarWhereWithAggregatesInput[]
    NOT?: RequestScalarWhereWithAggregatesInput | RequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Request"> | string
    title?: StringWithAggregatesFilter<"Request"> | string
    description?: StringWithAggregatesFilter<"Request"> | string
    status?: EnumRequestStatusWithAggregatesFilter<"Request"> | $Enums.RequestStatus
    requesterId?: StringWithAggregatesFilter<"Request"> | string
    managerId?: StringWithAggregatesFilter<"Request"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Request"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Request"> | Date | string
  }

  export type RequestStatusHistoryWhereInput = {
    AND?: RequestStatusHistoryWhereInput | RequestStatusHistoryWhereInput[]
    OR?: RequestStatusHistoryWhereInput[]
    NOT?: RequestStatusHistoryWhereInput | RequestStatusHistoryWhereInput[]
    id?: IntFilter<"RequestStatusHistory"> | number
    requestId?: StringFilter<"RequestStatusHistory"> | string
    status?: EnumRequestStatusFilter<"RequestStatusHistory"> | $Enums.RequestStatus
    comment?: StringNullableFilter<"RequestStatusHistory"> | string | null
    changedBy?: StringFilter<"RequestStatusHistory"> | string
    createdAt?: DateTimeFilter<"RequestStatusHistory"> | Date | string
    request?: XOR<RequestScalarRelationFilter, RequestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: StatusAttachmentListRelationFilter
  }

  export type RequestStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
    request?: RequestOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    attachments?: StatusAttachmentOrderByRelationAggregateInput
  }

  export type RequestStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RequestStatusHistoryWhereInput | RequestStatusHistoryWhereInput[]
    OR?: RequestStatusHistoryWhereInput[]
    NOT?: RequestStatusHistoryWhereInput | RequestStatusHistoryWhereInput[]
    requestId?: StringFilter<"RequestStatusHistory"> | string
    status?: EnumRequestStatusFilter<"RequestStatusHistory"> | $Enums.RequestStatus
    comment?: StringNullableFilter<"RequestStatusHistory"> | string | null
    changedBy?: StringFilter<"RequestStatusHistory"> | string
    createdAt?: DateTimeFilter<"RequestStatusHistory"> | Date | string
    request?: XOR<RequestScalarRelationFilter, RequestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: StatusAttachmentListRelationFilter
  }, "id">

  export type RequestStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
    _count?: RequestStatusHistoryCountOrderByAggregateInput
    _avg?: RequestStatusHistoryAvgOrderByAggregateInput
    _max?: RequestStatusHistoryMaxOrderByAggregateInput
    _min?: RequestStatusHistoryMinOrderByAggregateInput
    _sum?: RequestStatusHistorySumOrderByAggregateInput
  }

  export type RequestStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: RequestStatusHistoryScalarWhereWithAggregatesInput | RequestStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: RequestStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: RequestStatusHistoryScalarWhereWithAggregatesInput | RequestStatusHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RequestStatusHistory"> | number
    requestId?: StringWithAggregatesFilter<"RequestStatusHistory"> | string
    status?: EnumRequestStatusWithAggregatesFilter<"RequestStatusHistory"> | $Enums.RequestStatus
    comment?: StringNullableWithAggregatesFilter<"RequestStatusHistory"> | string | null
    changedBy?: StringWithAggregatesFilter<"RequestStatusHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RequestStatusHistory"> | Date | string
  }

  export type StatusAttachmentWhereInput = {
    AND?: StatusAttachmentWhereInput | StatusAttachmentWhereInput[]
    OR?: StatusAttachmentWhereInput[]
    NOT?: StatusAttachmentWhereInput | StatusAttachmentWhereInput[]
    id?: IntFilter<"StatusAttachment"> | number
    historyId?: IntFilter<"StatusAttachment"> | number
    fileName?: StringFilter<"StatusAttachment"> | string
    fileKey?: StringFilter<"StatusAttachment"> | string
    fileType?: StringFilter<"StatusAttachment"> | string
    uploadedAt?: DateTimeFilter<"StatusAttachment"> | Date | string
    history?: XOR<RequestStatusHistoryScalarRelationFilter, RequestStatusHistoryWhereInput>
  }

  export type StatusAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    historyId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
    history?: RequestStatusHistoryOrderByWithRelationInput
  }

  export type StatusAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StatusAttachmentWhereInput | StatusAttachmentWhereInput[]
    OR?: StatusAttachmentWhereInput[]
    NOT?: StatusAttachmentWhereInput | StatusAttachmentWhereInput[]
    historyId?: IntFilter<"StatusAttachment"> | number
    fileName?: StringFilter<"StatusAttachment"> | string
    fileKey?: StringFilter<"StatusAttachment"> | string
    fileType?: StringFilter<"StatusAttachment"> | string
    uploadedAt?: DateTimeFilter<"StatusAttachment"> | Date | string
    history?: XOR<RequestStatusHistoryScalarRelationFilter, RequestStatusHistoryWhereInput>
  }, "id">

  export type StatusAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    historyId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
    _count?: StatusAttachmentCountOrderByAggregateInput
    _avg?: StatusAttachmentAvgOrderByAggregateInput
    _max?: StatusAttachmentMaxOrderByAggregateInput
    _min?: StatusAttachmentMinOrderByAggregateInput
    _sum?: StatusAttachmentSumOrderByAggregateInput
  }

  export type StatusAttachmentScalarWhereWithAggregatesInput = {
    AND?: StatusAttachmentScalarWhereWithAggregatesInput | StatusAttachmentScalarWhereWithAggregatesInput[]
    OR?: StatusAttachmentScalarWhereWithAggregatesInput[]
    NOT?: StatusAttachmentScalarWhereWithAggregatesInput | StatusAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StatusAttachment"> | number
    historyId?: IntWithAggregatesFilter<"StatusAttachment"> | number
    fileName?: StringWithAggregatesFilter<"StatusAttachment"> | string
    fileKey?: StringWithAggregatesFilter<"StatusAttachment"> | string
    fileType?: StringWithAggregatesFilter<"StatusAttachment"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"StatusAttachment"> | Date | string
  }

  export type RequestAttachmentWhereInput = {
    AND?: RequestAttachmentWhereInput | RequestAttachmentWhereInput[]
    OR?: RequestAttachmentWhereInput[]
    NOT?: RequestAttachmentWhereInput | RequestAttachmentWhereInput[]
    id?: IntFilter<"RequestAttachment"> | number
    requestId?: StringFilter<"RequestAttachment"> | string
    fileName?: StringFilter<"RequestAttachment"> | string
    fileKey?: StringFilter<"RequestAttachment"> | string
    fileType?: StringFilter<"RequestAttachment"> | string
    uploadedAt?: DateTimeFilter<"RequestAttachment"> | Date | string
    request?: XOR<RequestScalarRelationFilter, RequestWhereInput>
  }

  export type RequestAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
    request?: RequestOrderByWithRelationInput
  }

  export type RequestAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RequestAttachmentWhereInput | RequestAttachmentWhereInput[]
    OR?: RequestAttachmentWhereInput[]
    NOT?: RequestAttachmentWhereInput | RequestAttachmentWhereInput[]
    requestId?: StringFilter<"RequestAttachment"> | string
    fileName?: StringFilter<"RequestAttachment"> | string
    fileKey?: StringFilter<"RequestAttachment"> | string
    fileType?: StringFilter<"RequestAttachment"> | string
    uploadedAt?: DateTimeFilter<"RequestAttachment"> | Date | string
    request?: XOR<RequestScalarRelationFilter, RequestWhereInput>
  }, "id">

  export type RequestAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
    _count?: RequestAttachmentCountOrderByAggregateInput
    _avg?: RequestAttachmentAvgOrderByAggregateInput
    _max?: RequestAttachmentMaxOrderByAggregateInput
    _min?: RequestAttachmentMinOrderByAggregateInput
    _sum?: RequestAttachmentSumOrderByAggregateInput
  }

  export type RequestAttachmentScalarWhereWithAggregatesInput = {
    AND?: RequestAttachmentScalarWhereWithAggregatesInput | RequestAttachmentScalarWhereWithAggregatesInput[]
    OR?: RequestAttachmentScalarWhereWithAggregatesInput[]
    NOT?: RequestAttachmentScalarWhereWithAggregatesInput | RequestAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RequestAttachment"> | number
    requestId?: StringWithAggregatesFilter<"RequestAttachment"> | string
    fileName?: StringWithAggregatesFilter<"RequestAttachment"> | string
    fileKey?: StringWithAggregatesFilter<"RequestAttachment"> | string
    fileType?: StringWithAggregatesFilter<"RequestAttachment"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"RequestAttachment"> | Date | string
  }

  export type LeaveRequestWhereInput = {
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    managerId?: StringFilter<"LeaveRequest"> | string
    type?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    duration?: FloatFilter<"LeaveRequest"> | number
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    manager?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: LeaveAttachmentListRelationFilter
    statusHistory?: LeaveStatusHistoryListRelationFilter
  }

  export type LeaveRequestOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    managerId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: UserOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    attachments?: LeaveAttachmentOrderByRelationAggregateInput
    statusHistory?: LeaveStatusHistoryOrderByRelationAggregateInput
  }

  export type LeaveRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    employeeId?: StringFilter<"LeaveRequest"> | string
    managerId?: StringFilter<"LeaveRequest"> | string
    type?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    duration?: FloatFilter<"LeaveRequest"> | number
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    manager?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: LeaveAttachmentListRelationFilter
    statusHistory?: LeaveStatusHistoryListRelationFilter
  }, "id">

  export type LeaveRequestOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    managerId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveRequestCountOrderByAggregateInput
    _avg?: LeaveRequestAvgOrderByAggregateInput
    _max?: LeaveRequestMaxOrderByAggregateInput
    _min?: LeaveRequestMinOrderByAggregateInput
    _sum?: LeaveRequestSumOrderByAggregateInput
  }

  export type LeaveRequestScalarWhereWithAggregatesInput = {
    AND?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    OR?: LeaveRequestScalarWhereWithAggregatesInput[]
    NOT?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveRequest"> | string
    employeeId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    managerId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    type?: EnumLeaveTypeWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    duration?: FloatWithAggregatesFilter<"LeaveRequest"> | number
    reason?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveStatus
    createdAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
  }

  export type LeaveAttachmentWhereInput = {
    AND?: LeaveAttachmentWhereInput | LeaveAttachmentWhereInput[]
    OR?: LeaveAttachmentWhereInput[]
    NOT?: LeaveAttachmentWhereInput | LeaveAttachmentWhereInput[]
    id?: IntFilter<"LeaveAttachment"> | number
    leaveId?: StringFilter<"LeaveAttachment"> | string
    fileName?: StringFilter<"LeaveAttachment"> | string
    fileKey?: StringFilter<"LeaveAttachment"> | string
    fileType?: StringFilter<"LeaveAttachment"> | string
    uploadedAt?: DateTimeFilter<"LeaveAttachment"> | Date | string
    leave?: XOR<LeaveRequestScalarRelationFilter, LeaveRequestWhereInput>
  }

  export type LeaveAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    leaveId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
    leave?: LeaveRequestOrderByWithRelationInput
  }

  export type LeaveAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaveAttachmentWhereInput | LeaveAttachmentWhereInput[]
    OR?: LeaveAttachmentWhereInput[]
    NOT?: LeaveAttachmentWhereInput | LeaveAttachmentWhereInput[]
    leaveId?: StringFilter<"LeaveAttachment"> | string
    fileName?: StringFilter<"LeaveAttachment"> | string
    fileKey?: StringFilter<"LeaveAttachment"> | string
    fileType?: StringFilter<"LeaveAttachment"> | string
    uploadedAt?: DateTimeFilter<"LeaveAttachment"> | Date | string
    leave?: XOR<LeaveRequestScalarRelationFilter, LeaveRequestWhereInput>
  }, "id">

  export type LeaveAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    leaveId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
    _count?: LeaveAttachmentCountOrderByAggregateInput
    _avg?: LeaveAttachmentAvgOrderByAggregateInput
    _max?: LeaveAttachmentMaxOrderByAggregateInput
    _min?: LeaveAttachmentMinOrderByAggregateInput
    _sum?: LeaveAttachmentSumOrderByAggregateInput
  }

  export type LeaveAttachmentScalarWhereWithAggregatesInput = {
    AND?: LeaveAttachmentScalarWhereWithAggregatesInput | LeaveAttachmentScalarWhereWithAggregatesInput[]
    OR?: LeaveAttachmentScalarWhereWithAggregatesInput[]
    NOT?: LeaveAttachmentScalarWhereWithAggregatesInput | LeaveAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaveAttachment"> | number
    leaveId?: StringWithAggregatesFilter<"LeaveAttachment"> | string
    fileName?: StringWithAggregatesFilter<"LeaveAttachment"> | string
    fileKey?: StringWithAggregatesFilter<"LeaveAttachment"> | string
    fileType?: StringWithAggregatesFilter<"LeaveAttachment"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"LeaveAttachment"> | Date | string
  }

  export type LeaveStatusHistoryWhereInput = {
    AND?: LeaveStatusHistoryWhereInput | LeaveStatusHistoryWhereInput[]
    OR?: LeaveStatusHistoryWhereInput[]
    NOT?: LeaveStatusHistoryWhereInput | LeaveStatusHistoryWhereInput[]
    id?: IntFilter<"LeaveStatusHistory"> | number
    leaveId?: StringFilter<"LeaveStatusHistory"> | string
    status?: EnumLeaveStatusFilter<"LeaveStatusHistory"> | $Enums.LeaveStatus
    comment?: StringNullableFilter<"LeaveStatusHistory"> | string | null
    changedById?: StringFilter<"LeaveStatusHistory"> | string
    createdAt?: DateTimeFilter<"LeaveStatusHistory"> | Date | string
    leave?: XOR<LeaveRequestScalarRelationFilter, LeaveRequestWhereInput>
    changedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: LeaveStatusAttachmentListRelationFilter
  }

  export type LeaveStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    leaveId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
    leave?: LeaveRequestOrderByWithRelationInput
    changedBy?: UserOrderByWithRelationInput
    attachments?: LeaveStatusAttachmentOrderByRelationAggregateInput
  }

  export type LeaveStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaveStatusHistoryWhereInput | LeaveStatusHistoryWhereInput[]
    OR?: LeaveStatusHistoryWhereInput[]
    NOT?: LeaveStatusHistoryWhereInput | LeaveStatusHistoryWhereInput[]
    leaveId?: StringFilter<"LeaveStatusHistory"> | string
    status?: EnumLeaveStatusFilter<"LeaveStatusHistory"> | $Enums.LeaveStatus
    comment?: StringNullableFilter<"LeaveStatusHistory"> | string | null
    changedById?: StringFilter<"LeaveStatusHistory"> | string
    createdAt?: DateTimeFilter<"LeaveStatusHistory"> | Date | string
    leave?: XOR<LeaveRequestScalarRelationFilter, LeaveRequestWhereInput>
    changedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: LeaveStatusAttachmentListRelationFilter
  }, "id">

  export type LeaveStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    leaveId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
    _count?: LeaveStatusHistoryCountOrderByAggregateInput
    _avg?: LeaveStatusHistoryAvgOrderByAggregateInput
    _max?: LeaveStatusHistoryMaxOrderByAggregateInput
    _min?: LeaveStatusHistoryMinOrderByAggregateInput
    _sum?: LeaveStatusHistorySumOrderByAggregateInput
  }

  export type LeaveStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: LeaveStatusHistoryScalarWhereWithAggregatesInput | LeaveStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: LeaveStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: LeaveStatusHistoryScalarWhereWithAggregatesInput | LeaveStatusHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaveStatusHistory"> | number
    leaveId?: StringWithAggregatesFilter<"LeaveStatusHistory"> | string
    status?: EnumLeaveStatusWithAggregatesFilter<"LeaveStatusHistory"> | $Enums.LeaveStatus
    comment?: StringNullableWithAggregatesFilter<"LeaveStatusHistory"> | string | null
    changedById?: StringWithAggregatesFilter<"LeaveStatusHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeaveStatusHistory"> | Date | string
  }

  export type LeaveStatusAttachmentWhereInput = {
    AND?: LeaveStatusAttachmentWhereInput | LeaveStatusAttachmentWhereInput[]
    OR?: LeaveStatusAttachmentWhereInput[]
    NOT?: LeaveStatusAttachmentWhereInput | LeaveStatusAttachmentWhereInput[]
    id?: IntFilter<"LeaveStatusAttachment"> | number
    historyId?: IntFilter<"LeaveStatusAttachment"> | number
    fileName?: StringFilter<"LeaveStatusAttachment"> | string
    fileKey?: StringFilter<"LeaveStatusAttachment"> | string
    fileType?: StringFilter<"LeaveStatusAttachment"> | string
    uploadedAt?: DateTimeFilter<"LeaveStatusAttachment"> | Date | string
    history?: XOR<LeaveStatusHistoryScalarRelationFilter, LeaveStatusHistoryWhereInput>
  }

  export type LeaveStatusAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    historyId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
    history?: LeaveStatusHistoryOrderByWithRelationInput
  }

  export type LeaveStatusAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaveStatusAttachmentWhereInput | LeaveStatusAttachmentWhereInput[]
    OR?: LeaveStatusAttachmentWhereInput[]
    NOT?: LeaveStatusAttachmentWhereInput | LeaveStatusAttachmentWhereInput[]
    historyId?: IntFilter<"LeaveStatusAttachment"> | number
    fileName?: StringFilter<"LeaveStatusAttachment"> | string
    fileKey?: StringFilter<"LeaveStatusAttachment"> | string
    fileType?: StringFilter<"LeaveStatusAttachment"> | string
    uploadedAt?: DateTimeFilter<"LeaveStatusAttachment"> | Date | string
    history?: XOR<LeaveStatusHistoryScalarRelationFilter, LeaveStatusHistoryWhereInput>
  }, "id">

  export type LeaveStatusAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    historyId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
    _count?: LeaveStatusAttachmentCountOrderByAggregateInput
    _avg?: LeaveStatusAttachmentAvgOrderByAggregateInput
    _max?: LeaveStatusAttachmentMaxOrderByAggregateInput
    _min?: LeaveStatusAttachmentMinOrderByAggregateInput
    _sum?: LeaveStatusAttachmentSumOrderByAggregateInput
  }

  export type LeaveStatusAttachmentScalarWhereWithAggregatesInput = {
    AND?: LeaveStatusAttachmentScalarWhereWithAggregatesInput | LeaveStatusAttachmentScalarWhereWithAggregatesInput[]
    OR?: LeaveStatusAttachmentScalarWhereWithAggregatesInput[]
    NOT?: LeaveStatusAttachmentScalarWhereWithAggregatesInput | LeaveStatusAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaveStatusAttachment"> | number
    historyId?: IntWithAggregatesFilter<"LeaveStatusAttachment"> | number
    fileName?: StringWithAggregatesFilter<"LeaveStatusAttachment"> | string
    fileKey?: StringWithAggregatesFilter<"LeaveStatusAttachment"> | string
    fileType?: StringWithAggregatesFilter<"LeaveStatusAttachment"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"LeaveStatusAttachment"> | Date | string
  }

  export type HolidayWhereInput = {
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    id?: StringFilter<"Holiday"> | string
    name?: StringFilter<"Holiday"> | string
    date?: DateTimeFilter<"Holiday"> | Date | string
    isActive?: BoolFilter<"Holiday"> | boolean
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
  }

  export type HolidayOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date?: Date | string
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    name?: StringFilter<"Holiday"> | string
    isActive?: BoolFilter<"Holiday"> | boolean
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
  }, "id" | "date">

  export type HolidayOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HolidayCountOrderByAggregateInput
    _max?: HolidayMaxOrderByAggregateInput
    _min?: HolidayMinOrderByAggregateInput
  }

  export type HolidayScalarWhereWithAggregatesInput = {
    AND?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    OR?: HolidayScalarWhereWithAggregatesInput[]
    NOT?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Holiday"> | string
    name?: StringWithAggregatesFilter<"Holiday"> | string
    date?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Holiday"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    users?: UserListRelationFilter
    JobListing?: JobListingListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    JobListing?: JobListingOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    description?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    users?: UserListRelationFilter
    JobListing?: JobListingListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    city?: StringFilter<"Location"> | string
    region?: StringFilter<"Location"> | string
    postalCode?: StringFilter<"Location"> | string
    country?: StringFilter<"Location"> | string
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    users?: UserListRelationFilter
    JobListing?: JobListingListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    JobListing?: JobListingOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_city?: LocationNameCityCompoundUniqueInput
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    city?: StringFilter<"Location"> | string
    region?: StringFilter<"Location"> | string
    postalCode?: StringFilter<"Location"> | string
    country?: StringFilter<"Location"> | string
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    users?: UserListRelationFilter
    JobListing?: JobListingListRelationFilter
  }, "id" | "name_city">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    address?: StringWithAggregatesFilter<"Location"> | string
    city?: StringWithAggregatesFilter<"Location"> | string
    region?: StringWithAggregatesFilter<"Location"> | string
    postalCode?: StringWithAggregatesFilter<"Location"> | string
    country?: StringWithAggregatesFilter<"Location"> | string
    isActive?: BoolWithAggregatesFilter<"Location"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type PositionWhereInput = {
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    id?: StringFilter<"Position"> | string
    title?: StringFilter<"Position"> | string
    code?: StringFilter<"Position"> | string
    isActive?: BoolFilter<"Position"> | boolean
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    users?: UserListRelationFilter
    jobListings?: JobListingListRelationFilter
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    jobListings?: JobListingOrderByRelationAggregateInput
  }

  export type PositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    title?: StringFilter<"Position"> | string
    isActive?: BoolFilter<"Position"> | boolean
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    users?: UserListRelationFilter
    jobListings?: JobListingListRelationFilter
  }, "id" | "code">

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PositionCountOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    OR?: PositionScalarWhereWithAggregatesInput[]
    NOT?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Position"> | string
    title?: StringWithAggregatesFilter<"Position"> | string
    code?: StringWithAggregatesFilter<"Position"> | string
    isActive?: BoolWithAggregatesFilter<"Position"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    vatNumber?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    status?: EnumClientStatusFilter<"Client"> | $Enums.ClientStatus
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    projects?: ProjectListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    vatNumber?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vatNumber?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    status?: EnumClientStatusFilter<"Client"> | $Enums.ClientStatus
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    projects?: ProjectListRelationFilter
  }, "id" | "vatNumber">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    vatNumber?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    vatNumber?: StringWithAggregatesFilter<"Client"> | string
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    status?: EnumClientStatusWithAggregatesFilter<"Client"> | $Enums.ClientStatus
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    clientId?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    managerId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    manager?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ProjectMemberListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    clientId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    members?: ProjectMemberOrderByRelationAggregateInput
    timeEntries?: TimeEntryOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    clientId?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    managerId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    manager?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ProjectMemberListRelationFilter
    timeEntries?: TimeEntryListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    clientId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    clientId?: StringWithAggregatesFilter<"Project"> | string
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    managerId?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectMemberRoleFilter<"ProjectMember"> | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    leftAt?: DateTimeNullableFilter<"ProjectMember"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_userId?: ProjectMemberProjectIdUserIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectMemberRoleFilter<"ProjectMember"> | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    leftAt?: DateTimeNullableFilter<"ProjectMember"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMember"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMember"> | string
    userId?: StringWithAggregatesFilter<"ProjectMember"> | string
    role?: EnumProjectMemberRoleWithAggregatesFilter<"ProjectMember"> | $Enums.ProjectMemberRole
    joinedAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
    leftAt?: DateTimeNullableWithAggregatesFilter<"ProjectMember"> | Date | string | null
  }

  export type TimeEntryWhereInput = {
    AND?: TimeEntryWhereInput | TimeEntryWhereInput[]
    OR?: TimeEntryWhereInput[]
    NOT?: TimeEntryWhereInput | TimeEntryWhereInput[]
    id?: StringFilter<"TimeEntry"> | string
    projectId?: StringFilter<"TimeEntry"> | string
    userId?: StringFilter<"TimeEntry"> | string
    description?: StringFilter<"TimeEntry"> | string
    startTime?: DateTimeFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    duration?: IntFilter<"TimeEntry"> | number
    status?: EnumTimeEntryStatusFilter<"TimeEntry"> | $Enums.TimeEntryStatus
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TimeEntryOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TimeEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeEntryWhereInput | TimeEntryWhereInput[]
    OR?: TimeEntryWhereInput[]
    NOT?: TimeEntryWhereInput | TimeEntryWhereInput[]
    projectId?: StringFilter<"TimeEntry"> | string
    userId?: StringFilter<"TimeEntry"> | string
    description?: StringFilter<"TimeEntry"> | string
    startTime?: DateTimeFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    duration?: IntFilter<"TimeEntry"> | number
    status?: EnumTimeEntryStatusFilter<"TimeEntry"> | $Enums.TimeEntryStatus
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TimeEntryOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimeEntryCountOrderByAggregateInput
    _avg?: TimeEntryAvgOrderByAggregateInput
    _max?: TimeEntryMaxOrderByAggregateInput
    _min?: TimeEntryMinOrderByAggregateInput
    _sum?: TimeEntrySumOrderByAggregateInput
  }

  export type TimeEntryScalarWhereWithAggregatesInput = {
    AND?: TimeEntryScalarWhereWithAggregatesInput | TimeEntryScalarWhereWithAggregatesInput[]
    OR?: TimeEntryScalarWhereWithAggregatesInput[]
    NOT?: TimeEntryScalarWhereWithAggregatesInput | TimeEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeEntry"> | string
    projectId?: StringWithAggregatesFilter<"TimeEntry"> | string
    userId?: StringWithAggregatesFilter<"TimeEntry"> | string
    description?: StringWithAggregatesFilter<"TimeEntry"> | string
    startTime?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"TimeEntry"> | Date | string | null
    duration?: IntWithAggregatesFilter<"TimeEntry"> | number
    status?: EnumTimeEntryStatusWithAggregatesFilter<"TimeEntry"> | $Enums.TimeEntryStatus
    createdAt?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    publishedAt?: DateTimeFilter<"Announcement"> | Date | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    changedBy?: StringFilter<"Announcement"> | string
    publishedBy?: StringFilter<"Announcement"> | string
    changedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    publishedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    changedBy?: SortOrder
    publishedBy?: SortOrder
    changedByUser?: UserOrderByWithRelationInput
    publishedByUser?: UserOrderByWithRelationInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    publishedAt?: DateTimeFilter<"Announcement"> | Date | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    changedBy?: StringFilter<"Announcement"> | string
    publishedBy?: StringFilter<"Announcement"> | string
    changedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    publishedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    changedBy?: SortOrder
    publishedBy?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    content?: StringWithAggregatesFilter<"Announcement"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    changedBy?: StringWithAggregatesFilter<"Announcement"> | string
    publishedBy?: StringWithAggregatesFilter<"Announcement"> | string
  }

  export type TimeScheduleWhereInput = {
    AND?: TimeScheduleWhereInput | TimeScheduleWhereInput[]
    OR?: TimeScheduleWhereInput[]
    NOT?: TimeScheduleWhereInput | TimeScheduleWhereInput[]
    id?: StringFilter<"TimeSchedule"> | string
    name?: StringFilter<"TimeSchedule"> | string
    startTime?: StringFilter<"TimeSchedule"> | string
    endTime?: StringFilter<"TimeSchedule"> | string
    isActive?: BoolFilter<"TimeSchedule"> | boolean
    createdAt?: DateTimeFilter<"TimeSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSchedule"> | Date | string
    shifts?: ShiftEntryListRelationFilter
  }

  export type TimeScheduleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shifts?: ShiftEntryOrderByRelationAggregateInput
  }

  export type TimeScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_startTime_endTime?: TimeScheduleNameStartTimeEndTimeCompoundUniqueInput
    AND?: TimeScheduleWhereInput | TimeScheduleWhereInput[]
    OR?: TimeScheduleWhereInput[]
    NOT?: TimeScheduleWhereInput | TimeScheduleWhereInput[]
    name?: StringFilter<"TimeSchedule"> | string
    startTime?: StringFilter<"TimeSchedule"> | string
    endTime?: StringFilter<"TimeSchedule"> | string
    isActive?: BoolFilter<"TimeSchedule"> | boolean
    createdAt?: DateTimeFilter<"TimeSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSchedule"> | Date | string
    shifts?: ShiftEntryListRelationFilter
  }, "id" | "name_startTime_endTime">

  export type TimeScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimeScheduleCountOrderByAggregateInput
    _max?: TimeScheduleMaxOrderByAggregateInput
    _min?: TimeScheduleMinOrderByAggregateInput
  }

  export type TimeScheduleScalarWhereWithAggregatesInput = {
    AND?: TimeScheduleScalarWhereWithAggregatesInput | TimeScheduleScalarWhereWithAggregatesInput[]
    OR?: TimeScheduleScalarWhereWithAggregatesInput[]
    NOT?: TimeScheduleScalarWhereWithAggregatesInput | TimeScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeSchedule"> | string
    name?: StringWithAggregatesFilter<"TimeSchedule"> | string
    startTime?: StringWithAggregatesFilter<"TimeSchedule"> | string
    endTime?: StringWithAggregatesFilter<"TimeSchedule"> | string
    isActive?: BoolWithAggregatesFilter<"TimeSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TimeSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeSchedule"> | Date | string
  }

  export type ShiftEntryWhereInput = {
    AND?: ShiftEntryWhereInput | ShiftEntryWhereInput[]
    OR?: ShiftEntryWhereInput[]
    NOT?: ShiftEntryWhereInput | ShiftEntryWhereInput[]
    id?: StringFilter<"ShiftEntry"> | string
    userId?: StringFilter<"ShiftEntry"> | string
    scheduleId?: StringFilter<"ShiftEntry"> | string
    date?: DateTimeFilter<"ShiftEntry"> | Date | string
    status?: EnumShiftStatusFilter<"ShiftEntry"> | $Enums.ShiftStatus
    isNightShift?: BoolFilter<"ShiftEntry"> | boolean
    workplaceType?: EnumWorkplaceTypeFilter<"ShiftEntry"> | $Enums.WorkplaceType
    createdAt?: DateTimeFilter<"ShiftEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedule?: XOR<TimeScheduleScalarRelationFilter, TimeScheduleWhereInput>
  }

  export type ShiftEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    isNightShift?: SortOrder
    workplaceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    schedule?: TimeScheduleOrderByWithRelationInput
  }

  export type ShiftEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_scheduleId_date?: ShiftEntryUserIdScheduleIdDateCompoundUniqueInput
    AND?: ShiftEntryWhereInput | ShiftEntryWhereInput[]
    OR?: ShiftEntryWhereInput[]
    NOT?: ShiftEntryWhereInput | ShiftEntryWhereInput[]
    userId?: StringFilter<"ShiftEntry"> | string
    scheduleId?: StringFilter<"ShiftEntry"> | string
    date?: DateTimeFilter<"ShiftEntry"> | Date | string
    status?: EnumShiftStatusFilter<"ShiftEntry"> | $Enums.ShiftStatus
    isNightShift?: BoolFilter<"ShiftEntry"> | boolean
    workplaceType?: EnumWorkplaceTypeFilter<"ShiftEntry"> | $Enums.WorkplaceType
    createdAt?: DateTimeFilter<"ShiftEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedule?: XOR<TimeScheduleScalarRelationFilter, TimeScheduleWhereInput>
  }, "id" | "userId_scheduleId_date">

  export type ShiftEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    isNightShift?: SortOrder
    workplaceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftEntryCountOrderByAggregateInput
    _max?: ShiftEntryMaxOrderByAggregateInput
    _min?: ShiftEntryMinOrderByAggregateInput
  }

  export type ShiftEntryScalarWhereWithAggregatesInput = {
    AND?: ShiftEntryScalarWhereWithAggregatesInput | ShiftEntryScalarWhereWithAggregatesInput[]
    OR?: ShiftEntryScalarWhereWithAggregatesInput[]
    NOT?: ShiftEntryScalarWhereWithAggregatesInput | ShiftEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShiftEntry"> | string
    userId?: StringWithAggregatesFilter<"ShiftEntry"> | string
    scheduleId?: StringWithAggregatesFilter<"ShiftEntry"> | string
    date?: DateTimeWithAggregatesFilter<"ShiftEntry"> | Date | string
    status?: EnumShiftStatusWithAggregatesFilter<"ShiftEntry"> | $Enums.ShiftStatus
    isNightShift?: BoolWithAggregatesFilter<"ShiftEntry"> | boolean
    workplaceType?: EnumWorkplaceTypeWithAggregatesFilter<"ShiftEntry"> | $Enums.WorkplaceType
    createdAt?: DateTimeWithAggregatesFilter<"ShiftEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShiftEntry"> | Date | string
  }

  export type CompanySettingsWhereInput = {
    AND?: CompanySettingsWhereInput | CompanySettingsWhereInput[]
    OR?: CompanySettingsWhereInput[]
    NOT?: CompanySettingsWhereInput | CompanySettingsWhereInput[]
    id?: IntFilter<"CompanySettings"> | number
    name?: StringFilter<"CompanySettings"> | string
    logoUrl?: StringNullableFilter<"CompanySettings"> | string | null
    url?: StringNullableFilter<"CompanySettings"> | string | null
    address?: StringFilter<"CompanySettings"> | string
    postalCode?: StringFilter<"CompanySettings"> | string
    city?: StringFilter<"CompanySettings"> | string
    region?: StringFilter<"CompanySettings"> | string
    country?: StringFilter<"CompanySettings"> | string
    phone?: StringNullableFilter<"CompanySettings"> | string | null
    email?: StringNullableFilter<"CompanySettings"> | string | null
    timezone?: StringFilter<"CompanySettings"> | string
    createdAt?: DateTimeFilter<"CompanySettings"> | Date | string
    updatedAt?: DateTimeFilter<"CompanySettings"> | Date | string
  }

  export type CompanySettingsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    address?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanySettingsWhereInput | CompanySettingsWhereInput[]
    OR?: CompanySettingsWhereInput[]
    NOT?: CompanySettingsWhereInput | CompanySettingsWhereInput[]
    name?: StringFilter<"CompanySettings"> | string
    logoUrl?: StringNullableFilter<"CompanySettings"> | string | null
    url?: StringNullableFilter<"CompanySettings"> | string | null
    address?: StringFilter<"CompanySettings"> | string
    postalCode?: StringFilter<"CompanySettings"> | string
    city?: StringFilter<"CompanySettings"> | string
    region?: StringFilter<"CompanySettings"> | string
    country?: StringFilter<"CompanySettings"> | string
    phone?: StringNullableFilter<"CompanySettings"> | string | null
    email?: StringNullableFilter<"CompanySettings"> | string | null
    timezone?: StringFilter<"CompanySettings"> | string
    createdAt?: DateTimeFilter<"CompanySettings"> | Date | string
    updatedAt?: DateTimeFilter<"CompanySettings"> | Date | string
  }, "id">

  export type CompanySettingsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    address?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanySettingsCountOrderByAggregateInput
    _avg?: CompanySettingsAvgOrderByAggregateInput
    _max?: CompanySettingsMaxOrderByAggregateInput
    _min?: CompanySettingsMinOrderByAggregateInput
    _sum?: CompanySettingsSumOrderByAggregateInput
  }

  export type CompanySettingsScalarWhereWithAggregatesInput = {
    AND?: CompanySettingsScalarWhereWithAggregatesInput | CompanySettingsScalarWhereWithAggregatesInput[]
    OR?: CompanySettingsScalarWhereWithAggregatesInput[]
    NOT?: CompanySettingsScalarWhereWithAggregatesInput | CompanySettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanySettings"> | number
    name?: StringWithAggregatesFilter<"CompanySettings"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    url?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    address?: StringWithAggregatesFilter<"CompanySettings"> | string
    postalCode?: StringWithAggregatesFilter<"CompanySettings"> | string
    city?: StringWithAggregatesFilter<"CompanySettings"> | string
    region?: StringWithAggregatesFilter<"CompanySettings"> | string
    country?: StringWithAggregatesFilter<"CompanySettings"> | string
    phone?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    email?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    timezone?: StringWithAggregatesFilter<"CompanySettings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanySettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanySettings"> | Date | string
  }

  export type CareerSettingsWhereInput = {
    AND?: CareerSettingsWhereInput | CareerSettingsWhereInput[]
    OR?: CareerSettingsWhereInput[]
    NOT?: CareerSettingsWhereInput | CareerSettingsWhereInput[]
    id?: IntFilter<"CareerSettings"> | number
    logoUrl?: StringNullableFilter<"CareerSettings"> | string | null
    headerButtonText?: StringNullableFilter<"CareerSettings"> | string | null
    headerButtonUrl?: StringNullableFilter<"CareerSettings"> | string | null
    headerButtonBgColor?: StringNullableFilter<"CareerSettings"> | string | null
    headerButtonTextColor?: StringNullableFilter<"CareerSettings"> | string | null
    bannerText?: StringNullableFilter<"CareerSettings"> | string | null
    bannerBgColor?: StringNullableFilter<"CareerSettings"> | string | null
    bannerTextColor?: StringNullableFilter<"CareerSettings"> | string | null
    showCvBanner?: BoolFilter<"CareerSettings"> | boolean
    cvBannerUrl?: StringNullableFilter<"CareerSettings"> | string | null
    cvBannerTitle?: StringNullableFilter<"CareerSettings"> | string | null
    cvBannerSubtitle?: StringNullableFilter<"CareerSettings"> | string | null
    createdAt?: DateTimeFilter<"CareerSettings"> | Date | string
    updatedAt?: DateTimeFilter<"CareerSettings"> | Date | string
  }

  export type CareerSettingsOrderByWithRelationInput = {
    id?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    headerButtonText?: SortOrderInput | SortOrder
    headerButtonUrl?: SortOrderInput | SortOrder
    headerButtonBgColor?: SortOrderInput | SortOrder
    headerButtonTextColor?: SortOrderInput | SortOrder
    bannerText?: SortOrderInput | SortOrder
    bannerBgColor?: SortOrderInput | SortOrder
    bannerTextColor?: SortOrderInput | SortOrder
    showCvBanner?: SortOrder
    cvBannerUrl?: SortOrderInput | SortOrder
    cvBannerTitle?: SortOrderInput | SortOrder
    cvBannerSubtitle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CareerSettingsWhereInput | CareerSettingsWhereInput[]
    OR?: CareerSettingsWhereInput[]
    NOT?: CareerSettingsWhereInput | CareerSettingsWhereInput[]
    logoUrl?: StringNullableFilter<"CareerSettings"> | string | null
    headerButtonText?: StringNullableFilter<"CareerSettings"> | string | null
    headerButtonUrl?: StringNullableFilter<"CareerSettings"> | string | null
    headerButtonBgColor?: StringNullableFilter<"CareerSettings"> | string | null
    headerButtonTextColor?: StringNullableFilter<"CareerSettings"> | string | null
    bannerText?: StringNullableFilter<"CareerSettings"> | string | null
    bannerBgColor?: StringNullableFilter<"CareerSettings"> | string | null
    bannerTextColor?: StringNullableFilter<"CareerSettings"> | string | null
    showCvBanner?: BoolFilter<"CareerSettings"> | boolean
    cvBannerUrl?: StringNullableFilter<"CareerSettings"> | string | null
    cvBannerTitle?: StringNullableFilter<"CareerSettings"> | string | null
    cvBannerSubtitle?: StringNullableFilter<"CareerSettings"> | string | null
    createdAt?: DateTimeFilter<"CareerSettings"> | Date | string
    updatedAt?: DateTimeFilter<"CareerSettings"> | Date | string
  }, "id">

  export type CareerSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    headerButtonText?: SortOrderInput | SortOrder
    headerButtonUrl?: SortOrderInput | SortOrder
    headerButtonBgColor?: SortOrderInput | SortOrder
    headerButtonTextColor?: SortOrderInput | SortOrder
    bannerText?: SortOrderInput | SortOrder
    bannerBgColor?: SortOrderInput | SortOrder
    bannerTextColor?: SortOrderInput | SortOrder
    showCvBanner?: SortOrder
    cvBannerUrl?: SortOrderInput | SortOrder
    cvBannerTitle?: SortOrderInput | SortOrder
    cvBannerSubtitle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CareerSettingsCountOrderByAggregateInput
    _avg?: CareerSettingsAvgOrderByAggregateInput
    _max?: CareerSettingsMaxOrderByAggregateInput
    _min?: CareerSettingsMinOrderByAggregateInput
    _sum?: CareerSettingsSumOrderByAggregateInput
  }

  export type CareerSettingsScalarWhereWithAggregatesInput = {
    AND?: CareerSettingsScalarWhereWithAggregatesInput | CareerSettingsScalarWhereWithAggregatesInput[]
    OR?: CareerSettingsScalarWhereWithAggregatesInput[]
    NOT?: CareerSettingsScalarWhereWithAggregatesInput | CareerSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CareerSettings"> | number
    logoUrl?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    headerButtonText?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    headerButtonUrl?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    headerButtonBgColor?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    headerButtonTextColor?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    bannerText?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    bannerBgColor?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    bannerTextColor?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    showCvBanner?: BoolWithAggregatesFilter<"CareerSettings"> | boolean
    cvBannerUrl?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    cvBannerTitle?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    cvBannerSubtitle?: StringNullableWithAggregatesFilter<"CareerSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CareerSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CareerSettings"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserStatusHistoryCreateInput = {
    status: $Enums.UserStatus
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStatusHistoryInput
    changedBy: UserCreateNestedOneWithoutStatusChangesByInput
  }

  export type UserStatusHistoryUncheckedCreateInput = {
    id?: number
    userId: string
    status: $Enums.UserStatus
    comment?: string | null
    createdAt?: Date | string
    changedById: string
  }

  export type UserStatusHistoryUpdateInput = {
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStatusHistoryNestedInput
    changedBy?: UserUpdateOneRequiredWithoutStatusChangesByNestedInput
  }

  export type UserStatusHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedById?: StringFieldUpdateOperationsInput | string
  }

  export type UserStatusHistoryCreateManyInput = {
    id?: number
    userId: string
    status: $Enums.UserStatus
    comment?: string | null
    createdAt?: Date | string
    changedById: string
  }

  export type UserStatusHistoryUpdateManyMutationInput = {
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatusHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedById?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateNoteCreateInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    candidate: CandidateCreateNestedOneWithoutNotesInput
    createdBy: UserCreateNestedOneWithoutCandidateNotesInput
  }

  export type CandidateNoteUncheckedCreateInput = {
    id?: number
    candidateId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type CandidateNoteUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidate?: CandidateUpdateOneRequiredWithoutNotesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCandidateNotesNestedInput
  }

  export type CandidateNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateNoteCreateManyInput = {
    id?: number
    candidateId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type CandidateNoteUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type JobListingCreateInput = {
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutJobListingInput
    location?: LocationCreateNestedOneWithoutJobListingInput
    applications?: JobApplicationCreateNestedManyWithoutJobListingInput
    position?: PositionCreateNestedOneWithoutJobListingsInput
  }

  export type JobListingUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    departmentId?: string | null
    locationId?: string | null
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
    applications?: JobApplicationUncheckedCreateNestedManyWithoutJobListingInput
  }

  export type JobListingUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutJobListingNestedInput
    location?: LocationUpdateOneWithoutJobListingNestedInput
    applications?: JobApplicationUpdateManyWithoutJobListingNestedInput
    position?: PositionUpdateOneWithoutJobListingsNestedInput
  }

  export type JobListingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    applications?: JobApplicationUncheckedUpdateManyWithoutJobListingNestedInput
  }

  export type JobListingCreateManyInput = {
    id?: number
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    departmentId?: string | null
    locationId?: string | null
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
  }

  export type JobListingUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobListingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CandidateCreateInput = {
    id?: string
    name: string
    surname: string
    email: string
    phone: string
    linkedin?: string | null
    github?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: JobApplicationCreateNestedManyWithoutCandidateInput
    notes?: CandidateNoteCreateNestedManyWithoutCandidateInput
  }

  export type CandidateUncheckedCreateInput = {
    id?: string
    name: string
    surname: string
    email: string
    phone: string
    linkedin?: string | null
    github?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: JobApplicationUncheckedCreateNestedManyWithoutCandidateInput
    notes?: CandidateNoteUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type CandidateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: JobApplicationUpdateManyWithoutCandidateNestedInput
    notes?: CandidateNoteUpdateManyWithoutCandidateNestedInput
  }

  export type CandidateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: JobApplicationUncheckedUpdateManyWithoutCandidateNestedInput
    notes?: CandidateNoteUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type CandidateCreateManyInput = {
    id?: string
    name: string
    surname: string
    email: string
    phone: string
    linkedin?: string | null
    github?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CandidateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationCreateInput = {
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    candidate: CandidateCreateNestedOneWithoutApplicationsInput
    jobListing: JobListingCreateNestedOneWithoutApplicationsInput
    history?: JobApplicationHistoryCreateNestedManyWithoutApplicationInput
    cvAnalysis?: CvAnalysisCreateNestedOneWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateInput = {
    id?: number
    candidateId: string
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    jobListingId: number
    createdAt?: Date | string
    history?: JobApplicationHistoryUncheckedCreateNestedManyWithoutApplicationInput
    cvAnalysis?: CvAnalysisUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationUpdateInput = {
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidate?: CandidateUpdateOneRequiredWithoutApplicationsNestedInput
    jobListing?: JobListingUpdateOneRequiredWithoutApplicationsNestedInput
    history?: JobApplicationHistoryUpdateManyWithoutApplicationNestedInput
    cvAnalysis?: CvAnalysisUpdateOneWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    jobListingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: JobApplicationHistoryUncheckedUpdateManyWithoutApplicationNestedInput
    cvAnalysis?: CvAnalysisUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationCreateManyInput = {
    id?: number
    candidateId: string
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    jobListingId: number
    createdAt?: Date | string
  }

  export type JobApplicationUpdateManyMutationInput = {
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    jobListingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CvAnalysisCreateInput = {
    totalScore?: number | null
    technicalScore?: number | null
    experienceScore?: number | null
    educationScore?: number | null
    cvQualityScore?: number | null
    softSkillsScore?: number | null
    analysis?: string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    application: JobApplicationCreateNestedOneWithoutCvAnalysisInput
  }

  export type CvAnalysisUncheckedCreateInput = {
    id?: number
    applicationId: number
    totalScore?: number | null
    technicalScore?: number | null
    experienceScore?: number | null
    educationScore?: number | null
    cvQualityScore?: number | null
    softSkillsScore?: number | null
    analysis?: string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CvAnalysisUpdateInput = {
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    educationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    cvQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    softSkillsScore?: NullableFloatFieldUpdateOperationsInput | number | null
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: JobApplicationUpdateOneRequiredWithoutCvAnalysisNestedInput
  }

  export type CvAnalysisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicationId?: IntFieldUpdateOperationsInput | number
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    educationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    cvQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    softSkillsScore?: NullableFloatFieldUpdateOperationsInput | number | null
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CvAnalysisCreateManyInput = {
    id?: number
    applicationId: number
    totalScore?: number | null
    technicalScore?: number | null
    experienceScore?: number | null
    educationScore?: number | null
    cvQualityScore?: number | null
    softSkillsScore?: number | null
    analysis?: string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CvAnalysisUpdateManyMutationInput = {
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    educationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    cvQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    softSkillsScore?: NullableFloatFieldUpdateOperationsInput | number | null
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CvAnalysisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicationId?: IntFieldUpdateOperationsInput | number
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    educationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    cvQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    softSkillsScore?: NullableFloatFieldUpdateOperationsInput | number | null
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationHistoryCreateInput = {
    status: $Enums.ApplicationStatus
    comment?: string | null
    createdAt?: Date | string
    application: JobApplicationCreateNestedOneWithoutHistoryInput
    changedBy?: UserCreateNestedOneWithoutJobApplicationHistoryInput
  }

  export type JobApplicationHistoryUncheckedCreateInput = {
    id?: number
    applicationId: number
    status: $Enums.ApplicationStatus
    comment?: string | null
    createdAt?: Date | string
    changedByUserId?: string | null
  }

  export type JobApplicationHistoryUpdateInput = {
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: JobApplicationUpdateOneRequiredWithoutHistoryNestedInput
    changedBy?: UserUpdateOneWithoutJobApplicationHistoryNestedInput
  }

  export type JobApplicationHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicationId?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobApplicationHistoryCreateManyInput = {
    id?: number
    applicationId: number
    status: $Enums.ApplicationStatus
    comment?: string | null
    createdAt?: Date | string
    changedByUserId?: string | null
  }

  export type JobApplicationHistoryUpdateManyMutationInput = {
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicationId?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalInfoCreateInput = {
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    user: UserCreateNestedOneWithoutPersonalInfoInput
    identificationDocuments?: IdentificationDocumentCreateNestedManyWithoutPersonalInfoInput
    addresses?: AddressCreateNestedManyWithoutPersonalInfoInput
    bankAccounts?: BankAccountCreateNestedManyWithoutPersonalInfoInput
    languageSkills?: LanguageSkillCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoUncheckedCreateInput = {
    id?: number
    userId: string
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    identificationDocuments?: IdentificationDocumentUncheckedCreateNestedManyWithoutPersonalInfoInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonalInfoInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutPersonalInfoInput
    languageSkills?: LanguageSkillUncheckedCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoUpdateInput = {
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutPersonalInfoNestedInput
    identificationDocuments?: IdentificationDocumentUpdateManyWithoutPersonalInfoNestedInput
    addresses?: AddressUpdateManyWithoutPersonalInfoNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutPersonalInfoNestedInput
    languageSkills?: LanguageSkillUpdateManyWithoutPersonalInfoNestedInput
  }

  export type PersonalInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    identificationDocuments?: IdentificationDocumentUncheckedUpdateManyWithoutPersonalInfoNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonalInfoNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutPersonalInfoNestedInput
    languageSkills?: LanguageSkillUncheckedUpdateManyWithoutPersonalInfoNestedInput
  }

  export type PersonalInfoCreateManyInput = {
    id?: number
    userId: string
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
  }

  export type PersonalInfoUpdateManyMutationInput = {
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonalInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IdentificationDocumentCreateInput = {
    type: $Enums.IdentificationDocumentType
    documentNumber: string
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuingAuthority: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo: PersonalInfoCreateNestedOneWithoutIdentificationDocumentsInput
  }

  export type IdentificationDocumentUncheckedCreateInput = {
    id?: number
    personalInfoId: number
    type: $Enums.IdentificationDocumentType
    documentNumber: string
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuingAuthority: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentificationDocumentUpdateInput = {
    type?: EnumIdentificationDocumentTypeFieldUpdateOperationsInput | $Enums.IdentificationDocumentType
    documentNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: PersonalInfoUpdateOneRequiredWithoutIdentificationDocumentsNestedInput
  }

  export type IdentificationDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personalInfoId?: IntFieldUpdateOperationsInput | number
    type?: EnumIdentificationDocumentTypeFieldUpdateOperationsInput | $Enums.IdentificationDocumentType
    documentNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentificationDocumentCreateManyInput = {
    id?: number
    personalInfoId: number
    type: $Enums.IdentificationDocumentType
    documentNumber: string
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuingAuthority: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentificationDocumentUpdateManyMutationInput = {
    type?: EnumIdentificationDocumentTypeFieldUpdateOperationsInput | $Enums.IdentificationDocumentType
    documentNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentificationDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personalInfoId?: IntFieldUpdateOperationsInput | number
    type?: EnumIdentificationDocumentTypeFieldUpdateOperationsInput | $Enums.IdentificationDocumentType
    documentNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    type?: $Enums.AddressType
    street: string
    streetNumber: string
    city: string
    region: string
    postalCode: string
    country: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo: PersonalInfoCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    personalInfoId: number
    type?: $Enums.AddressType
    street: string
    streetNumber: string
    city: string
    region: string
    postalCode: string
    country: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateInput = {
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: PersonalInfoUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personalInfoId?: IntFieldUpdateOperationsInput | number
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    id?: number
    personalInfoId: number
    type?: $Enums.AddressType
    street: string
    streetNumber: string
    city: string
    region: string
    postalCode: string
    country: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personalInfoId?: IntFieldUpdateOperationsInput | number
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    dependentMember?: DependentMemberCreateNestedOneWithoutDocumentInput
    verification?: DocumentVerificationCreateNestedOneWithoutDocumentInput
    languageSkill?: LanguageSkillCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: number
    userId: string
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    dependentMemberId?: number | null
    languageSkillId?: number | null
    verification?: DocumentVerificationUncheckedCreateNestedOneWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    dependentMember?: DependentMemberUpdateOneWithoutDocumentNestedInput
    verification?: DocumentVerificationUpdateOneWithoutDocumentNestedInput
    languageSkill?: LanguageSkillUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    languageSkillId?: NullableIntFieldUpdateOperationsInput | number | null
    verification?: DocumentVerificationUncheckedUpdateOneWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: number
    userId: string
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    dependentMemberId?: number | null
    languageSkillId?: number | null
  }

  export type DocumentUpdateManyMutationInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    languageSkillId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DocumentVerificationCreateInput = {
    status?: $Enums.VerificationStatus
    comments?: string | null
    reviewedAt?: Date | string | null
    document: DocumentCreateNestedOneWithoutVerificationInput
    reviewedBy: UserCreateNestedOneWithoutDocumentReviewsInput
    User?: UserCreateNestedOneWithoutDocumentVerificationInput
  }

  export type DocumentVerificationUncheckedCreateInput = {
    id?: number
    documentId: number
    status?: $Enums.VerificationStatus
    reviewedById: string
    comments?: string | null
    reviewedAt?: Date | string | null
    userId?: string | null
  }

  export type DocumentVerificationUpdateInput = {
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: DocumentUpdateOneRequiredWithoutVerificationNestedInput
    reviewedBy?: UserUpdateOneRequiredWithoutDocumentReviewsNestedInput
    User?: UserUpdateOneWithoutDocumentVerificationNestedInput
  }

  export type DocumentVerificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedById?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentVerificationCreateManyInput = {
    id?: number
    documentId: number
    status?: $Enums.VerificationStatus
    reviewedById: string
    comments?: string | null
    reviewedAt?: Date | string | null
    userId?: string | null
  }

  export type DocumentVerificationUpdateManyMutationInput = {
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentVerificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedById?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OnboardingProgressCreateInput = {
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    user: UserCreateNestedOneWithoutOnboardingProgressInput
    application: JobApplicationCreateNestedOneWithoutOnboardingProgressInput
    hiringManager: UserCreateNestedOneWithoutManagedOnboardingsInput
    contract?: ContractCreateNestedOneWithoutOnboardingInput
  }

  export type OnboardingProgressUncheckedCreateInput = {
    id?: number
    userId: string
    applicationId: number
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    hiringManagerId: string
    contract?: ContractUncheckedCreateNestedOneWithoutOnboardingInput
  }

  export type OnboardingProgressUpdateInput = {
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingProgressNestedInput
    application?: JobApplicationUpdateOneRequiredWithoutOnboardingProgressNestedInput
    hiringManager?: UserUpdateOneRequiredWithoutManagedOnboardingsNestedInput
    contract?: ContractUpdateOneWithoutOnboardingNestedInput
  }

  export type OnboardingProgressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    applicationId?: IntFieldUpdateOperationsInput | number
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hiringManagerId?: StringFieldUpdateOperationsInput | string
    contract?: ContractUncheckedUpdateOneWithoutOnboardingNestedInput
  }

  export type OnboardingProgressCreateManyInput = {
    id?: number
    userId: string
    applicationId: number
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    hiringManagerId: string
  }

  export type OnboardingProgressUpdateManyMutationInput = {
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    applicationId?: IntFieldUpdateOperationsInput | number
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hiringManagerId?: StringFieldUpdateOperationsInput | string
  }

  export type OnboardingInvitationCreateInput = {
    id?: string
    email: string
    token: string
    otp?: string | null
    otpExpiresAt?: Date | string | null
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    lastAccessedAt?: Date | string
    sessionToken?: string | null
    sessionExpiresAt?: Date | string | null
    createdAt?: Date | string
    application: JobApplicationCreateNestedOneWithoutOnboardingInvitationInput
  }

  export type OnboardingInvitationUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    otp?: string | null
    otpExpiresAt?: Date | string | null
    applicationId: number
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    lastAccessedAt?: Date | string
    sessionToken?: string | null
    sessionExpiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OnboardingInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: JobApplicationUpdateOneRequiredWithoutOnboardingInvitationNestedInput
  }

  export type OnboardingInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInvitationCreateManyInput = {
    id?: string
    email: string
    token: string
    otp?: string | null
    otpExpiresAt?: Date | string | null
    applicationId: number
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    lastAccessedAt?: Date | string
    sessionToken?: string | null
    sessionExpiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OnboardingInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactCreateInput = {
    fullName: string
    relationship: string
    primaryPhone: string
    secondaryPhone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmergencyContactsInput
  }

  export type EmergencyContactUncheckedCreateInput = {
    id?: number
    userId: string
    fullName: string
    relationship: string
    primaryPhone: string
    secondaryPhone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    primaryPhone?: StringFieldUpdateOperationsInput | string
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmergencyContactsNestedInput
  }

  export type EmergencyContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    primaryPhone?: StringFieldUpdateOperationsInput | string
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactCreateManyInput = {
    id?: number
    userId: string
    fullName: string
    relationship: string
    primaryPhone: string
    secondaryPhone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    primaryPhone?: StringFieldUpdateOperationsInput | string
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    primaryPhone?: StringFieldUpdateOperationsInput | string
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependentMemberCreateInput = {
    firstName: string
    lastName: string
    middleName?: string | null
    birthDate: Date | string
    relationship: string
    isStudent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDependentMembersInput
    Document?: DocumentCreateNestedManyWithoutDependentMemberInput
  }

  export type DependentMemberUncheckedCreateInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    birthDate: Date | string
    relationship: string
    isStudent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentUncheckedCreateNestedManyWithoutDependentMemberInput
  }

  export type DependentMemberUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDependentMembersNestedInput
    Document?: DocumentUpdateManyWithoutDependentMemberNestedInput
  }

  export type DependentMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUncheckedUpdateManyWithoutDependentMemberNestedInput
  }

  export type DependentMemberCreateManyInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    birthDate: Date | string
    relationship: string
    isStudent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DependentMemberUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependentMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailCreateInput = {
    email: string
    type: $Enums.EmailType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailsInput
  }

  export type UserEmailUncheckedCreateInput = {
    id?: number
    userId: string
    email: string
    type: $Enums.EmailType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmailUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type UserEmailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailCreateManyInput = {
    id?: number
    userId: string
    email: string
    type: $Enums.EmailType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmailUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneCreateInput = {
    phoneNumber: string
    countryCode?: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPhonesInput
  }

  export type UserPhoneUncheckedCreateInput = {
    id?: number
    userId: string
    phoneNumber: string
    countryCode?: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhoneUpdateInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPhonesNestedInput
  }

  export type UserPhoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneCreateManyInput = {
    id?: number
    userId: string
    phoneNumber: string
    countryCode?: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhoneUpdateManyMutationInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    bank?: $Enums.GreekBank
    iban: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo: PersonalInfoCreateNestedOneWithoutBankAccountsInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: number
    personalInfoId: number
    bank?: $Enums.GreekBank
    iban: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUpdateInput = {
    bank?: EnumGreekBankFieldUpdateOperationsInput | $Enums.GreekBank
    iban?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: PersonalInfoUpdateOneRequiredWithoutBankAccountsNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personalInfoId?: IntFieldUpdateOperationsInput | number
    bank?: EnumGreekBankFieldUpdateOperationsInput | $Enums.GreekBank
    iban?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateManyInput = {
    id?: number
    personalInfoId: number
    bank?: $Enums.GreekBank
    iban: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUpdateManyMutationInput = {
    bank?: EnumGreekBankFieldUpdateOperationsInput | $Enums.GreekBank
    iban?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personalInfoId?: IntFieldUpdateOperationsInput | number
    bank?: EnumGreekBankFieldUpdateOperationsInput | $Enums.GreekBank
    iban?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    draftKey?: string | null
    signedKey?: string | null
    uploadedAt?: Date | string
    signedAt?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding: OnboardingProgressCreateNestedOneWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: number
    onboardingId: number
    draftKey?: string | null
    signedKey?: string | null
    uploadedAt?: Date | string
    signedAt?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateInput = {
    draftKey?: NullableStringFieldUpdateOperationsInput | string | null
    signedKey?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: OnboardingProgressUpdateOneRequiredWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    onboardingId?: IntFieldUpdateOperationsInput | number
    draftKey?: NullableStringFieldUpdateOperationsInput | string | null
    signedKey?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateManyInput = {
    id?: number
    onboardingId: number
    draftKey?: string | null
    signedKey?: string | null
    uploadedAt?: Date | string
    signedAt?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateManyMutationInput = {
    draftKey?: NullableStringFieldUpdateOperationsInput | string | null
    signedKey?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    onboardingId?: IntFieldUpdateOperationsInput | number
    draftKey?: NullableStringFieldUpdateOperationsInput | string | null
    signedKey?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageSkillCreateInput = {
    language: $Enums.Language
    proficiency: $Enums.Proficiency
    certificate?: string | null
    issueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo: PersonalInfoCreateNestedOneWithoutLanguageSkillsInput
    documents?: DocumentCreateNestedManyWithoutLanguageSkillInput
  }

  export type LanguageSkillUncheckedCreateInput = {
    id?: number
    personalInfoId: number
    language: $Enums.Language
    proficiency: $Enums.Proficiency
    certificate?: string | null
    issueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLanguageSkillInput
  }

  export type LanguageSkillUpdateInput = {
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    proficiency?: EnumProficiencyFieldUpdateOperationsInput | $Enums.Proficiency
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: PersonalInfoUpdateOneRequiredWithoutLanguageSkillsNestedInput
    documents?: DocumentUpdateManyWithoutLanguageSkillNestedInput
  }

  export type LanguageSkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personalInfoId?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    proficiency?: EnumProficiencyFieldUpdateOperationsInput | $Enums.Proficiency
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLanguageSkillNestedInput
  }

  export type LanguageSkillCreateManyInput = {
    id?: number
    personalInfoId: number
    language: $Enums.Language
    proficiency: $Enums.Proficiency
    certificate?: string | null
    issueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageSkillUpdateManyMutationInput = {
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    proficiency?: EnumProficiencyFieldUpdateOperationsInput | $Enums.Proficiency
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageSkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personalInfoId?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    proficiency?: EnumProficiencyFieldUpdateOperationsInput | $Enums.Proficiency
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutRequestsMadeInput
    manager: UserCreateNestedOneWithoutRequestsToManageInput
    attachments?: RequestAttachmentCreateNestedManyWithoutRequestInput
    RequestStatusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
  }

  export type RequestUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    requesterId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: RequestAttachmentUncheckedCreateNestedManyWithoutRequestInput
    RequestStatusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutRequestsMadeNestedInput
    manager?: UserUpdateOneRequiredWithoutRequestsToManageNestedInput
    attachments?: RequestAttachmentUpdateManyWithoutRequestNestedInput
    RequestStatusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    requesterId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: RequestAttachmentUncheckedUpdateManyWithoutRequestNestedInput
    RequestStatusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    requesterId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    requesterId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusHistoryCreateInput = {
    status: $Enums.RequestStatus
    comment?: string | null
    createdAt?: Date | string
    request: RequestCreateNestedOneWithoutRequestStatusHistoryInput
    user: UserCreateNestedOneWithoutRequestHistoryInput
    attachments?: StatusAttachmentCreateNestedManyWithoutHistoryInput
  }

  export type RequestStatusHistoryUncheckedCreateInput = {
    id?: number
    requestId: string
    status: $Enums.RequestStatus
    comment?: string | null
    changedBy: string
    createdAt?: Date | string
    attachments?: StatusAttachmentUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type RequestStatusHistoryUpdateInput = {
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: RequestUpdateOneRequiredWithoutRequestStatusHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutRequestHistoryNestedInput
    attachments?: StatusAttachmentUpdateManyWithoutHistoryNestedInput
  }

  export type RequestStatusHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: StatusAttachmentUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type RequestStatusHistoryCreateManyInput = {
    id?: number
    requestId: string
    status: $Enums.RequestStatus
    comment?: string | null
    changedBy: string
    createdAt?: Date | string
  }

  export type RequestStatusHistoryUpdateManyMutationInput = {
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAttachmentCreateInput = {
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
    history: RequestStatusHistoryCreateNestedOneWithoutAttachmentsInput
  }

  export type StatusAttachmentUncheckedCreateInput = {
    id?: number
    historyId: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type StatusAttachmentUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: RequestStatusHistoryUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type StatusAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    historyId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAttachmentCreateManyInput = {
    id?: number
    historyId: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type StatusAttachmentUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    historyId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestAttachmentCreateInput = {
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
    request: RequestCreateNestedOneWithoutAttachmentsInput
  }

  export type RequestAttachmentUncheckedCreateInput = {
    id?: number
    requestId: string
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type RequestAttachmentUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: RequestUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type RequestAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestAttachmentCreateManyInput = {
    id?: number
    requestId: string
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type RequestAttachmentUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestCreateInput = {
    id?: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutLeavesRequestedInput
    manager: UserCreateNestedOneWithoutLeavesToApproveInput
    attachments?: LeaveAttachmentCreateNestedManyWithoutLeaveInput
    statusHistory?: LeaveStatusHistoryCreateNestedManyWithoutLeaveInput
  }

  export type LeaveRequestUncheckedCreateInput = {
    id?: string
    employeeId: string
    managerId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: LeaveAttachmentUncheckedCreateNestedManyWithoutLeaveInput
    statusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutLeaveInput
  }

  export type LeaveRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutLeavesRequestedNestedInput
    manager?: UserUpdateOneRequiredWithoutLeavesToApproveNestedInput
    attachments?: LeaveAttachmentUpdateManyWithoutLeaveNestedInput
    statusHistory?: LeaveStatusHistoryUpdateManyWithoutLeaveNestedInput
  }

  export type LeaveRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: LeaveAttachmentUncheckedUpdateManyWithoutLeaveNestedInput
    statusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutLeaveNestedInput
  }

  export type LeaveRequestCreateManyInput = {
    id?: string
    employeeId: string
    managerId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveAttachmentCreateInput = {
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
    leave: LeaveRequestCreateNestedOneWithoutAttachmentsInput
  }

  export type LeaveAttachmentUncheckedCreateInput = {
    id?: number
    leaveId: string
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type LeaveAttachmentUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leave?: LeaveRequestUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type LeaveAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveAttachmentCreateManyInput = {
    id?: number
    leaveId: string
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type LeaveAttachmentUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveStatusHistoryCreateInput = {
    status: $Enums.LeaveStatus
    comment?: string | null
    createdAt?: Date | string
    leave: LeaveRequestCreateNestedOneWithoutStatusHistoryInput
    changedBy: UserCreateNestedOneWithoutLeaveStatusHistoryInput
    attachments?: LeaveStatusAttachmentCreateNestedManyWithoutHistoryInput
  }

  export type LeaveStatusHistoryUncheckedCreateInput = {
    id?: number
    leaveId: string
    status: $Enums.LeaveStatus
    comment?: string | null
    changedById: string
    createdAt?: Date | string
    attachments?: LeaveStatusAttachmentUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type LeaveStatusHistoryUpdateInput = {
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leave?: LeaveRequestUpdateOneRequiredWithoutStatusHistoryNestedInput
    changedBy?: UserUpdateOneRequiredWithoutLeaveStatusHistoryNestedInput
    attachments?: LeaveStatusAttachmentUpdateManyWithoutHistoryNestedInput
  }

  export type LeaveStatusHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveId?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: LeaveStatusAttachmentUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type LeaveStatusHistoryCreateManyInput = {
    id?: number
    leaveId: string
    status: $Enums.LeaveStatus
    comment?: string | null
    changedById: string
    createdAt?: Date | string
  }

  export type LeaveStatusHistoryUpdateManyMutationInput = {
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveStatusHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveId?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveStatusAttachmentCreateInput = {
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
    history: LeaveStatusHistoryCreateNestedOneWithoutAttachmentsInput
  }

  export type LeaveStatusAttachmentUncheckedCreateInput = {
    id?: number
    historyId: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type LeaveStatusAttachmentUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: LeaveStatusHistoryUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type LeaveStatusAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    historyId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveStatusAttachmentCreateManyInput = {
    id?: number
    historyId: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type LeaveStatusAttachmentUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveStatusAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    historyId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateInput = {
    id?: string
    name: string
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUncheckedCreateInput = {
    id?: string
    name: string
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateManyInput = {
    id?: string
    name: string
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutDepartmentInput
    JobListing?: JobListingCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
    JobListing?: JobListingUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutDepartmentNestedInput
    JobListing?: JobListingUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
    JobListing?: JobListingUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    region: string
    postalCode: string
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutLocationInput
    JobListing?: JobListingCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    region: string
    postalCode: string
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutLocationInput
    JobListing?: JobListingUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutLocationNestedInput
    JobListing?: JobListingUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutLocationNestedInput
    JobListing?: JobListingUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    address: string
    city: string
    region: string
    postalCode: string
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionCreateInput = {
    id?: string
    title: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutPositionInput
    jobListings?: JobListingCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateInput = {
    id?: string
    title: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutPositionInput
    jobListings?: JobListingUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutPositionNestedInput
    jobListings?: JobListingUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutPositionNestedInput
    jobListings?: JobListingUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionCreateManyInput = {
    id?: string
    title: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    vatNumber: string
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    vatNumber: string
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vatNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vatNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    vatNumber: string
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vatNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vatNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProjectsInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProjectsNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateInput = {
    id?: string
    role?: $Enums.ProjectMemberRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    role?: $Enums.ProjectMemberRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type ProjectMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    role?: $Enums.ProjectMemberRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type ProjectMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimeEntryCreateInput = {
    id?: string
    description: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    status?: $Enums.TimeEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTimeEntriesInput
    user: UserCreateNestedOneWithoutTimeEntriesInput
  }

  export type TimeEntryUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    description: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    status?: $Enums.TimeEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumTimeEntryStatusFieldUpdateOperationsInput | $Enums.TimeEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTimeEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutTimeEntriesNestedInput
  }

  export type TimeEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumTimeEntryStatusFieldUpdateOperationsInput | $Enums.TimeEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    description: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    status?: $Enums.TimeEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumTimeEntryStatusFieldUpdateOperationsInput | $Enums.TimeEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumTimeEntryStatusFieldUpdateOperationsInput | $Enums.TimeEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    content: string
    publishedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    changedByUser: UserCreateNestedOneWithoutAnnouncementsChangedInput
    publishedByUser: UserCreateNestedOneWithoutAnnouncementsPublishedInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    publishedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    changedBy: string
    publishedBy: string
  }

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedByUser?: UserUpdateOneRequiredWithoutAnnouncementsChangedNestedInput
    publishedByUser?: UserUpdateOneRequiredWithoutAnnouncementsPublishedNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: StringFieldUpdateOperationsInput | string
    publishedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    title: string
    content: string
    publishedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    changedBy: string
    publishedBy: string
  }

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: StringFieldUpdateOperationsInput | string
    publishedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TimeScheduleCreateInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftEntryCreateNestedManyWithoutScheduleInput
  }

  export type TimeScheduleUncheckedCreateInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type TimeScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftEntryUpdateManyWithoutScheduleNestedInput
  }

  export type TimeScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftEntryUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type TimeScheduleCreateManyInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftEntryCreateInput = {
    id?: string
    date: Date | string
    status?: $Enums.ShiftStatus
    isNightShift?: boolean
    workplaceType?: $Enums.WorkplaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShiftsInput
    schedule: TimeScheduleCreateNestedOneWithoutShiftsInput
  }

  export type ShiftEntryUncheckedCreateInput = {
    id?: string
    userId: string
    scheduleId: string
    date: Date | string
    status?: $Enums.ShiftStatus
    isNightShift?: boolean
    workplaceType?: $Enums.WorkplaceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShiftsNestedInput
    schedule?: TimeScheduleUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftEntryCreateManyInput = {
    id?: string
    userId: string
    scheduleId: string
    date: Date | string
    status?: $Enums.ShiftStatus
    isNightShift?: boolean
    workplaceType?: $Enums.WorkplaceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingsCreateInput = {
    name: string
    logoUrl?: string | null
    url?: string | null
    address: string
    postalCode: string
    city: string
    region: string
    country: string
    phone?: string | null
    email?: string | null
    timezone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySettingsUncheckedCreateInput = {
    id?: number
    name: string
    logoUrl?: string | null
    url?: string | null
    address: string
    postalCode: string
    city: string
    region: string
    country: string
    phone?: string | null
    email?: string | null
    timezone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySettingsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingsCreateManyInput = {
    id?: number
    name: string
    logoUrl?: string | null
    url?: string | null
    address: string
    postalCode: string
    city: string
    region: string
    country: string
    phone?: string | null
    email?: string | null
    timezone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySettingsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerSettingsCreateInput = {
    logoUrl?: string | null
    headerButtonText?: string | null
    headerButtonUrl?: string | null
    headerButtonBgColor?: string | null
    headerButtonTextColor?: string | null
    bannerText?: string | null
    bannerBgColor?: string | null
    bannerTextColor?: string | null
    showCvBanner?: boolean
    cvBannerUrl?: string | null
    cvBannerTitle?: string | null
    cvBannerSubtitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareerSettingsUncheckedCreateInput = {
    id?: number
    logoUrl?: string | null
    headerButtonText?: string | null
    headerButtonUrl?: string | null
    headerButtonBgColor?: string | null
    headerButtonTextColor?: string | null
    bannerText?: string | null
    bannerBgColor?: string | null
    bannerTextColor?: string | null
    showCvBanner?: boolean
    cvBannerUrl?: string | null
    cvBannerTitle?: string | null
    cvBannerSubtitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareerSettingsUpdateInput = {
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonText?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonBgColor?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    bannerBgColor?: NullableStringFieldUpdateOperationsInput | string | null
    bannerTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    showCvBanner?: BoolFieldUpdateOperationsInput | boolean
    cvBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cvBannerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    cvBannerSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonText?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonBgColor?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    bannerBgColor?: NullableStringFieldUpdateOperationsInput | string | null
    bannerTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    showCvBanner?: BoolFieldUpdateOperationsInput | boolean
    cvBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cvBannerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    cvBannerSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerSettingsCreateManyInput = {
    id?: number
    logoUrl?: string | null
    headerButtonText?: string | null
    headerButtonUrl?: string | null
    headerButtonBgColor?: string | null
    headerButtonTextColor?: string | null
    bannerText?: string | null
    bannerBgColor?: string | null
    bannerTextColor?: string | null
    showCvBanner?: boolean
    cvBannerUrl?: string | null
    cvBannerTitle?: string | null
    cvBannerSubtitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareerSettingsUpdateManyMutationInput = {
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonText?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonBgColor?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    bannerBgColor?: NullableStringFieldUpdateOperationsInput | string | null
    bannerTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    showCvBanner?: BoolFieldUpdateOperationsInput | boolean
    cvBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cvBannerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    cvBannerSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonText?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonBgColor?: NullableStringFieldUpdateOperationsInput | string | null
    headerButtonTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    bannerBgColor?: NullableStringFieldUpdateOperationsInput | string | null
    bannerTextColor?: NullableStringFieldUpdateOperationsInput | string | null
    showCvBanner?: BoolFieldUpdateOperationsInput | boolean
    cvBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cvBannerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    cvBannerSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumEmploymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeFilter<$PrismaModel> | $Enums.EmploymentType
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type CandidateNoteListRelationFilter = {
    every?: CandidateNoteWhereInput
    some?: CandidateNoteWhereInput
    none?: CandidateNoteWhereInput
  }

  export type JobApplicationHistoryListRelationFilter = {
    every?: JobApplicationHistoryWhereInput
    some?: JobApplicationHistoryWhereInput
    none?: JobApplicationHistoryWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UserStatusHistoryListRelationFilter = {
    every?: UserStatusHistoryWhereInput
    some?: UserStatusHistoryWhereInput
    none?: UserStatusHistoryWhereInput
  }

  export type PersonalInfoNullableScalarRelationFilter = {
    is?: PersonalInfoWhereInput | null
    isNot?: PersonalInfoWhereInput | null
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentVerificationListRelationFilter = {
    every?: DocumentVerificationWhereInput
    some?: DocumentVerificationWhereInput
    none?: DocumentVerificationWhereInput
  }

  export type OnboardingProgressNullableScalarRelationFilter = {
    is?: OnboardingProgressWhereInput | null
    isNot?: OnboardingProgressWhereInput | null
  }

  export type EmergencyContactListRelationFilter = {
    every?: EmergencyContactWhereInput
    some?: EmergencyContactWhereInput
    none?: EmergencyContactWhereInput
  }

  export type DependentMemberListRelationFilter = {
    every?: DependentMemberWhereInput
    some?: DependentMemberWhereInput
    none?: DependentMemberWhereInput
  }

  export type UserEmailListRelationFilter = {
    every?: UserEmailWhereInput
    some?: UserEmailWhereInput
    none?: UserEmailWhereInput
  }

  export type UserPhoneListRelationFilter = {
    every?: UserPhoneWhereInput
    some?: UserPhoneWhereInput
    none?: UserPhoneWhereInput
  }

  export type OnboardingProgressListRelationFilter = {
    every?: OnboardingProgressWhereInput
    some?: OnboardingProgressWhereInput
    none?: OnboardingProgressWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type RequestListRelationFilter = {
    every?: RequestWhereInput
    some?: RequestWhereInput
    none?: RequestWhereInput
  }

  export type RequestStatusHistoryListRelationFilter = {
    every?: RequestStatusHistoryWhereInput
    some?: RequestStatusHistoryWhereInput
    none?: RequestStatusHistoryWhereInput
  }

  export type LeaveRequestListRelationFilter = {
    every?: LeaveRequestWhereInput
    some?: LeaveRequestWhereInput
    none?: LeaveRequestWhereInput
  }

  export type LeaveStatusHistoryListRelationFilter = {
    every?: LeaveStatusHistoryWhereInput
    some?: LeaveStatusHistoryWhereInput
    none?: LeaveStatusHistoryWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type TimeEntryListRelationFilter = {
    every?: TimeEntryWhereInput
    some?: TimeEntryWhereInput
    none?: TimeEntryWhereInput
  }

  export type ShiftEntryListRelationFilter = {
    every?: ShiftEntryWhereInput
    some?: ShiftEntryWhereInput
    none?: ShiftEntryWhereInput
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type PositionNullableScalarRelationFilter = {
    is?: PositionWhereInput | null
    isNot?: PositionWhereInput | null
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type CandidateNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobApplicationHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmergencyContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DependentMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OnboardingProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role?: SortOrder
    employmentType?: SortOrder
    jobStartDate?: SortOrder
    jobEndDate?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    positionId?: SortOrder
    locationId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role?: SortOrder
    employmentType?: SortOrder
    jobStartDate?: SortOrder
    jobEndDate?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    positionId?: SortOrder
    locationId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role?: SortOrder
    employmentType?: SortOrder
    jobStartDate?: SortOrder
    jobEndDate?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    managerId?: SortOrder
    positionId?: SortOrder
    locationId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumEmploymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    changedById?: SortOrder
  }

  export type UserStatusHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    changedById?: SortOrder
  }

  export type UserStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    changedById?: SortOrder
  }

  export type UserStatusHistorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CandidateScalarRelationFilter = {
    is?: CandidateWhereInput
    isNot?: CandidateWhereInput
  }

  export type CandidateNoteCountOrderByAggregateInput = {
    id?: SortOrder
    candidateId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type CandidateNoteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CandidateNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    candidateId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type CandidateNoteMinOrderByAggregateInput = {
    id?: SortOrder
    candidateId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type CandidateNoteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumWorkplaceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkplaceType | EnumWorkplaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkplaceType[] | ListEnumWorkplaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkplaceType[] | ListEnumWorkplaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkplaceTypeFilter<$PrismaModel> | $Enums.WorkplaceType
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type JobApplicationListRelationFilter = {
    every?: JobApplicationWhereInput
    some?: JobApplicationWhereInput
    none?: JobApplicationWhereInput
  }

  export type JobApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobListingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    employmentType?: SortOrder
    workplaceType?: SortOrder
    referralSource?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    departmentId?: SortOrder
    locationId?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    positionId?: SortOrder
  }

  export type JobListingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JobListingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    employmentType?: SortOrder
    workplaceType?: SortOrder
    referralSource?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    departmentId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    positionId?: SortOrder
  }

  export type JobListingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    employmentType?: SortOrder
    workplaceType?: SortOrder
    referralSource?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    departmentId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    positionId?: SortOrder
  }

  export type JobListingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumWorkplaceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkplaceType | EnumWorkplaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkplaceType[] | ListEnumWorkplaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkplaceType[] | ListEnumWorkplaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkplaceTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkplaceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkplaceTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkplaceTypeFilter<$PrismaModel>
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type CandidateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CandidateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CandidateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    linkedin?: SortOrder
    github?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type JobListingScalarRelationFilter = {
    is?: JobListingWhereInput
    isNot?: JobListingWhereInput
  }

  export type CvAnalysisNullableScalarRelationFilter = {
    is?: CvAnalysisWhereInput | null
    isNot?: CvAnalysisWhereInput | null
  }

  export type OnboardingInvitationNullableScalarRelationFilter = {
    is?: OnboardingInvitationWhereInput | null
    isNot?: OnboardingInvitationWhereInput | null
  }

  export type JobApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    candidateId?: SortOrder
    resumeKey?: SortOrder
    additionalNotes?: SortOrder
    referralSource?: SortOrder
    status?: SortOrder
    jobListingId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobApplicationAvgOrderByAggregateInput = {
    id?: SortOrder
    jobListingId?: SortOrder
  }

  export type JobApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    candidateId?: SortOrder
    resumeKey?: SortOrder
    additionalNotes?: SortOrder
    referralSource?: SortOrder
    status?: SortOrder
    jobListingId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    candidateId?: SortOrder
    resumeKey?: SortOrder
    additionalNotes?: SortOrder
    referralSource?: SortOrder
    status?: SortOrder
    jobListingId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobApplicationSumOrderByAggregateInput = {
    id?: SortOrder
    jobListingId?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type JobApplicationScalarRelationFilter = {
    is?: JobApplicationWhereInput
    isNot?: JobApplicationWhereInput
  }

  export type CvAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    totalScore?: SortOrder
    technicalScore?: SortOrder
    experienceScore?: SortOrder
    educationScore?: SortOrder
    cvQualityScore?: SortOrder
    softSkillsScore?: SortOrder
    analysis?: SortOrder
    parsedContent?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CvAnalysisAvgOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    totalScore?: SortOrder
    technicalScore?: SortOrder
    experienceScore?: SortOrder
    educationScore?: SortOrder
    cvQualityScore?: SortOrder
    softSkillsScore?: SortOrder
  }

  export type CvAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    totalScore?: SortOrder
    technicalScore?: SortOrder
    experienceScore?: SortOrder
    educationScore?: SortOrder
    cvQualityScore?: SortOrder
    softSkillsScore?: SortOrder
    analysis?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CvAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    totalScore?: SortOrder
    technicalScore?: SortOrder
    experienceScore?: SortOrder
    educationScore?: SortOrder
    cvQualityScore?: SortOrder
    softSkillsScore?: SortOrder
    analysis?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CvAnalysisSumOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    totalScore?: SortOrder
    technicalScore?: SortOrder
    experienceScore?: SortOrder
    educationScore?: SortOrder
    cvQualityScore?: SortOrder
    softSkillsScore?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type JobApplicationHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    changedByUserId?: SortOrder
  }

  export type JobApplicationHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
  }

  export type JobApplicationHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    changedByUserId?: SortOrder
  }

  export type JobApplicationHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    changedByUserId?: SortOrder
  }

  export type JobApplicationHistorySumOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
  }

  export type EnumMaritalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaritalStatusFilter<$PrismaModel> | $Enums.MaritalStatus
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumEducationLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EducationLevel | EnumEducationLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEducationLevelNullableFilter<$PrismaModel> | $Enums.EducationLevel | null
  }

  export type IdentificationDocumentListRelationFilter = {
    every?: IdentificationDocumentWhereInput
    some?: IdentificationDocumentWhereInput
    none?: IdentificationDocumentWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type BankAccountListRelationFilter = {
    every?: BankAccountWhereInput
    some?: BankAccountWhereInput
    none?: BankAccountWhereInput
  }

  export type LanguageSkillListRelationFilter = {
    every?: LanguageSkillWhereInput
    some?: LanguageSkillWhereInput
    none?: LanguageSkillWhereInput
  }

  export type IdentificationDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalInfoCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amka?: SortOrder
    afm?: SortOrder
    doy?: SortOrder
    middleName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    maritalStatus?: SortOrder
    numberOfChildren?: SortOrder
    citizenship?: SortOrder
    nationality?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    educationLevel?: SortOrder
    educationTitle?: SortOrder
    educationInstitution?: SortOrder
    graduationYear?: SortOrder
  }

  export type PersonalInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    numberOfChildren?: SortOrder
    graduationYear?: SortOrder
  }

  export type PersonalInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amka?: SortOrder
    afm?: SortOrder
    doy?: SortOrder
    middleName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    maritalStatus?: SortOrder
    numberOfChildren?: SortOrder
    citizenship?: SortOrder
    nationality?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    educationLevel?: SortOrder
    educationTitle?: SortOrder
    educationInstitution?: SortOrder
    graduationYear?: SortOrder
  }

  export type PersonalInfoMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amka?: SortOrder
    afm?: SortOrder
    doy?: SortOrder
    middleName?: SortOrder
    birthDate?: SortOrder
    birthPlace?: SortOrder
    maritalStatus?: SortOrder
    numberOfChildren?: SortOrder
    citizenship?: SortOrder
    nationality?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    educationLevel?: SortOrder
    educationTitle?: SortOrder
    educationInstitution?: SortOrder
    graduationYear?: SortOrder
  }

  export type PersonalInfoSumOrderByAggregateInput = {
    id?: SortOrder
    numberOfChildren?: SortOrder
    graduationYear?: SortOrder
  }

  export type EnumMaritalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaritalStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumEducationLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EducationLevel | EnumEducationLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEducationLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.EducationLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEducationLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumEducationLevelNullableFilter<$PrismaModel>
  }

  export type EnumIdentificationDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationDocumentType | EnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdentificationDocumentType[] | ListEnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentificationDocumentType[] | ListEnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentificationDocumentTypeFilter<$PrismaModel> | $Enums.IdentificationDocumentType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PersonalInfoScalarRelationFilter = {
    is?: PersonalInfoWhereInput
    isNot?: PersonalInfoWhereInput
  }

  export type IdentificationDocumentPersonalInfoIdDocumentNumberCompoundUniqueInput = {
    personalInfoId: number
    documentNumber: string
  }

  export type IdentificationDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    type?: SortOrder
    documentNumber?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    issuingAuthority?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentificationDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
  }

  export type IdentificationDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    type?: SortOrder
    documentNumber?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    issuingAuthority?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentificationDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    type?: SortOrder
    documentNumber?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    issuingAuthority?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentificationDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
  }

  export type EnumIdentificationDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationDocumentType | EnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdentificationDocumentType[] | ListEnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentificationDocumentType[] | ListEnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentificationDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IdentificationDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdentificationDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumIdentificationDocumentTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    type?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    type?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    type?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
  }

  export type EnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type DependentMemberNullableScalarRelationFilter = {
    is?: DependentMemberWhereInput | null
    isNot?: DependentMemberWhereInput | null
  }

  export type DocumentVerificationNullableScalarRelationFilter = {
    is?: DocumentVerificationWhereInput | null
    isNot?: DocumentVerificationWhereInput | null
  }

  export type LanguageSkillNullableScalarRelationFilter = {
    is?: LanguageSkillWhereInput | null
    isNot?: LanguageSkillWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    uploadedAt?: SortOrder
    dependentMemberId?: SortOrder
    languageSkillId?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    dependentMemberId?: SortOrder
    languageSkillId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    uploadedAt?: SortOrder
    dependentMemberId?: SortOrder
    languageSkillId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    key?: SortOrder
    uploadedAt?: SortOrder
    dependentMemberId?: SortOrder
    languageSkillId?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    id?: SortOrder
    dependentMemberId?: SortOrder
    languageSkillId?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type DocumentVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentVerificationAvgOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
  }

  export type DocumentVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    comments?: SortOrder
    reviewedAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentVerificationSumOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type EnumPhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.Phase | EnumPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.Phase[] | ListEnumPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.Phase[] | ListEnumPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumPhaseFilter<$PrismaModel> | $Enums.Phase
  }

  export type EnumOnboardingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OnboardingStatus | EnumOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnboardingStatusFilter<$PrismaModel> | $Enums.OnboardingStatus
  }

  export type ContractNullableScalarRelationFilter = {
    is?: ContractWhereInput | null
    isNot?: ContractWhereInput | null
  }

  export type OnboardingProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    applicationId?: SortOrder
    currentPhase?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    hireDate?: SortOrder
    hiringManagerId?: SortOrder
  }

  export type OnboardingProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
  }

  export type OnboardingProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    applicationId?: SortOrder
    currentPhase?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    hireDate?: SortOrder
    hiringManagerId?: SortOrder
  }

  export type OnboardingProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    applicationId?: SortOrder
    currentPhase?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    hireDate?: SortOrder
    hiringManagerId?: SortOrder
  }

  export type OnboardingProgressSumOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
  }

  export type EnumPhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Phase | EnumPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.Phase[] | ListEnumPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.Phase[] | ListEnumPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumPhaseWithAggregatesFilter<$PrismaModel> | $Enums.Phase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhaseFilter<$PrismaModel>
    _max?: NestedEnumPhaseFilter<$PrismaModel>
  }

  export type EnumOnboardingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OnboardingStatus | EnumOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnboardingStatusWithAggregatesFilter<$PrismaModel> | $Enums.OnboardingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOnboardingStatusFilter<$PrismaModel>
    _max?: NestedEnumOnboardingStatusFilter<$PrismaModel>
  }

  export type OnboardingInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    applicationId?: SortOrder
    expiresAt?: SortOrder
    verifiedAt?: SortOrder
    lastAccessedAt?: SortOrder
    sessionToken?: SortOrder
    sessionExpiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OnboardingInvitationAvgOrderByAggregateInput = {
    applicationId?: SortOrder
  }

  export type OnboardingInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    applicationId?: SortOrder
    expiresAt?: SortOrder
    verifiedAt?: SortOrder
    lastAccessedAt?: SortOrder
    sessionToken?: SortOrder
    sessionExpiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OnboardingInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    applicationId?: SortOrder
    expiresAt?: SortOrder
    verifiedAt?: SortOrder
    lastAccessedAt?: SortOrder
    sessionToken?: SortOrder
    sessionExpiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OnboardingInvitationSumOrderByAggregateInput = {
    applicationId?: SortOrder
  }

  export type EmergencyContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    relationship?: SortOrder
    primaryPhone?: SortOrder
    secondaryPhone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmergencyContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    relationship?: SortOrder
    primaryPhone?: SortOrder
    secondaryPhone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    relationship?: SortOrder
    primaryPhone?: SortOrder
    secondaryPhone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmergencyContactSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DependentMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    birthDate?: SortOrder
    relationship?: SortOrder
    isStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DependentMemberAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DependentMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    birthDate?: SortOrder
    relationship?: SortOrder
    isStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DependentMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    birthDate?: SortOrder
    relationship?: SortOrder
    isStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DependentMemberSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumEmailTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailType | EnumEmailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTypeFilter<$PrismaModel> | $Enums.EmailType
  }

  export type UserEmailCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserEmailAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserEmailMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserEmailSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumEmailTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailType | EnumEmailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmailType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailTypeFilter<$PrismaModel>
    _max?: NestedEnumEmailTypeFilter<$PrismaModel>
  }

  export type EnumPhoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneType | EnumPhoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhoneTypeFilter<$PrismaModel> | $Enums.PhoneType
  }

  export type UserPhoneCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhoneAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserPhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhoneMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhoneSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPhoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneType | EnumPhoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.PhoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhoneTypeFilter<$PrismaModel>
    _max?: NestedEnumPhoneTypeFilter<$PrismaModel>
  }

  export type EnumGreekBankFilter<$PrismaModel = never> = {
    equals?: $Enums.GreekBank | EnumGreekBankFieldRefInput<$PrismaModel>
    in?: $Enums.GreekBank[] | ListEnumGreekBankFieldRefInput<$PrismaModel>
    notIn?: $Enums.GreekBank[] | ListEnumGreekBankFieldRefInput<$PrismaModel>
    not?: NestedEnumGreekBankFilter<$PrismaModel> | $Enums.GreekBank
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    bank?: SortOrder
    iban?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    bank?: SortOrder
    iban?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    bank?: SortOrder
    iban?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
  }

  export type EnumGreekBankWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GreekBank | EnumGreekBankFieldRefInput<$PrismaModel>
    in?: $Enums.GreekBank[] | ListEnumGreekBankFieldRefInput<$PrismaModel>
    notIn?: $Enums.GreekBank[] | ListEnumGreekBankFieldRefInput<$PrismaModel>
    not?: NestedEnumGreekBankWithAggregatesFilter<$PrismaModel> | $Enums.GreekBank
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGreekBankFilter<$PrismaModel>
    _max?: NestedEnumGreekBankFilter<$PrismaModel>
  }

  export type EnumContractStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusFilter<$PrismaModel> | $Enums.ContractStatus
  }

  export type OnboardingProgressScalarRelationFilter = {
    is?: OnboardingProgressWhereInput
    isNot?: OnboardingProgressWhereInput
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    onboardingId?: SortOrder
    draftKey?: SortOrder
    signedKey?: SortOrder
    uploadedAt?: SortOrder
    signedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    id?: SortOrder
    onboardingId?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    onboardingId?: SortOrder
    draftKey?: SortOrder
    signedKey?: SortOrder
    uploadedAt?: SortOrder
    signedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    onboardingId?: SortOrder
    draftKey?: SortOrder
    signedKey?: SortOrder
    uploadedAt?: SortOrder
    signedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    id?: SortOrder
    onboardingId?: SortOrder
  }

  export type EnumContractStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractStatusFilter<$PrismaModel>
    _max?: NestedEnumContractStatusFilter<$PrismaModel>
  }

  export type EnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type EnumProficiencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Proficiency | EnumProficiencyFieldRefInput<$PrismaModel>
    in?: $Enums.Proficiency[] | ListEnumProficiencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Proficiency[] | ListEnumProficiencyFieldRefInput<$PrismaModel>
    not?: NestedEnumProficiencyFilter<$PrismaModel> | $Enums.Proficiency
  }

  export type LanguageSkillCountOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    language?: SortOrder
    proficiency?: SortOrder
    certificate?: SortOrder
    issueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageSkillAvgOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
  }

  export type LanguageSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    language?: SortOrder
    proficiency?: SortOrder
    certificate?: SortOrder
    issueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageSkillMinOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
    language?: SortOrder
    proficiency?: SortOrder
    certificate?: SortOrder
    issueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageSkillSumOrderByAggregateInput = {
    id?: SortOrder
    personalInfoId?: SortOrder
  }

  export type EnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type EnumProficiencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Proficiency | EnumProficiencyFieldRefInput<$PrismaModel>
    in?: $Enums.Proficiency[] | ListEnumProficiencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Proficiency[] | ListEnumProficiencyFieldRefInput<$PrismaModel>
    not?: NestedEnumProficiencyWithAggregatesFilter<$PrismaModel> | $Enums.Proficiency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProficiencyFilter<$PrismaModel>
    _max?: NestedEnumProficiencyFilter<$PrismaModel>
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type RequestAttachmentListRelationFilter = {
    every?: RequestAttachmentWhereInput
    some?: RequestAttachmentWhereInput
    none?: RequestAttachmentWhereInput
  }

  export type RequestAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type RequestScalarRelationFilter = {
    is?: RequestWhereInput
    isNot?: RequestWhereInput
  }

  export type StatusAttachmentListRelationFilter = {
    every?: StatusAttachmentWhereInput
    some?: StatusAttachmentWhereInput
    none?: StatusAttachmentWhereInput
  }

  export type StatusAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestStatusHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RequestStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestStatusHistorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RequestStatusHistoryScalarRelationFilter = {
    is?: RequestStatusHistoryWhereInput
    isNot?: RequestStatusHistoryWhereInput
  }

  export type StatusAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type StatusAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
  }

  export type StatusAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type StatusAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type StatusAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
  }

  export type RequestAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type RequestAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RequestAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type RequestAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type RequestAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type LeaveAttachmentListRelationFilter = {
    every?: LeaveAttachmentWhereInput
    some?: LeaveAttachmentWhereInput
    none?: LeaveAttachmentWhereInput
  }

  export type LeaveAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    managerId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type LeaveRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    managerId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    managerId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type LeaveRequestScalarRelationFilter = {
    is?: LeaveRequestWhereInput
    isNot?: LeaveRequestWhereInput
  }

  export type LeaveAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    leaveId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LeaveAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeaveAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    leaveId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LeaveAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    leaveId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LeaveAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeaveStatusAttachmentListRelationFilter = {
    every?: LeaveStatusAttachmentWhereInput
    some?: LeaveStatusAttachmentWhereInput
    none?: LeaveStatusAttachmentWhereInput
  }

  export type LeaveStatusAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    leaveId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaveStatusHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeaveStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    leaveId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaveStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    leaveId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaveStatusHistorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeaveStatusHistoryScalarRelationFilter = {
    is?: LeaveStatusHistoryWhereInput
    isNot?: LeaveStatusHistoryWhereInput
  }

  export type LeaveStatusAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LeaveStatusAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
  }

  export type LeaveStatusAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LeaveStatusAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
    fileName?: SortOrder
    fileKey?: SortOrder
    fileType?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LeaveStatusAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    historyId?: SortOrder
  }

  export type HolidayCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobListingListRelationFilter = {
    every?: JobListingWhereInput
    some?: JobListingWhereInput
    none?: JobListingWhereInput
  }

  export type JobListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationNameCityCompoundUniqueInput = {
    name: string
    city: string
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusFilter<$PrismaModel> | $Enums.ClientStatus
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vatNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vatNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    vatNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientStatusFilter<$PrismaModel>
    _max?: NestedEnumClientStatusFilter<$PrismaModel>
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type EnumProjectMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectMemberRole | EnumProjectMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectMemberRoleFilter<$PrismaModel> | $Enums.ProjectMemberRole
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
  }

  export type EnumProjectMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectMemberRole | EnumProjectMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectMemberRoleFilter<$PrismaModel>
  }

  export type EnumTimeEntryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeEntryStatus | EnumTimeEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TimeEntryStatus[] | ListEnumTimeEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeEntryStatus[] | ListEnumTimeEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeEntryStatusFilter<$PrismaModel> | $Enums.TimeEntryStatus
  }

  export type TimeEntryCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntryAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type TimeEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntryMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntrySumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumTimeEntryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeEntryStatus | EnumTimeEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TimeEntryStatus[] | ListEnumTimeEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeEntryStatus[] | ListEnumTimeEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeEntryStatusWithAggregatesFilter<$PrismaModel> | $Enums.TimeEntryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimeEntryStatusFilter<$PrismaModel>
    _max?: NestedEnumTimeEntryStatusFilter<$PrismaModel>
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    changedBy?: SortOrder
    publishedBy?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    changedBy?: SortOrder
    publishedBy?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    changedBy?: SortOrder
    publishedBy?: SortOrder
  }

  export type TimeScheduleNameStartTimeEndTimeCompoundUniqueInput = {
    name: string
    startTime: string
    endTime: string
  }

  export type TimeScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumShiftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftStatus | EnumShiftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftStatus[] | ListEnumShiftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftStatus[] | ListEnumShiftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftStatusFilter<$PrismaModel> | $Enums.ShiftStatus
  }

  export type TimeScheduleScalarRelationFilter = {
    is?: TimeScheduleWhereInput
    isNot?: TimeScheduleWhereInput
  }

  export type ShiftEntryUserIdScheduleIdDateCompoundUniqueInput = {
    userId: string
    scheduleId: string
    date: Date | string
  }

  export type ShiftEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    isNightShift?: SortOrder
    workplaceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    isNightShift?: SortOrder
    workplaceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    isNightShift?: SortOrder
    workplaceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumShiftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftStatus | EnumShiftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftStatus[] | ListEnumShiftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftStatus[] | ListEnumShiftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShiftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftStatusFilter<$PrismaModel>
    _max?: NestedEnumShiftStatusFilter<$PrismaModel>
  }

  export type CompanySettingsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    url?: SortOrder
    address?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanySettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    url?: SortOrder
    address?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySettingsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    url?: SortOrder
    address?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CareerSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    logoUrl?: SortOrder
    headerButtonText?: SortOrder
    headerButtonUrl?: SortOrder
    headerButtonBgColor?: SortOrder
    headerButtonTextColor?: SortOrder
    bannerText?: SortOrder
    bannerBgColor?: SortOrder
    bannerTextColor?: SortOrder
    showCvBanner?: SortOrder
    cvBannerUrl?: SortOrder
    cvBannerTitle?: SortOrder
    cvBannerSubtitle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CareerSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    logoUrl?: SortOrder
    headerButtonText?: SortOrder
    headerButtonUrl?: SortOrder
    headerButtonBgColor?: SortOrder
    headerButtonTextColor?: SortOrder
    bannerText?: SortOrder
    bannerBgColor?: SortOrder
    bannerTextColor?: SortOrder
    showCvBanner?: SortOrder
    cvBannerUrl?: SortOrder
    cvBannerTitle?: SortOrder
    cvBannerSubtitle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    logoUrl?: SortOrder
    headerButtonText?: SortOrder
    headerButtonUrl?: SortOrder
    headerButtonBgColor?: SortOrder
    headerButtonTextColor?: SortOrder
    bannerText?: SortOrder
    bannerBgColor?: SortOrder
    bannerTextColor?: SortOrder
    showCvBanner?: SortOrder
    cvBannerUrl?: SortOrder
    cvBannerTitle?: SortOrder
    cvBannerSubtitle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerSettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type DepartmentCreateNestedOneWithoutUsersInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type CandidateNoteCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CandidateNoteCreateWithoutCreatedByInput, CandidateNoteUncheckedCreateWithoutCreatedByInput> | CandidateNoteCreateWithoutCreatedByInput[] | CandidateNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CandidateNoteCreateOrConnectWithoutCreatedByInput | CandidateNoteCreateOrConnectWithoutCreatedByInput[]
    createMany?: CandidateNoteCreateManyCreatedByInputEnvelope
    connect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
  }

  export type JobApplicationHistoryCreateNestedManyWithoutChangedByInput = {
    create?: XOR<JobApplicationHistoryCreateWithoutChangedByInput, JobApplicationHistoryUncheckedCreateWithoutChangedByInput> | JobApplicationHistoryCreateWithoutChangedByInput[] | JobApplicationHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: JobApplicationHistoryCreateOrConnectWithoutChangedByInput | JobApplicationHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: JobApplicationHistoryCreateManyChangedByInputEnvelope
    connect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserStatusHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserStatusHistoryCreateWithoutUserInput, UserStatusHistoryUncheckedCreateWithoutUserInput> | UserStatusHistoryCreateWithoutUserInput[] | UserStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserStatusHistoryCreateOrConnectWithoutUserInput | UserStatusHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserStatusHistoryCreateManyUserInputEnvelope
    connect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
  }

  export type UserStatusHistoryCreateNestedManyWithoutChangedByInput = {
    create?: XOR<UserStatusHistoryCreateWithoutChangedByInput, UserStatusHistoryUncheckedCreateWithoutChangedByInput> | UserStatusHistoryCreateWithoutChangedByInput[] | UserStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: UserStatusHistoryCreateOrConnectWithoutChangedByInput | UserStatusHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: UserStatusHistoryCreateManyChangedByInputEnvelope
    connect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
  }

  export type PersonalInfoCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonalInfoCreateWithoutUserInput, PersonalInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutUserInput
    connect?: PersonalInfoWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentVerificationCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<DocumentVerificationCreateWithoutReviewedByInput, DocumentVerificationUncheckedCreateWithoutReviewedByInput> | DocumentVerificationCreateWithoutReviewedByInput[] | DocumentVerificationUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutReviewedByInput | DocumentVerificationCreateOrConnectWithoutReviewedByInput[]
    createMany?: DocumentVerificationCreateManyReviewedByInputEnvelope
    connect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
  }

  export type DocumentVerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentVerificationCreateWithoutUserInput, DocumentVerificationUncheckedCreateWithoutUserInput> | DocumentVerificationCreateWithoutUserInput[] | DocumentVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutUserInput | DocumentVerificationCreateOrConnectWithoutUserInput[]
    createMany?: DocumentVerificationCreateManyUserInputEnvelope
    connect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
  }

  export type OnboardingProgressCreateNestedOneWithoutUserInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    connect?: OnboardingProgressWhereUniqueInput
  }

  export type EmergencyContactCreateNestedManyWithoutUserInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type DependentMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<DependentMemberCreateWithoutUserInput, DependentMemberUncheckedCreateWithoutUserInput> | DependentMemberCreateWithoutUserInput[] | DependentMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DependentMemberCreateOrConnectWithoutUserInput | DependentMemberCreateOrConnectWithoutUserInput[]
    createMany?: DependentMemberCreateManyUserInputEnvelope
    connect?: DependentMemberWhereUniqueInput | DependentMemberWhereUniqueInput[]
  }

  export type UserEmailCreateNestedManyWithoutUserInput = {
    create?: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput> | UserEmailCreateWithoutUserInput[] | UserEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailCreateOrConnectWithoutUserInput | UserEmailCreateOrConnectWithoutUserInput[]
    createMany?: UserEmailCreateManyUserInputEnvelope
    connect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
  }

  export type UserPhoneCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput> | UserPhoneCreateWithoutUserInput[] | UserPhoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput | UserPhoneCreateOrConnectWithoutUserInput[]
    createMany?: UserPhoneCreateManyUserInputEnvelope
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
  }

  export type OnboardingProgressCreateNestedManyWithoutHiringManagerInput = {
    create?: XOR<OnboardingProgressCreateWithoutHiringManagerInput, OnboardingProgressUncheckedCreateWithoutHiringManagerInput> | OnboardingProgressCreateWithoutHiringManagerInput[] | OnboardingProgressUncheckedCreateWithoutHiringManagerInput[]
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutHiringManagerInput | OnboardingProgressCreateOrConnectWithoutHiringManagerInput[]
    createMany?: OnboardingProgressCreateManyHiringManagerInputEnvelope
    connect?: OnboardingProgressWhereUniqueInput | OnboardingProgressWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput> | RequestCreateWithoutRequesterInput[] | RequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequesterInput | RequestCreateOrConnectWithoutRequesterInput[]
    createMany?: RequestCreateManyRequesterInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type RequestCreateNestedManyWithoutManagerInput = {
    create?: XOR<RequestCreateWithoutManagerInput, RequestUncheckedCreateWithoutManagerInput> | RequestCreateWithoutManagerInput[] | RequestUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutManagerInput | RequestCreateOrConnectWithoutManagerInput[]
    createMany?: RequestCreateManyManagerInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type RequestStatusHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutUserInput, RequestStatusHistoryUncheckedCreateWithoutUserInput> | RequestStatusHistoryCreateWithoutUserInput[] | RequestStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutUserInput | RequestStatusHistoryCreateOrConnectWithoutUserInput[]
    createMany?: RequestStatusHistoryCreateManyUserInputEnvelope
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutManagerInput = {
    create?: XOR<LeaveRequestCreateWithoutManagerInput, LeaveRequestUncheckedCreateWithoutManagerInput> | LeaveRequestCreateWithoutManagerInput[] | LeaveRequestUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutManagerInput | LeaveRequestCreateOrConnectWithoutManagerInput[]
    createMany?: LeaveRequestCreateManyManagerInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveStatusHistoryCreateNestedManyWithoutChangedByInput = {
    create?: XOR<LeaveStatusHistoryCreateWithoutChangedByInput, LeaveStatusHistoryUncheckedCreateWithoutChangedByInput> | LeaveStatusHistoryCreateWithoutChangedByInput[] | LeaveStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: LeaveStatusHistoryCreateOrConnectWithoutChangedByInput | LeaveStatusHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: LeaveStatusHistoryCreateManyChangedByInputEnvelope
    connect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutManagerInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type TimeEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type ShiftEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<ShiftEntryCreateWithoutUserInput, ShiftEntryUncheckedCreateWithoutUserInput> | ShiftEntryCreateWithoutUserInput[] | ShiftEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftEntryCreateOrConnectWithoutUserInput | ShiftEntryCreateOrConnectWithoutUserInput[]
    createMany?: ShiftEntryCreateManyUserInputEnvelope
    connect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutChangedByUserInput = {
    create?: XOR<AnnouncementCreateWithoutChangedByUserInput, AnnouncementUncheckedCreateWithoutChangedByUserInput> | AnnouncementCreateWithoutChangedByUserInput[] | AnnouncementUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutChangedByUserInput | AnnouncementCreateOrConnectWithoutChangedByUserInput[]
    createMany?: AnnouncementCreateManyChangedByUserInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutPublishedByUserInput = {
    create?: XOR<AnnouncementCreateWithoutPublishedByUserInput, AnnouncementUncheckedCreateWithoutPublishedByUserInput> | AnnouncementCreateWithoutPublishedByUserInput[] | AnnouncementUncheckedCreateWithoutPublishedByUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutPublishedByUserInput | AnnouncementCreateOrConnectWithoutPublishedByUserInput[]
    createMany?: AnnouncementCreateManyPublishedByUserInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type PositionCreateNestedOneWithoutUsersInput = {
    create?: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PositionCreateOrConnectWithoutUsersInput
    connect?: PositionWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutUsersInput = {
    create?: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUsersInput
    connect?: LocationWhereUniqueInput
  }

  export type CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CandidateNoteCreateWithoutCreatedByInput, CandidateNoteUncheckedCreateWithoutCreatedByInput> | CandidateNoteCreateWithoutCreatedByInput[] | CandidateNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CandidateNoteCreateOrConnectWithoutCreatedByInput | CandidateNoteCreateOrConnectWithoutCreatedByInput[]
    createMany?: CandidateNoteCreateManyCreatedByInputEnvelope
    connect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
  }

  export type JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<JobApplicationHistoryCreateWithoutChangedByInput, JobApplicationHistoryUncheckedCreateWithoutChangedByInput> | JobApplicationHistoryCreateWithoutChangedByInput[] | JobApplicationHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: JobApplicationHistoryCreateOrConnectWithoutChangedByInput | JobApplicationHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: JobApplicationHistoryCreateManyChangedByInputEnvelope
    connect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserStatusHistoryCreateWithoutUserInput, UserStatusHistoryUncheckedCreateWithoutUserInput> | UserStatusHistoryCreateWithoutUserInput[] | UserStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserStatusHistoryCreateOrConnectWithoutUserInput | UserStatusHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UserStatusHistoryCreateManyUserInputEnvelope
    connect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
  }

  export type UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<UserStatusHistoryCreateWithoutChangedByInput, UserStatusHistoryUncheckedCreateWithoutChangedByInput> | UserStatusHistoryCreateWithoutChangedByInput[] | UserStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: UserStatusHistoryCreateOrConnectWithoutChangedByInput | UserStatusHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: UserStatusHistoryCreateManyChangedByInputEnvelope
    connect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
  }

  export type PersonalInfoUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonalInfoCreateWithoutUserInput, PersonalInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutUserInput
    connect?: PersonalInfoWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<DocumentVerificationCreateWithoutReviewedByInput, DocumentVerificationUncheckedCreateWithoutReviewedByInput> | DocumentVerificationCreateWithoutReviewedByInput[] | DocumentVerificationUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutReviewedByInput | DocumentVerificationCreateOrConnectWithoutReviewedByInput[]
    createMany?: DocumentVerificationCreateManyReviewedByInputEnvelope
    connect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
  }

  export type DocumentVerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentVerificationCreateWithoutUserInput, DocumentVerificationUncheckedCreateWithoutUserInput> | DocumentVerificationCreateWithoutUserInput[] | DocumentVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutUserInput | DocumentVerificationCreateOrConnectWithoutUserInput[]
    createMany?: DocumentVerificationCreateManyUserInputEnvelope
    connect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
  }

  export type OnboardingProgressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    connect?: OnboardingProgressWhereUniqueInput
  }

  export type EmergencyContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
  }

  export type DependentMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DependentMemberCreateWithoutUserInput, DependentMemberUncheckedCreateWithoutUserInput> | DependentMemberCreateWithoutUserInput[] | DependentMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DependentMemberCreateOrConnectWithoutUserInput | DependentMemberCreateOrConnectWithoutUserInput[]
    createMany?: DependentMemberCreateManyUserInputEnvelope
    connect?: DependentMemberWhereUniqueInput | DependentMemberWhereUniqueInput[]
  }

  export type UserEmailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput> | UserEmailCreateWithoutUserInput[] | UserEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailCreateOrConnectWithoutUserInput | UserEmailCreateOrConnectWithoutUserInput[]
    createMany?: UserEmailCreateManyUserInputEnvelope
    connect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
  }

  export type UserPhoneUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput> | UserPhoneCreateWithoutUserInput[] | UserPhoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput | UserPhoneCreateOrConnectWithoutUserInput[]
    createMany?: UserPhoneCreateManyUserInputEnvelope
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
  }

  export type OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput = {
    create?: XOR<OnboardingProgressCreateWithoutHiringManagerInput, OnboardingProgressUncheckedCreateWithoutHiringManagerInput> | OnboardingProgressCreateWithoutHiringManagerInput[] | OnboardingProgressUncheckedCreateWithoutHiringManagerInput[]
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutHiringManagerInput | OnboardingProgressCreateOrConnectWithoutHiringManagerInput[]
    createMany?: OnboardingProgressCreateManyHiringManagerInputEnvelope
    connect?: OnboardingProgressWhereUniqueInput | OnboardingProgressWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput> | RequestCreateWithoutRequesterInput[] | RequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequesterInput | RequestCreateOrConnectWithoutRequesterInput[]
    createMany?: RequestCreateManyRequesterInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type RequestUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<RequestCreateWithoutManagerInput, RequestUncheckedCreateWithoutManagerInput> | RequestCreateWithoutManagerInput[] | RequestUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutManagerInput | RequestCreateOrConnectWithoutManagerInput[]
    createMany?: RequestCreateManyManagerInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutUserInput, RequestStatusHistoryUncheckedCreateWithoutUserInput> | RequestStatusHistoryCreateWithoutUserInput[] | RequestStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutUserInput | RequestStatusHistoryCreateOrConnectWithoutUserInput[]
    createMany?: RequestStatusHistoryCreateManyUserInputEnvelope
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<LeaveRequestCreateWithoutManagerInput, LeaveRequestUncheckedCreateWithoutManagerInput> | LeaveRequestCreateWithoutManagerInput[] | LeaveRequestUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutManagerInput | LeaveRequestCreateOrConnectWithoutManagerInput[]
    createMany?: LeaveRequestCreateManyManagerInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<LeaveStatusHistoryCreateWithoutChangedByInput, LeaveStatusHistoryUncheckedCreateWithoutChangedByInput> | LeaveStatusHistoryCreateWithoutChangedByInput[] | LeaveStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: LeaveStatusHistoryCreateOrConnectWithoutChangedByInput | LeaveStatusHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: LeaveStatusHistoryCreateManyChangedByInputEnvelope
    connect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type TimeEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type ShiftEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShiftEntryCreateWithoutUserInput, ShiftEntryUncheckedCreateWithoutUserInput> | ShiftEntryCreateWithoutUserInput[] | ShiftEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftEntryCreateOrConnectWithoutUserInput | ShiftEntryCreateOrConnectWithoutUserInput[]
    createMany?: ShiftEntryCreateManyUserInputEnvelope
    connect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput = {
    create?: XOR<AnnouncementCreateWithoutChangedByUserInput, AnnouncementUncheckedCreateWithoutChangedByUserInput> | AnnouncementCreateWithoutChangedByUserInput[] | AnnouncementUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutChangedByUserInput | AnnouncementCreateOrConnectWithoutChangedByUserInput[]
    createMany?: AnnouncementCreateManyChangedByUserInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput = {
    create?: XOR<AnnouncementCreateWithoutPublishedByUserInput, AnnouncementUncheckedCreateWithoutPublishedByUserInput> | AnnouncementCreateWithoutPublishedByUserInput[] | AnnouncementUncheckedCreateWithoutPublishedByUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutPublishedByUserInput | AnnouncementCreateOrConnectWithoutPublishedByUserInput[]
    createMany?: AnnouncementCreateManyPublishedByUserInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumEmploymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmploymentType
  }

  export type DepartmentUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    upsert?: DepartmentUpsertWithoutUsersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutUsersInput, DepartmentUpdateWithoutUsersInput>, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type CandidateNoteUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CandidateNoteCreateWithoutCreatedByInput, CandidateNoteUncheckedCreateWithoutCreatedByInput> | CandidateNoteCreateWithoutCreatedByInput[] | CandidateNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CandidateNoteCreateOrConnectWithoutCreatedByInput | CandidateNoteCreateOrConnectWithoutCreatedByInput[]
    upsert?: CandidateNoteUpsertWithWhereUniqueWithoutCreatedByInput | CandidateNoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CandidateNoteCreateManyCreatedByInputEnvelope
    set?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    disconnect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    delete?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    connect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    update?: CandidateNoteUpdateWithWhereUniqueWithoutCreatedByInput | CandidateNoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CandidateNoteUpdateManyWithWhereWithoutCreatedByInput | CandidateNoteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CandidateNoteScalarWhereInput | CandidateNoteScalarWhereInput[]
  }

  export type JobApplicationHistoryUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<JobApplicationHistoryCreateWithoutChangedByInput, JobApplicationHistoryUncheckedCreateWithoutChangedByInput> | JobApplicationHistoryCreateWithoutChangedByInput[] | JobApplicationHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: JobApplicationHistoryCreateOrConnectWithoutChangedByInput | JobApplicationHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: JobApplicationHistoryUpsertWithWhereUniqueWithoutChangedByInput | JobApplicationHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: JobApplicationHistoryCreateManyChangedByInputEnvelope
    set?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    disconnect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    delete?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    connect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    update?: JobApplicationHistoryUpdateWithWhereUniqueWithoutChangedByInput | JobApplicationHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: JobApplicationHistoryUpdateManyWithWhereWithoutChangedByInput | JobApplicationHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: JobApplicationHistoryScalarWhereInput | JobApplicationHistoryScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserStatusHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserStatusHistoryCreateWithoutUserInput, UserStatusHistoryUncheckedCreateWithoutUserInput> | UserStatusHistoryCreateWithoutUserInput[] | UserStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserStatusHistoryCreateOrConnectWithoutUserInput | UserStatusHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserStatusHistoryUpsertWithWhereUniqueWithoutUserInput | UserStatusHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserStatusHistoryCreateManyUserInputEnvelope
    set?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    disconnect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    delete?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    connect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    update?: UserStatusHistoryUpdateWithWhereUniqueWithoutUserInput | UserStatusHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserStatusHistoryUpdateManyWithWhereWithoutUserInput | UserStatusHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserStatusHistoryScalarWhereInput | UserStatusHistoryScalarWhereInput[]
  }

  export type UserStatusHistoryUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<UserStatusHistoryCreateWithoutChangedByInput, UserStatusHistoryUncheckedCreateWithoutChangedByInput> | UserStatusHistoryCreateWithoutChangedByInput[] | UserStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: UserStatusHistoryCreateOrConnectWithoutChangedByInput | UserStatusHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: UserStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput | UserStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: UserStatusHistoryCreateManyChangedByInputEnvelope
    set?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    disconnect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    delete?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    connect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    update?: UserStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput | UserStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: UserStatusHistoryUpdateManyWithWhereWithoutChangedByInput | UserStatusHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: UserStatusHistoryScalarWhereInput | UserStatusHistoryScalarWhereInput[]
  }

  export type PersonalInfoUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonalInfoCreateWithoutUserInput, PersonalInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutUserInput
    upsert?: PersonalInfoUpsertWithoutUserInput
    disconnect?: PersonalInfoWhereInput | boolean
    delete?: PersonalInfoWhereInput | boolean
    connect?: PersonalInfoWhereUniqueInput
    update?: XOR<XOR<PersonalInfoUpdateToOneWithWhereWithoutUserInput, PersonalInfoUpdateWithoutUserInput>, PersonalInfoUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentVerificationUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<DocumentVerificationCreateWithoutReviewedByInput, DocumentVerificationUncheckedCreateWithoutReviewedByInput> | DocumentVerificationCreateWithoutReviewedByInput[] | DocumentVerificationUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutReviewedByInput | DocumentVerificationCreateOrConnectWithoutReviewedByInput[]
    upsert?: DocumentVerificationUpsertWithWhereUniqueWithoutReviewedByInput | DocumentVerificationUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: DocumentVerificationCreateManyReviewedByInputEnvelope
    set?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    disconnect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    delete?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    connect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    update?: DocumentVerificationUpdateWithWhereUniqueWithoutReviewedByInput | DocumentVerificationUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: DocumentVerificationUpdateManyWithWhereWithoutReviewedByInput | DocumentVerificationUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: DocumentVerificationScalarWhereInput | DocumentVerificationScalarWhereInput[]
  }

  export type DocumentVerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentVerificationCreateWithoutUserInput, DocumentVerificationUncheckedCreateWithoutUserInput> | DocumentVerificationCreateWithoutUserInput[] | DocumentVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutUserInput | DocumentVerificationCreateOrConnectWithoutUserInput[]
    upsert?: DocumentVerificationUpsertWithWhereUniqueWithoutUserInput | DocumentVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentVerificationCreateManyUserInputEnvelope
    set?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    disconnect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    delete?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    connect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    update?: DocumentVerificationUpdateWithWhereUniqueWithoutUserInput | DocumentVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentVerificationUpdateManyWithWhereWithoutUserInput | DocumentVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentVerificationScalarWhereInput | DocumentVerificationScalarWhereInput[]
  }

  export type OnboardingProgressUpdateOneWithoutUserNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    upsert?: OnboardingProgressUpsertWithoutUserInput
    disconnect?: OnboardingProgressWhereInput | boolean
    delete?: OnboardingProgressWhereInput | boolean
    connect?: OnboardingProgressWhereUniqueInput
    update?: XOR<XOR<OnboardingProgressUpdateToOneWithWhereWithoutUserInput, OnboardingProgressUpdateWithoutUserInput>, OnboardingProgressUncheckedUpdateWithoutUserInput>
  }

  export type EmergencyContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutUserInput | EmergencyContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutUserInput | EmergencyContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutUserInput | EmergencyContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type DependentMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<DependentMemberCreateWithoutUserInput, DependentMemberUncheckedCreateWithoutUserInput> | DependentMemberCreateWithoutUserInput[] | DependentMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DependentMemberCreateOrConnectWithoutUserInput | DependentMemberCreateOrConnectWithoutUserInput[]
    upsert?: DependentMemberUpsertWithWhereUniqueWithoutUserInput | DependentMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DependentMemberCreateManyUserInputEnvelope
    set?: DependentMemberWhereUniqueInput | DependentMemberWhereUniqueInput[]
    disconnect?: DependentMemberWhereUniqueInput | DependentMemberWhereUniqueInput[]
    delete?: DependentMemberWhereUniqueInput | DependentMemberWhereUniqueInput[]
    connect?: DependentMemberWhereUniqueInput | DependentMemberWhereUniqueInput[]
    update?: DependentMemberUpdateWithWhereUniqueWithoutUserInput | DependentMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DependentMemberUpdateManyWithWhereWithoutUserInput | DependentMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DependentMemberScalarWhereInput | DependentMemberScalarWhereInput[]
  }

  export type UserEmailUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput> | UserEmailCreateWithoutUserInput[] | UserEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailCreateOrConnectWithoutUserInput | UserEmailCreateOrConnectWithoutUserInput[]
    upsert?: UserEmailUpsertWithWhereUniqueWithoutUserInput | UserEmailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserEmailCreateManyUserInputEnvelope
    set?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    disconnect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    delete?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    connect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    update?: UserEmailUpdateWithWhereUniqueWithoutUserInput | UserEmailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserEmailUpdateManyWithWhereWithoutUserInput | UserEmailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserEmailScalarWhereInput | UserEmailScalarWhereInput[]
  }

  export type UserPhoneUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput> | UserPhoneCreateWithoutUserInput[] | UserPhoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput | UserPhoneCreateOrConnectWithoutUserInput[]
    upsert?: UserPhoneUpsertWithWhereUniqueWithoutUserInput | UserPhoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPhoneCreateManyUserInputEnvelope
    set?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    disconnect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    delete?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    update?: UserPhoneUpdateWithWhereUniqueWithoutUserInput | UserPhoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPhoneUpdateManyWithWhereWithoutUserInput | UserPhoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPhoneScalarWhereInput | UserPhoneScalarWhereInput[]
  }

  export type OnboardingProgressUpdateManyWithoutHiringManagerNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutHiringManagerInput, OnboardingProgressUncheckedCreateWithoutHiringManagerInput> | OnboardingProgressCreateWithoutHiringManagerInput[] | OnboardingProgressUncheckedCreateWithoutHiringManagerInput[]
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutHiringManagerInput | OnboardingProgressCreateOrConnectWithoutHiringManagerInput[]
    upsert?: OnboardingProgressUpsertWithWhereUniqueWithoutHiringManagerInput | OnboardingProgressUpsertWithWhereUniqueWithoutHiringManagerInput[]
    createMany?: OnboardingProgressCreateManyHiringManagerInputEnvelope
    set?: OnboardingProgressWhereUniqueInput | OnboardingProgressWhereUniqueInput[]
    disconnect?: OnboardingProgressWhereUniqueInput | OnboardingProgressWhereUniqueInput[]
    delete?: OnboardingProgressWhereUniqueInput | OnboardingProgressWhereUniqueInput[]
    connect?: OnboardingProgressWhereUniqueInput | OnboardingProgressWhereUniqueInput[]
    update?: OnboardingProgressUpdateWithWhereUniqueWithoutHiringManagerInput | OnboardingProgressUpdateWithWhereUniqueWithoutHiringManagerInput[]
    updateMany?: OnboardingProgressUpdateManyWithWhereWithoutHiringManagerInput | OnboardingProgressUpdateManyWithWhereWithoutHiringManagerInput[]
    deleteMany?: OnboardingProgressScalarWhereInput | OnboardingProgressScalarWhereInput[]
  }

  export type UserUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeesInput
    upsert?: UserUpsertWithoutEmployeesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeesInput, UserUpdateWithoutEmployeesInput>, UserUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RequestUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput> | RequestCreateWithoutRequesterInput[] | RequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequesterInput | RequestCreateOrConnectWithoutRequesterInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutRequesterInput | RequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: RequestCreateManyRequesterInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutRequesterInput | RequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutRequesterInput | RequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type RequestUpdateManyWithoutManagerNestedInput = {
    create?: XOR<RequestCreateWithoutManagerInput, RequestUncheckedCreateWithoutManagerInput> | RequestCreateWithoutManagerInput[] | RequestUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutManagerInput | RequestCreateOrConnectWithoutManagerInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutManagerInput | RequestUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: RequestCreateManyManagerInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutManagerInput | RequestUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutManagerInput | RequestUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type RequestStatusHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutUserInput, RequestStatusHistoryUncheckedCreateWithoutUserInput> | RequestStatusHistoryCreateWithoutUserInput[] | RequestStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutUserInput | RequestStatusHistoryCreateOrConnectWithoutUserInput[]
    upsert?: RequestStatusHistoryUpsertWithWhereUniqueWithoutUserInput | RequestStatusHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RequestStatusHistoryCreateManyUserInputEnvelope
    set?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    disconnect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    delete?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    update?: RequestStatusHistoryUpdateWithWhereUniqueWithoutUserInput | RequestStatusHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RequestStatusHistoryUpdateManyWithWhereWithoutUserInput | RequestStatusHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RequestStatusHistoryScalarWhereInput | RequestStatusHistoryScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutManagerNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutManagerInput, LeaveRequestUncheckedCreateWithoutManagerInput> | LeaveRequestCreateWithoutManagerInput[] | LeaveRequestUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutManagerInput | LeaveRequestCreateOrConnectWithoutManagerInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutManagerInput | LeaveRequestUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: LeaveRequestCreateManyManagerInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutManagerInput | LeaveRequestUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutManagerInput | LeaveRequestUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<LeaveStatusHistoryCreateWithoutChangedByInput, LeaveStatusHistoryUncheckedCreateWithoutChangedByInput> | LeaveStatusHistoryCreateWithoutChangedByInput[] | LeaveStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: LeaveStatusHistoryCreateOrConnectWithoutChangedByInput | LeaveStatusHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: LeaveStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput | LeaveStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: LeaveStatusHistoryCreateManyChangedByInputEnvelope
    set?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    disconnect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    delete?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    connect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    update?: LeaveStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput | LeaveStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: LeaveStatusHistoryUpdateManyWithWhereWithoutChangedByInput | LeaveStatusHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: LeaveStatusHistoryScalarWhereInput | LeaveStatusHistoryScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutManagerInput | ProjectUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutManagerInput | ProjectUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutManagerInput | ProjectUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type TimeEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutUserInput | TimeEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutUserInput | TimeEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutUserInput | TimeEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type ShiftEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShiftEntryCreateWithoutUserInput, ShiftEntryUncheckedCreateWithoutUserInput> | ShiftEntryCreateWithoutUserInput[] | ShiftEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftEntryCreateOrConnectWithoutUserInput | ShiftEntryCreateOrConnectWithoutUserInput[]
    upsert?: ShiftEntryUpsertWithWhereUniqueWithoutUserInput | ShiftEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShiftEntryCreateManyUserInputEnvelope
    set?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    disconnect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    delete?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    connect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    update?: ShiftEntryUpdateWithWhereUniqueWithoutUserInput | ShiftEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShiftEntryUpdateManyWithWhereWithoutUserInput | ShiftEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShiftEntryScalarWhereInput | ShiftEntryScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutChangedByUserNestedInput = {
    create?: XOR<AnnouncementCreateWithoutChangedByUserInput, AnnouncementUncheckedCreateWithoutChangedByUserInput> | AnnouncementCreateWithoutChangedByUserInput[] | AnnouncementUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutChangedByUserInput | AnnouncementCreateOrConnectWithoutChangedByUserInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutChangedByUserInput | AnnouncementUpsertWithWhereUniqueWithoutChangedByUserInput[]
    createMany?: AnnouncementCreateManyChangedByUserInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutChangedByUserInput | AnnouncementUpdateWithWhereUniqueWithoutChangedByUserInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutChangedByUserInput | AnnouncementUpdateManyWithWhereWithoutChangedByUserInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutPublishedByUserNestedInput = {
    create?: XOR<AnnouncementCreateWithoutPublishedByUserInput, AnnouncementUncheckedCreateWithoutPublishedByUserInput> | AnnouncementCreateWithoutPublishedByUserInput[] | AnnouncementUncheckedCreateWithoutPublishedByUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutPublishedByUserInput | AnnouncementCreateOrConnectWithoutPublishedByUserInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutPublishedByUserInput | AnnouncementUpsertWithWhereUniqueWithoutPublishedByUserInput[]
    createMany?: AnnouncementCreateManyPublishedByUserInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutPublishedByUserInput | AnnouncementUpdateWithWhereUniqueWithoutPublishedByUserInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutPublishedByUserInput | AnnouncementUpdateManyWithWhereWithoutPublishedByUserInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type PositionUpdateOneWithoutUsersNestedInput = {
    create?: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PositionCreateOrConnectWithoutUsersInput
    upsert?: PositionUpsertWithoutUsersInput
    disconnect?: PositionWhereInput | boolean
    delete?: PositionWhereInput | boolean
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutUsersInput, PositionUpdateWithoutUsersInput>, PositionUncheckedUpdateWithoutUsersInput>
  }

  export type LocationUpdateOneWithoutUsersNestedInput = {
    create?: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUsersInput
    upsert?: LocationUpsertWithoutUsersInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutUsersInput, LocationUpdateWithoutUsersInput>, LocationUncheckedUpdateWithoutUsersInput>
  }

  export type CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CandidateNoteCreateWithoutCreatedByInput, CandidateNoteUncheckedCreateWithoutCreatedByInput> | CandidateNoteCreateWithoutCreatedByInput[] | CandidateNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CandidateNoteCreateOrConnectWithoutCreatedByInput | CandidateNoteCreateOrConnectWithoutCreatedByInput[]
    upsert?: CandidateNoteUpsertWithWhereUniqueWithoutCreatedByInput | CandidateNoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CandidateNoteCreateManyCreatedByInputEnvelope
    set?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    disconnect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    delete?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    connect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    update?: CandidateNoteUpdateWithWhereUniqueWithoutCreatedByInput | CandidateNoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CandidateNoteUpdateManyWithWhereWithoutCreatedByInput | CandidateNoteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CandidateNoteScalarWhereInput | CandidateNoteScalarWhereInput[]
  }

  export type JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<JobApplicationHistoryCreateWithoutChangedByInput, JobApplicationHistoryUncheckedCreateWithoutChangedByInput> | JobApplicationHistoryCreateWithoutChangedByInput[] | JobApplicationHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: JobApplicationHistoryCreateOrConnectWithoutChangedByInput | JobApplicationHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: JobApplicationHistoryUpsertWithWhereUniqueWithoutChangedByInput | JobApplicationHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: JobApplicationHistoryCreateManyChangedByInputEnvelope
    set?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    disconnect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    delete?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    connect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    update?: JobApplicationHistoryUpdateWithWhereUniqueWithoutChangedByInput | JobApplicationHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: JobApplicationHistoryUpdateManyWithWhereWithoutChangedByInput | JobApplicationHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: JobApplicationHistoryScalarWhereInput | JobApplicationHistoryScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserStatusHistoryCreateWithoutUserInput, UserStatusHistoryUncheckedCreateWithoutUserInput> | UserStatusHistoryCreateWithoutUserInput[] | UserStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserStatusHistoryCreateOrConnectWithoutUserInput | UserStatusHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UserStatusHistoryUpsertWithWhereUniqueWithoutUserInput | UserStatusHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserStatusHistoryCreateManyUserInputEnvelope
    set?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    disconnect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    delete?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    connect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    update?: UserStatusHistoryUpdateWithWhereUniqueWithoutUserInput | UserStatusHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserStatusHistoryUpdateManyWithWhereWithoutUserInput | UserStatusHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserStatusHistoryScalarWhereInput | UserStatusHistoryScalarWhereInput[]
  }

  export type UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<UserStatusHistoryCreateWithoutChangedByInput, UserStatusHistoryUncheckedCreateWithoutChangedByInput> | UserStatusHistoryCreateWithoutChangedByInput[] | UserStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: UserStatusHistoryCreateOrConnectWithoutChangedByInput | UserStatusHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: UserStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput | UserStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: UserStatusHistoryCreateManyChangedByInputEnvelope
    set?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    disconnect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    delete?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    connect?: UserStatusHistoryWhereUniqueInput | UserStatusHistoryWhereUniqueInput[]
    update?: UserStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput | UserStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: UserStatusHistoryUpdateManyWithWhereWithoutChangedByInput | UserStatusHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: UserStatusHistoryScalarWhereInput | UserStatusHistoryScalarWhereInput[]
  }

  export type PersonalInfoUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonalInfoCreateWithoutUserInput, PersonalInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutUserInput
    upsert?: PersonalInfoUpsertWithoutUserInput
    disconnect?: PersonalInfoWhereInput | boolean
    delete?: PersonalInfoWhereInput | boolean
    connect?: PersonalInfoWhereUniqueInput
    update?: XOR<XOR<PersonalInfoUpdateToOneWithWhereWithoutUserInput, PersonalInfoUpdateWithoutUserInput>, PersonalInfoUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<DocumentVerificationCreateWithoutReviewedByInput, DocumentVerificationUncheckedCreateWithoutReviewedByInput> | DocumentVerificationCreateWithoutReviewedByInput[] | DocumentVerificationUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutReviewedByInput | DocumentVerificationCreateOrConnectWithoutReviewedByInput[]
    upsert?: DocumentVerificationUpsertWithWhereUniqueWithoutReviewedByInput | DocumentVerificationUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: DocumentVerificationCreateManyReviewedByInputEnvelope
    set?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    disconnect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    delete?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    connect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    update?: DocumentVerificationUpdateWithWhereUniqueWithoutReviewedByInput | DocumentVerificationUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: DocumentVerificationUpdateManyWithWhereWithoutReviewedByInput | DocumentVerificationUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: DocumentVerificationScalarWhereInput | DocumentVerificationScalarWhereInput[]
  }

  export type DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentVerificationCreateWithoutUserInput, DocumentVerificationUncheckedCreateWithoutUserInput> | DocumentVerificationCreateWithoutUserInput[] | DocumentVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutUserInput | DocumentVerificationCreateOrConnectWithoutUserInput[]
    upsert?: DocumentVerificationUpsertWithWhereUniqueWithoutUserInput | DocumentVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentVerificationCreateManyUserInputEnvelope
    set?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    disconnect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    delete?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    connect?: DocumentVerificationWhereUniqueInput | DocumentVerificationWhereUniqueInput[]
    update?: DocumentVerificationUpdateWithWhereUniqueWithoutUserInput | DocumentVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentVerificationUpdateManyWithWhereWithoutUserInput | DocumentVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentVerificationScalarWhereInput | DocumentVerificationScalarWhereInput[]
  }

  export type OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    upsert?: OnboardingProgressUpsertWithoutUserInput
    disconnect?: OnboardingProgressWhereInput | boolean
    delete?: OnboardingProgressWhereInput | boolean
    connect?: OnboardingProgressWhereUniqueInput
    update?: XOR<XOR<OnboardingProgressUpdateToOneWithWhereWithoutUserInput, OnboardingProgressUpdateWithoutUserInput>, OnboardingProgressUncheckedUpdateWithoutUserInput>
  }

  export type EmergencyContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput> | EmergencyContactCreateWithoutUserInput[] | EmergencyContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmergencyContactCreateOrConnectWithoutUserInput | EmergencyContactCreateOrConnectWithoutUserInput[]
    upsert?: EmergencyContactUpsertWithWhereUniqueWithoutUserInput | EmergencyContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmergencyContactCreateManyUserInputEnvelope
    set?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    disconnect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    delete?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    connect?: EmergencyContactWhereUniqueInput | EmergencyContactWhereUniqueInput[]
    update?: EmergencyContactUpdateWithWhereUniqueWithoutUserInput | EmergencyContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmergencyContactUpdateManyWithWhereWithoutUserInput | EmergencyContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
  }

  export type DependentMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DependentMemberCreateWithoutUserInput, DependentMemberUncheckedCreateWithoutUserInput> | DependentMemberCreateWithoutUserInput[] | DependentMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DependentMemberCreateOrConnectWithoutUserInput | DependentMemberCreateOrConnectWithoutUserInput[]
    upsert?: DependentMemberUpsertWithWhereUniqueWithoutUserInput | DependentMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DependentMemberCreateManyUserInputEnvelope
    set?: DependentMemberWhereUniqueInput | DependentMemberWhereUniqueInput[]
    disconnect?: DependentMemberWhereUniqueInput | DependentMemberWhereUniqueInput[]
    delete?: DependentMemberWhereUniqueInput | DependentMemberWhereUniqueInput[]
    connect?: DependentMemberWhereUniqueInput | DependentMemberWhereUniqueInput[]
    update?: DependentMemberUpdateWithWhereUniqueWithoutUserInput | DependentMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DependentMemberUpdateManyWithWhereWithoutUserInput | DependentMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DependentMemberScalarWhereInput | DependentMemberScalarWhereInput[]
  }

  export type UserEmailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput> | UserEmailCreateWithoutUserInput[] | UserEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailCreateOrConnectWithoutUserInput | UserEmailCreateOrConnectWithoutUserInput[]
    upsert?: UserEmailUpsertWithWhereUniqueWithoutUserInput | UserEmailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserEmailCreateManyUserInputEnvelope
    set?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    disconnect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    delete?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    connect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    update?: UserEmailUpdateWithWhereUniqueWithoutUserInput | UserEmailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserEmailUpdateManyWithWhereWithoutUserInput | UserEmailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserEmailScalarWhereInput | UserEmailScalarWhereInput[]
  }

  export type UserPhoneUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput> | UserPhoneCreateWithoutUserInput[] | UserPhoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput | UserPhoneCreateOrConnectWithoutUserInput[]
    upsert?: UserPhoneUpsertWithWhereUniqueWithoutUserInput | UserPhoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPhoneCreateManyUserInputEnvelope
    set?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    disconnect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    delete?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    update?: UserPhoneUpdateWithWhereUniqueWithoutUserInput | UserPhoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPhoneUpdateManyWithWhereWithoutUserInput | UserPhoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPhoneScalarWhereInput | UserPhoneScalarWhereInput[]
  }

  export type OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutHiringManagerInput, OnboardingProgressUncheckedCreateWithoutHiringManagerInput> | OnboardingProgressCreateWithoutHiringManagerInput[] | OnboardingProgressUncheckedCreateWithoutHiringManagerInput[]
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutHiringManagerInput | OnboardingProgressCreateOrConnectWithoutHiringManagerInput[]
    upsert?: OnboardingProgressUpsertWithWhereUniqueWithoutHiringManagerInput | OnboardingProgressUpsertWithWhereUniqueWithoutHiringManagerInput[]
    createMany?: OnboardingProgressCreateManyHiringManagerInputEnvelope
    set?: OnboardingProgressWhereUniqueInput | OnboardingProgressWhereUniqueInput[]
    disconnect?: OnboardingProgressWhereUniqueInput | OnboardingProgressWhereUniqueInput[]
    delete?: OnboardingProgressWhereUniqueInput | OnboardingProgressWhereUniqueInput[]
    connect?: OnboardingProgressWhereUniqueInput | OnboardingProgressWhereUniqueInput[]
    update?: OnboardingProgressUpdateWithWhereUniqueWithoutHiringManagerInput | OnboardingProgressUpdateWithWhereUniqueWithoutHiringManagerInput[]
    updateMany?: OnboardingProgressUpdateManyWithWhereWithoutHiringManagerInput | OnboardingProgressUpdateManyWithWhereWithoutHiringManagerInput[]
    deleteMany?: OnboardingProgressScalarWhereInput | OnboardingProgressScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RequestUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput> | RequestCreateWithoutRequesterInput[] | RequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequesterInput | RequestCreateOrConnectWithoutRequesterInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutRequesterInput | RequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: RequestCreateManyRequesterInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutRequesterInput | RequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutRequesterInput | RequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type RequestUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<RequestCreateWithoutManagerInput, RequestUncheckedCreateWithoutManagerInput> | RequestCreateWithoutManagerInput[] | RequestUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutManagerInput | RequestCreateOrConnectWithoutManagerInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutManagerInput | RequestUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: RequestCreateManyManagerInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutManagerInput | RequestUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutManagerInput | RequestUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutUserInput, RequestStatusHistoryUncheckedCreateWithoutUserInput> | RequestStatusHistoryCreateWithoutUserInput[] | RequestStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutUserInput | RequestStatusHistoryCreateOrConnectWithoutUserInput[]
    upsert?: RequestStatusHistoryUpsertWithWhereUniqueWithoutUserInput | RequestStatusHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RequestStatusHistoryCreateManyUserInputEnvelope
    set?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    disconnect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    delete?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    update?: RequestStatusHistoryUpdateWithWhereUniqueWithoutUserInput | RequestStatusHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RequestStatusHistoryUpdateManyWithWhereWithoutUserInput | RequestStatusHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RequestStatusHistoryScalarWhereInput | RequestStatusHistoryScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutManagerInput, LeaveRequestUncheckedCreateWithoutManagerInput> | LeaveRequestCreateWithoutManagerInput[] | LeaveRequestUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutManagerInput | LeaveRequestCreateOrConnectWithoutManagerInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutManagerInput | LeaveRequestUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: LeaveRequestCreateManyManagerInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutManagerInput | LeaveRequestUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutManagerInput | LeaveRequestUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<LeaveStatusHistoryCreateWithoutChangedByInput, LeaveStatusHistoryUncheckedCreateWithoutChangedByInput> | LeaveStatusHistoryCreateWithoutChangedByInput[] | LeaveStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: LeaveStatusHistoryCreateOrConnectWithoutChangedByInput | LeaveStatusHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: LeaveStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput | LeaveStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: LeaveStatusHistoryCreateManyChangedByInputEnvelope
    set?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    disconnect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    delete?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    connect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    update?: LeaveStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput | LeaveStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: LeaveStatusHistoryUpdateManyWithWhereWithoutChangedByInput | LeaveStatusHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: LeaveStatusHistoryScalarWhereInput | LeaveStatusHistoryScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutManagerInput | ProjectUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutManagerInput | ProjectUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutManagerInput | ProjectUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type TimeEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutUserInput | TimeEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutUserInput | TimeEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutUserInput | TimeEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type ShiftEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShiftEntryCreateWithoutUserInput, ShiftEntryUncheckedCreateWithoutUserInput> | ShiftEntryCreateWithoutUserInput[] | ShiftEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftEntryCreateOrConnectWithoutUserInput | ShiftEntryCreateOrConnectWithoutUserInput[]
    upsert?: ShiftEntryUpsertWithWhereUniqueWithoutUserInput | ShiftEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShiftEntryCreateManyUserInputEnvelope
    set?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    disconnect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    delete?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    connect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    update?: ShiftEntryUpdateWithWhereUniqueWithoutUserInput | ShiftEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShiftEntryUpdateManyWithWhereWithoutUserInput | ShiftEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShiftEntryScalarWhereInput | ShiftEntryScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput = {
    create?: XOR<AnnouncementCreateWithoutChangedByUserInput, AnnouncementUncheckedCreateWithoutChangedByUserInput> | AnnouncementCreateWithoutChangedByUserInput[] | AnnouncementUncheckedCreateWithoutChangedByUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutChangedByUserInput | AnnouncementCreateOrConnectWithoutChangedByUserInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutChangedByUserInput | AnnouncementUpsertWithWhereUniqueWithoutChangedByUserInput[]
    createMany?: AnnouncementCreateManyChangedByUserInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutChangedByUserInput | AnnouncementUpdateWithWhereUniqueWithoutChangedByUserInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutChangedByUserInput | AnnouncementUpdateManyWithWhereWithoutChangedByUserInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput = {
    create?: XOR<AnnouncementCreateWithoutPublishedByUserInput, AnnouncementUncheckedCreateWithoutPublishedByUserInput> | AnnouncementCreateWithoutPublishedByUserInput[] | AnnouncementUncheckedCreateWithoutPublishedByUserInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutPublishedByUserInput | AnnouncementCreateOrConnectWithoutPublishedByUserInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutPublishedByUserInput | AnnouncementUpsertWithWhereUniqueWithoutPublishedByUserInput[]
    createMany?: AnnouncementCreateManyPublishedByUserInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutPublishedByUserInput | AnnouncementUpdateWithWhereUniqueWithoutPublishedByUserInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutPublishedByUserInput | AnnouncementUpdateManyWithWhereWithoutPublishedByUserInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<UserCreateWithoutStatusHistoryInput, UserUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStatusChangesByInput = {
    create?: XOR<UserCreateWithoutStatusChangesByInput, UserUncheckedCreateWithoutStatusChangesByInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusChangesByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<UserCreateWithoutStatusHistoryInput, UserUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusHistoryInput
    upsert?: UserUpsertWithoutStatusHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatusHistoryInput, UserUpdateWithoutStatusHistoryInput>, UserUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutStatusChangesByNestedInput = {
    create?: XOR<UserCreateWithoutStatusChangesByInput, UserUncheckedCreateWithoutStatusChangesByInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusChangesByInput
    upsert?: UserUpsertWithoutStatusChangesByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatusChangesByInput, UserUpdateWithoutStatusChangesByInput>, UserUncheckedUpdateWithoutStatusChangesByInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CandidateCreateNestedOneWithoutNotesInput = {
    create?: XOR<CandidateCreateWithoutNotesInput, CandidateUncheckedCreateWithoutNotesInput>
    connectOrCreate?: CandidateCreateOrConnectWithoutNotesInput
    connect?: CandidateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCandidateNotesInput = {
    create?: XOR<UserCreateWithoutCandidateNotesInput, UserUncheckedCreateWithoutCandidateNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCandidateNotesInput
    connect?: UserWhereUniqueInput
  }

  export type CandidateUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<CandidateCreateWithoutNotesInput, CandidateUncheckedCreateWithoutNotesInput>
    connectOrCreate?: CandidateCreateOrConnectWithoutNotesInput
    upsert?: CandidateUpsertWithoutNotesInput
    connect?: CandidateWhereUniqueInput
    update?: XOR<XOR<CandidateUpdateToOneWithWhereWithoutNotesInput, CandidateUpdateWithoutNotesInput>, CandidateUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutCandidateNotesNestedInput = {
    create?: XOR<UserCreateWithoutCandidateNotesInput, UserUncheckedCreateWithoutCandidateNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCandidateNotesInput
    upsert?: UserUpsertWithoutCandidateNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCandidateNotesInput, UserUpdateWithoutCandidateNotesInput>, UserUncheckedUpdateWithoutCandidateNotesInput>
  }

  export type JobListingCreatekeywordsInput = {
    set: string[]
  }

  export type DepartmentCreateNestedOneWithoutJobListingInput = {
    create?: XOR<DepartmentCreateWithoutJobListingInput, DepartmentUncheckedCreateWithoutJobListingInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutJobListingInput
    connect?: DepartmentWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutJobListingInput = {
    create?: XOR<LocationCreateWithoutJobListingInput, LocationUncheckedCreateWithoutJobListingInput>
    connectOrCreate?: LocationCreateOrConnectWithoutJobListingInput
    connect?: LocationWhereUniqueInput
  }

  export type JobApplicationCreateNestedManyWithoutJobListingInput = {
    create?: XOR<JobApplicationCreateWithoutJobListingInput, JobApplicationUncheckedCreateWithoutJobListingInput> | JobApplicationCreateWithoutJobListingInput[] | JobApplicationUncheckedCreateWithoutJobListingInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobListingInput | JobApplicationCreateOrConnectWithoutJobListingInput[]
    createMany?: JobApplicationCreateManyJobListingInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type PositionCreateNestedOneWithoutJobListingsInput = {
    create?: XOR<PositionCreateWithoutJobListingsInput, PositionUncheckedCreateWithoutJobListingsInput>
    connectOrCreate?: PositionCreateOrConnectWithoutJobListingsInput
    connect?: PositionWhereUniqueInput
  }

  export type JobApplicationUncheckedCreateNestedManyWithoutJobListingInput = {
    create?: XOR<JobApplicationCreateWithoutJobListingInput, JobApplicationUncheckedCreateWithoutJobListingInput> | JobApplicationCreateWithoutJobListingInput[] | JobApplicationUncheckedCreateWithoutJobListingInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobListingInput | JobApplicationCreateOrConnectWithoutJobListingInput[]
    createMany?: JobApplicationCreateManyJobListingInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type EnumWorkplaceTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkplaceType
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type JobListingUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DepartmentUpdateOneWithoutJobListingNestedInput = {
    create?: XOR<DepartmentCreateWithoutJobListingInput, DepartmentUncheckedCreateWithoutJobListingInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutJobListingInput
    upsert?: DepartmentUpsertWithoutJobListingInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutJobListingInput, DepartmentUpdateWithoutJobListingInput>, DepartmentUncheckedUpdateWithoutJobListingInput>
  }

  export type LocationUpdateOneWithoutJobListingNestedInput = {
    create?: XOR<LocationCreateWithoutJobListingInput, LocationUncheckedCreateWithoutJobListingInput>
    connectOrCreate?: LocationCreateOrConnectWithoutJobListingInput
    upsert?: LocationUpsertWithoutJobListingInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutJobListingInput, LocationUpdateWithoutJobListingInput>, LocationUncheckedUpdateWithoutJobListingInput>
  }

  export type JobApplicationUpdateManyWithoutJobListingNestedInput = {
    create?: XOR<JobApplicationCreateWithoutJobListingInput, JobApplicationUncheckedCreateWithoutJobListingInput> | JobApplicationCreateWithoutJobListingInput[] | JobApplicationUncheckedCreateWithoutJobListingInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobListingInput | JobApplicationCreateOrConnectWithoutJobListingInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutJobListingInput | JobApplicationUpsertWithWhereUniqueWithoutJobListingInput[]
    createMany?: JobApplicationCreateManyJobListingInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutJobListingInput | JobApplicationUpdateWithWhereUniqueWithoutJobListingInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutJobListingInput | JobApplicationUpdateManyWithWhereWithoutJobListingInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type PositionUpdateOneWithoutJobListingsNestedInput = {
    create?: XOR<PositionCreateWithoutJobListingsInput, PositionUncheckedCreateWithoutJobListingsInput>
    connectOrCreate?: PositionCreateOrConnectWithoutJobListingsInput
    upsert?: PositionUpsertWithoutJobListingsInput
    disconnect?: PositionWhereInput | boolean
    delete?: PositionWhereInput | boolean
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutJobListingsInput, PositionUpdateWithoutJobListingsInput>, PositionUncheckedUpdateWithoutJobListingsInput>
  }

  export type JobApplicationUncheckedUpdateManyWithoutJobListingNestedInput = {
    create?: XOR<JobApplicationCreateWithoutJobListingInput, JobApplicationUncheckedCreateWithoutJobListingInput> | JobApplicationCreateWithoutJobListingInput[] | JobApplicationUncheckedCreateWithoutJobListingInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobListingInput | JobApplicationCreateOrConnectWithoutJobListingInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutJobListingInput | JobApplicationUpsertWithWhereUniqueWithoutJobListingInput[]
    createMany?: JobApplicationCreateManyJobListingInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutJobListingInput | JobApplicationUpdateWithWhereUniqueWithoutJobListingInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutJobListingInput | JobApplicationUpdateManyWithWhereWithoutJobListingInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type JobApplicationCreateNestedManyWithoutCandidateInput = {
    create?: XOR<JobApplicationCreateWithoutCandidateInput, JobApplicationUncheckedCreateWithoutCandidateInput> | JobApplicationCreateWithoutCandidateInput[] | JobApplicationUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutCandidateInput | JobApplicationCreateOrConnectWithoutCandidateInput[]
    createMany?: JobApplicationCreateManyCandidateInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type CandidateNoteCreateNestedManyWithoutCandidateInput = {
    create?: XOR<CandidateNoteCreateWithoutCandidateInput, CandidateNoteUncheckedCreateWithoutCandidateInput> | CandidateNoteCreateWithoutCandidateInput[] | CandidateNoteUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: CandidateNoteCreateOrConnectWithoutCandidateInput | CandidateNoteCreateOrConnectWithoutCandidateInput[]
    createMany?: CandidateNoteCreateManyCandidateInputEnvelope
    connect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
  }

  export type JobApplicationUncheckedCreateNestedManyWithoutCandidateInput = {
    create?: XOR<JobApplicationCreateWithoutCandidateInput, JobApplicationUncheckedCreateWithoutCandidateInput> | JobApplicationCreateWithoutCandidateInput[] | JobApplicationUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutCandidateInput | JobApplicationCreateOrConnectWithoutCandidateInput[]
    createMany?: JobApplicationCreateManyCandidateInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type CandidateNoteUncheckedCreateNestedManyWithoutCandidateInput = {
    create?: XOR<CandidateNoteCreateWithoutCandidateInput, CandidateNoteUncheckedCreateWithoutCandidateInput> | CandidateNoteCreateWithoutCandidateInput[] | CandidateNoteUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: CandidateNoteCreateOrConnectWithoutCandidateInput | CandidateNoteCreateOrConnectWithoutCandidateInput[]
    createMany?: CandidateNoteCreateManyCandidateInputEnvelope
    connect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
  }

  export type JobApplicationUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<JobApplicationCreateWithoutCandidateInput, JobApplicationUncheckedCreateWithoutCandidateInput> | JobApplicationCreateWithoutCandidateInput[] | JobApplicationUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutCandidateInput | JobApplicationCreateOrConnectWithoutCandidateInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutCandidateInput | JobApplicationUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: JobApplicationCreateManyCandidateInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutCandidateInput | JobApplicationUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutCandidateInput | JobApplicationUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type CandidateNoteUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<CandidateNoteCreateWithoutCandidateInput, CandidateNoteUncheckedCreateWithoutCandidateInput> | CandidateNoteCreateWithoutCandidateInput[] | CandidateNoteUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: CandidateNoteCreateOrConnectWithoutCandidateInput | CandidateNoteCreateOrConnectWithoutCandidateInput[]
    upsert?: CandidateNoteUpsertWithWhereUniqueWithoutCandidateInput | CandidateNoteUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: CandidateNoteCreateManyCandidateInputEnvelope
    set?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    disconnect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    delete?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    connect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    update?: CandidateNoteUpdateWithWhereUniqueWithoutCandidateInput | CandidateNoteUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: CandidateNoteUpdateManyWithWhereWithoutCandidateInput | CandidateNoteUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: CandidateNoteScalarWhereInput | CandidateNoteScalarWhereInput[]
  }

  export type JobApplicationUncheckedUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<JobApplicationCreateWithoutCandidateInput, JobApplicationUncheckedCreateWithoutCandidateInput> | JobApplicationCreateWithoutCandidateInput[] | JobApplicationUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutCandidateInput | JobApplicationCreateOrConnectWithoutCandidateInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutCandidateInput | JobApplicationUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: JobApplicationCreateManyCandidateInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutCandidateInput | JobApplicationUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutCandidateInput | JobApplicationUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type CandidateNoteUncheckedUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<CandidateNoteCreateWithoutCandidateInput, CandidateNoteUncheckedCreateWithoutCandidateInput> | CandidateNoteCreateWithoutCandidateInput[] | CandidateNoteUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: CandidateNoteCreateOrConnectWithoutCandidateInput | CandidateNoteCreateOrConnectWithoutCandidateInput[]
    upsert?: CandidateNoteUpsertWithWhereUniqueWithoutCandidateInput | CandidateNoteUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: CandidateNoteCreateManyCandidateInputEnvelope
    set?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    disconnect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    delete?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    connect?: CandidateNoteWhereUniqueInput | CandidateNoteWhereUniqueInput[]
    update?: CandidateNoteUpdateWithWhereUniqueWithoutCandidateInput | CandidateNoteUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: CandidateNoteUpdateManyWithWhereWithoutCandidateInput | CandidateNoteUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: CandidateNoteScalarWhereInput | CandidateNoteScalarWhereInput[]
  }

  export type CandidateCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<CandidateCreateWithoutApplicationsInput, CandidateUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: CandidateCreateOrConnectWithoutApplicationsInput
    connect?: CandidateWhereUniqueInput
  }

  export type JobListingCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<JobListingCreateWithoutApplicationsInput, JobListingUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: JobListingCreateOrConnectWithoutApplicationsInput
    connect?: JobListingWhereUniqueInput
  }

  export type JobApplicationHistoryCreateNestedManyWithoutApplicationInput = {
    create?: XOR<JobApplicationHistoryCreateWithoutApplicationInput, JobApplicationHistoryUncheckedCreateWithoutApplicationInput> | JobApplicationHistoryCreateWithoutApplicationInput[] | JobApplicationHistoryUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: JobApplicationHistoryCreateOrConnectWithoutApplicationInput | JobApplicationHistoryCreateOrConnectWithoutApplicationInput[]
    createMany?: JobApplicationHistoryCreateManyApplicationInputEnvelope
    connect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
  }

  export type CvAnalysisCreateNestedOneWithoutApplicationInput = {
    create?: XOR<CvAnalysisCreateWithoutApplicationInput, CvAnalysisUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: CvAnalysisCreateOrConnectWithoutApplicationInput
    connect?: CvAnalysisWhereUniqueInput
  }

  export type OnboardingProgressCreateNestedOneWithoutApplicationInput = {
    create?: XOR<OnboardingProgressCreateWithoutApplicationInput, OnboardingProgressUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutApplicationInput
    connect?: OnboardingProgressWhereUniqueInput
  }

  export type OnboardingInvitationCreateNestedOneWithoutApplicationInput = {
    create?: XOR<OnboardingInvitationCreateWithoutApplicationInput, OnboardingInvitationUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: OnboardingInvitationCreateOrConnectWithoutApplicationInput
    connect?: OnboardingInvitationWhereUniqueInput
  }

  export type JobApplicationHistoryUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<JobApplicationHistoryCreateWithoutApplicationInput, JobApplicationHistoryUncheckedCreateWithoutApplicationInput> | JobApplicationHistoryCreateWithoutApplicationInput[] | JobApplicationHistoryUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: JobApplicationHistoryCreateOrConnectWithoutApplicationInput | JobApplicationHistoryCreateOrConnectWithoutApplicationInput[]
    createMany?: JobApplicationHistoryCreateManyApplicationInputEnvelope
    connect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
  }

  export type CvAnalysisUncheckedCreateNestedOneWithoutApplicationInput = {
    create?: XOR<CvAnalysisCreateWithoutApplicationInput, CvAnalysisUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: CvAnalysisCreateOrConnectWithoutApplicationInput
    connect?: CvAnalysisWhereUniqueInput
  }

  export type OnboardingProgressUncheckedCreateNestedOneWithoutApplicationInput = {
    create?: XOR<OnboardingProgressCreateWithoutApplicationInput, OnboardingProgressUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutApplicationInput
    connect?: OnboardingProgressWhereUniqueInput
  }

  export type OnboardingInvitationUncheckedCreateNestedOneWithoutApplicationInput = {
    create?: XOR<OnboardingInvitationCreateWithoutApplicationInput, OnboardingInvitationUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: OnboardingInvitationCreateOrConnectWithoutApplicationInput
    connect?: OnboardingInvitationWhereUniqueInput
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type CandidateUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<CandidateCreateWithoutApplicationsInput, CandidateUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: CandidateCreateOrConnectWithoutApplicationsInput
    upsert?: CandidateUpsertWithoutApplicationsInput
    connect?: CandidateWhereUniqueInput
    update?: XOR<XOR<CandidateUpdateToOneWithWhereWithoutApplicationsInput, CandidateUpdateWithoutApplicationsInput>, CandidateUncheckedUpdateWithoutApplicationsInput>
  }

  export type JobListingUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<JobListingCreateWithoutApplicationsInput, JobListingUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: JobListingCreateOrConnectWithoutApplicationsInput
    upsert?: JobListingUpsertWithoutApplicationsInput
    connect?: JobListingWhereUniqueInput
    update?: XOR<XOR<JobListingUpdateToOneWithWhereWithoutApplicationsInput, JobListingUpdateWithoutApplicationsInput>, JobListingUncheckedUpdateWithoutApplicationsInput>
  }

  export type JobApplicationHistoryUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<JobApplicationHistoryCreateWithoutApplicationInput, JobApplicationHistoryUncheckedCreateWithoutApplicationInput> | JobApplicationHistoryCreateWithoutApplicationInput[] | JobApplicationHistoryUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: JobApplicationHistoryCreateOrConnectWithoutApplicationInput | JobApplicationHistoryCreateOrConnectWithoutApplicationInput[]
    upsert?: JobApplicationHistoryUpsertWithWhereUniqueWithoutApplicationInput | JobApplicationHistoryUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: JobApplicationHistoryCreateManyApplicationInputEnvelope
    set?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    disconnect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    delete?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    connect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    update?: JobApplicationHistoryUpdateWithWhereUniqueWithoutApplicationInput | JobApplicationHistoryUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: JobApplicationHistoryUpdateManyWithWhereWithoutApplicationInput | JobApplicationHistoryUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: JobApplicationHistoryScalarWhereInput | JobApplicationHistoryScalarWhereInput[]
  }

  export type CvAnalysisUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<CvAnalysisCreateWithoutApplicationInput, CvAnalysisUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: CvAnalysisCreateOrConnectWithoutApplicationInput
    upsert?: CvAnalysisUpsertWithoutApplicationInput
    disconnect?: CvAnalysisWhereInput | boolean
    delete?: CvAnalysisWhereInput | boolean
    connect?: CvAnalysisWhereUniqueInput
    update?: XOR<XOR<CvAnalysisUpdateToOneWithWhereWithoutApplicationInput, CvAnalysisUpdateWithoutApplicationInput>, CvAnalysisUncheckedUpdateWithoutApplicationInput>
  }

  export type OnboardingProgressUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutApplicationInput, OnboardingProgressUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutApplicationInput
    upsert?: OnboardingProgressUpsertWithoutApplicationInput
    disconnect?: OnboardingProgressWhereInput | boolean
    delete?: OnboardingProgressWhereInput | boolean
    connect?: OnboardingProgressWhereUniqueInput
    update?: XOR<XOR<OnboardingProgressUpdateToOneWithWhereWithoutApplicationInput, OnboardingProgressUpdateWithoutApplicationInput>, OnboardingProgressUncheckedUpdateWithoutApplicationInput>
  }

  export type OnboardingInvitationUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<OnboardingInvitationCreateWithoutApplicationInput, OnboardingInvitationUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: OnboardingInvitationCreateOrConnectWithoutApplicationInput
    upsert?: OnboardingInvitationUpsertWithoutApplicationInput
    disconnect?: OnboardingInvitationWhereInput | boolean
    delete?: OnboardingInvitationWhereInput | boolean
    connect?: OnboardingInvitationWhereUniqueInput
    update?: XOR<XOR<OnboardingInvitationUpdateToOneWithWhereWithoutApplicationInput, OnboardingInvitationUpdateWithoutApplicationInput>, OnboardingInvitationUncheckedUpdateWithoutApplicationInput>
  }

  export type JobApplicationHistoryUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<JobApplicationHistoryCreateWithoutApplicationInput, JobApplicationHistoryUncheckedCreateWithoutApplicationInput> | JobApplicationHistoryCreateWithoutApplicationInput[] | JobApplicationHistoryUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: JobApplicationHistoryCreateOrConnectWithoutApplicationInput | JobApplicationHistoryCreateOrConnectWithoutApplicationInput[]
    upsert?: JobApplicationHistoryUpsertWithWhereUniqueWithoutApplicationInput | JobApplicationHistoryUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: JobApplicationHistoryCreateManyApplicationInputEnvelope
    set?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    disconnect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    delete?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    connect?: JobApplicationHistoryWhereUniqueInput | JobApplicationHistoryWhereUniqueInput[]
    update?: JobApplicationHistoryUpdateWithWhereUniqueWithoutApplicationInput | JobApplicationHistoryUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: JobApplicationHistoryUpdateManyWithWhereWithoutApplicationInput | JobApplicationHistoryUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: JobApplicationHistoryScalarWhereInput | JobApplicationHistoryScalarWhereInput[]
  }

  export type CvAnalysisUncheckedUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<CvAnalysisCreateWithoutApplicationInput, CvAnalysisUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: CvAnalysisCreateOrConnectWithoutApplicationInput
    upsert?: CvAnalysisUpsertWithoutApplicationInput
    disconnect?: CvAnalysisWhereInput | boolean
    delete?: CvAnalysisWhereInput | boolean
    connect?: CvAnalysisWhereUniqueInput
    update?: XOR<XOR<CvAnalysisUpdateToOneWithWhereWithoutApplicationInput, CvAnalysisUpdateWithoutApplicationInput>, CvAnalysisUncheckedUpdateWithoutApplicationInput>
  }

  export type OnboardingProgressUncheckedUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutApplicationInput, OnboardingProgressUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutApplicationInput
    upsert?: OnboardingProgressUpsertWithoutApplicationInput
    disconnect?: OnboardingProgressWhereInput | boolean
    delete?: OnboardingProgressWhereInput | boolean
    connect?: OnboardingProgressWhereUniqueInput
    update?: XOR<XOR<OnboardingProgressUpdateToOneWithWhereWithoutApplicationInput, OnboardingProgressUpdateWithoutApplicationInput>, OnboardingProgressUncheckedUpdateWithoutApplicationInput>
  }

  export type OnboardingInvitationUncheckedUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<OnboardingInvitationCreateWithoutApplicationInput, OnboardingInvitationUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: OnboardingInvitationCreateOrConnectWithoutApplicationInput
    upsert?: OnboardingInvitationUpsertWithoutApplicationInput
    disconnect?: OnboardingInvitationWhereInput | boolean
    delete?: OnboardingInvitationWhereInput | boolean
    connect?: OnboardingInvitationWhereUniqueInput
    update?: XOR<XOR<OnboardingInvitationUpdateToOneWithWhereWithoutApplicationInput, OnboardingInvitationUpdateWithoutApplicationInput>, OnboardingInvitationUncheckedUpdateWithoutApplicationInput>
  }

  export type JobApplicationCreateNestedOneWithoutCvAnalysisInput = {
    create?: XOR<JobApplicationCreateWithoutCvAnalysisInput, JobApplicationUncheckedCreateWithoutCvAnalysisInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutCvAnalysisInput
    connect?: JobApplicationWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobApplicationUpdateOneRequiredWithoutCvAnalysisNestedInput = {
    create?: XOR<JobApplicationCreateWithoutCvAnalysisInput, JobApplicationUncheckedCreateWithoutCvAnalysisInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutCvAnalysisInput
    upsert?: JobApplicationUpsertWithoutCvAnalysisInput
    connect?: JobApplicationWhereUniqueInput
    update?: XOR<XOR<JobApplicationUpdateToOneWithWhereWithoutCvAnalysisInput, JobApplicationUpdateWithoutCvAnalysisInput>, JobApplicationUncheckedUpdateWithoutCvAnalysisInput>
  }

  export type JobApplicationCreateNestedOneWithoutHistoryInput = {
    create?: XOR<JobApplicationCreateWithoutHistoryInput, JobApplicationUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutHistoryInput
    connect?: JobApplicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutJobApplicationHistoryInput = {
    create?: XOR<UserCreateWithoutJobApplicationHistoryInput, UserUncheckedCreateWithoutJobApplicationHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobApplicationHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type JobApplicationUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<JobApplicationCreateWithoutHistoryInput, JobApplicationUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutHistoryInput
    upsert?: JobApplicationUpsertWithoutHistoryInput
    connect?: JobApplicationWhereUniqueInput
    update?: XOR<XOR<JobApplicationUpdateToOneWithWhereWithoutHistoryInput, JobApplicationUpdateWithoutHistoryInput>, JobApplicationUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneWithoutJobApplicationHistoryNestedInput = {
    create?: XOR<UserCreateWithoutJobApplicationHistoryInput, UserUncheckedCreateWithoutJobApplicationHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobApplicationHistoryInput
    upsert?: UserUpsertWithoutJobApplicationHistoryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobApplicationHistoryInput, UserUpdateWithoutJobApplicationHistoryInput>, UserUncheckedUpdateWithoutJobApplicationHistoryInput>
  }

  export type UserCreateNestedOneWithoutPersonalInfoInput = {
    create?: XOR<UserCreateWithoutPersonalInfoInput, UserUncheckedCreateWithoutPersonalInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalInfoInput
    connect?: UserWhereUniqueInput
  }

  export type IdentificationDocumentCreateNestedManyWithoutPersonalInfoInput = {
    create?: XOR<IdentificationDocumentCreateWithoutPersonalInfoInput, IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput> | IdentificationDocumentCreateWithoutPersonalInfoInput[] | IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: IdentificationDocumentCreateOrConnectWithoutPersonalInfoInput | IdentificationDocumentCreateOrConnectWithoutPersonalInfoInput[]
    createMany?: IdentificationDocumentCreateManyPersonalInfoInputEnvelope
    connect?: IdentificationDocumentWhereUniqueInput | IdentificationDocumentWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutPersonalInfoInput = {
    create?: XOR<AddressCreateWithoutPersonalInfoInput, AddressUncheckedCreateWithoutPersonalInfoInput> | AddressCreateWithoutPersonalInfoInput[] | AddressUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonalInfoInput | AddressCreateOrConnectWithoutPersonalInfoInput[]
    createMany?: AddressCreateManyPersonalInfoInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type BankAccountCreateNestedManyWithoutPersonalInfoInput = {
    create?: XOR<BankAccountCreateWithoutPersonalInfoInput, BankAccountUncheckedCreateWithoutPersonalInfoInput> | BankAccountCreateWithoutPersonalInfoInput[] | BankAccountUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutPersonalInfoInput | BankAccountCreateOrConnectWithoutPersonalInfoInput[]
    createMany?: BankAccountCreateManyPersonalInfoInputEnvelope
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
  }

  export type LanguageSkillCreateNestedManyWithoutPersonalInfoInput = {
    create?: XOR<LanguageSkillCreateWithoutPersonalInfoInput, LanguageSkillUncheckedCreateWithoutPersonalInfoInput> | LanguageSkillCreateWithoutPersonalInfoInput[] | LanguageSkillUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: LanguageSkillCreateOrConnectWithoutPersonalInfoInput | LanguageSkillCreateOrConnectWithoutPersonalInfoInput[]
    createMany?: LanguageSkillCreateManyPersonalInfoInputEnvelope
    connect?: LanguageSkillWhereUniqueInput | LanguageSkillWhereUniqueInput[]
  }

  export type IdentificationDocumentUncheckedCreateNestedManyWithoutPersonalInfoInput = {
    create?: XOR<IdentificationDocumentCreateWithoutPersonalInfoInput, IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput> | IdentificationDocumentCreateWithoutPersonalInfoInput[] | IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: IdentificationDocumentCreateOrConnectWithoutPersonalInfoInput | IdentificationDocumentCreateOrConnectWithoutPersonalInfoInput[]
    createMany?: IdentificationDocumentCreateManyPersonalInfoInputEnvelope
    connect?: IdentificationDocumentWhereUniqueInput | IdentificationDocumentWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutPersonalInfoInput = {
    create?: XOR<AddressCreateWithoutPersonalInfoInput, AddressUncheckedCreateWithoutPersonalInfoInput> | AddressCreateWithoutPersonalInfoInput[] | AddressUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonalInfoInput | AddressCreateOrConnectWithoutPersonalInfoInput[]
    createMany?: AddressCreateManyPersonalInfoInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type BankAccountUncheckedCreateNestedManyWithoutPersonalInfoInput = {
    create?: XOR<BankAccountCreateWithoutPersonalInfoInput, BankAccountUncheckedCreateWithoutPersonalInfoInput> | BankAccountCreateWithoutPersonalInfoInput[] | BankAccountUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutPersonalInfoInput | BankAccountCreateOrConnectWithoutPersonalInfoInput[]
    createMany?: BankAccountCreateManyPersonalInfoInputEnvelope
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
  }

  export type LanguageSkillUncheckedCreateNestedManyWithoutPersonalInfoInput = {
    create?: XOR<LanguageSkillCreateWithoutPersonalInfoInput, LanguageSkillUncheckedCreateWithoutPersonalInfoInput> | LanguageSkillCreateWithoutPersonalInfoInput[] | LanguageSkillUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: LanguageSkillCreateOrConnectWithoutPersonalInfoInput | LanguageSkillCreateOrConnectWithoutPersonalInfoInput[]
    createMany?: LanguageSkillCreateManyPersonalInfoInputEnvelope
    connect?: LanguageSkillWhereUniqueInput | LanguageSkillWhereUniqueInput[]
  }

  export type EnumMaritalStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaritalStatus
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableEnumEducationLevelFieldUpdateOperationsInput = {
    set?: $Enums.EducationLevel | null
  }

  export type UserUpdateOneRequiredWithoutPersonalInfoNestedInput = {
    create?: XOR<UserCreateWithoutPersonalInfoInput, UserUncheckedCreateWithoutPersonalInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalInfoInput
    upsert?: UserUpsertWithoutPersonalInfoInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonalInfoInput, UserUpdateWithoutPersonalInfoInput>, UserUncheckedUpdateWithoutPersonalInfoInput>
  }

  export type IdentificationDocumentUpdateManyWithoutPersonalInfoNestedInput = {
    create?: XOR<IdentificationDocumentCreateWithoutPersonalInfoInput, IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput> | IdentificationDocumentCreateWithoutPersonalInfoInput[] | IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: IdentificationDocumentCreateOrConnectWithoutPersonalInfoInput | IdentificationDocumentCreateOrConnectWithoutPersonalInfoInput[]
    upsert?: IdentificationDocumentUpsertWithWhereUniqueWithoutPersonalInfoInput | IdentificationDocumentUpsertWithWhereUniqueWithoutPersonalInfoInput[]
    createMany?: IdentificationDocumentCreateManyPersonalInfoInputEnvelope
    set?: IdentificationDocumentWhereUniqueInput | IdentificationDocumentWhereUniqueInput[]
    disconnect?: IdentificationDocumentWhereUniqueInput | IdentificationDocumentWhereUniqueInput[]
    delete?: IdentificationDocumentWhereUniqueInput | IdentificationDocumentWhereUniqueInput[]
    connect?: IdentificationDocumentWhereUniqueInput | IdentificationDocumentWhereUniqueInput[]
    update?: IdentificationDocumentUpdateWithWhereUniqueWithoutPersonalInfoInput | IdentificationDocumentUpdateWithWhereUniqueWithoutPersonalInfoInput[]
    updateMany?: IdentificationDocumentUpdateManyWithWhereWithoutPersonalInfoInput | IdentificationDocumentUpdateManyWithWhereWithoutPersonalInfoInput[]
    deleteMany?: IdentificationDocumentScalarWhereInput | IdentificationDocumentScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutPersonalInfoNestedInput = {
    create?: XOR<AddressCreateWithoutPersonalInfoInput, AddressUncheckedCreateWithoutPersonalInfoInput> | AddressCreateWithoutPersonalInfoInput[] | AddressUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonalInfoInput | AddressCreateOrConnectWithoutPersonalInfoInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutPersonalInfoInput | AddressUpsertWithWhereUniqueWithoutPersonalInfoInput[]
    createMany?: AddressCreateManyPersonalInfoInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutPersonalInfoInput | AddressUpdateWithWhereUniqueWithoutPersonalInfoInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutPersonalInfoInput | AddressUpdateManyWithWhereWithoutPersonalInfoInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type BankAccountUpdateManyWithoutPersonalInfoNestedInput = {
    create?: XOR<BankAccountCreateWithoutPersonalInfoInput, BankAccountUncheckedCreateWithoutPersonalInfoInput> | BankAccountCreateWithoutPersonalInfoInput[] | BankAccountUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutPersonalInfoInput | BankAccountCreateOrConnectWithoutPersonalInfoInput[]
    upsert?: BankAccountUpsertWithWhereUniqueWithoutPersonalInfoInput | BankAccountUpsertWithWhereUniqueWithoutPersonalInfoInput[]
    createMany?: BankAccountCreateManyPersonalInfoInputEnvelope
    set?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    disconnect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    delete?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    update?: BankAccountUpdateWithWhereUniqueWithoutPersonalInfoInput | BankAccountUpdateWithWhereUniqueWithoutPersonalInfoInput[]
    updateMany?: BankAccountUpdateManyWithWhereWithoutPersonalInfoInput | BankAccountUpdateManyWithWhereWithoutPersonalInfoInput[]
    deleteMany?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
  }

  export type LanguageSkillUpdateManyWithoutPersonalInfoNestedInput = {
    create?: XOR<LanguageSkillCreateWithoutPersonalInfoInput, LanguageSkillUncheckedCreateWithoutPersonalInfoInput> | LanguageSkillCreateWithoutPersonalInfoInput[] | LanguageSkillUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: LanguageSkillCreateOrConnectWithoutPersonalInfoInput | LanguageSkillCreateOrConnectWithoutPersonalInfoInput[]
    upsert?: LanguageSkillUpsertWithWhereUniqueWithoutPersonalInfoInput | LanguageSkillUpsertWithWhereUniqueWithoutPersonalInfoInput[]
    createMany?: LanguageSkillCreateManyPersonalInfoInputEnvelope
    set?: LanguageSkillWhereUniqueInput | LanguageSkillWhereUniqueInput[]
    disconnect?: LanguageSkillWhereUniqueInput | LanguageSkillWhereUniqueInput[]
    delete?: LanguageSkillWhereUniqueInput | LanguageSkillWhereUniqueInput[]
    connect?: LanguageSkillWhereUniqueInput | LanguageSkillWhereUniqueInput[]
    update?: LanguageSkillUpdateWithWhereUniqueWithoutPersonalInfoInput | LanguageSkillUpdateWithWhereUniqueWithoutPersonalInfoInput[]
    updateMany?: LanguageSkillUpdateManyWithWhereWithoutPersonalInfoInput | LanguageSkillUpdateManyWithWhereWithoutPersonalInfoInput[]
    deleteMany?: LanguageSkillScalarWhereInput | LanguageSkillScalarWhereInput[]
  }

  export type IdentificationDocumentUncheckedUpdateManyWithoutPersonalInfoNestedInput = {
    create?: XOR<IdentificationDocumentCreateWithoutPersonalInfoInput, IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput> | IdentificationDocumentCreateWithoutPersonalInfoInput[] | IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: IdentificationDocumentCreateOrConnectWithoutPersonalInfoInput | IdentificationDocumentCreateOrConnectWithoutPersonalInfoInput[]
    upsert?: IdentificationDocumentUpsertWithWhereUniqueWithoutPersonalInfoInput | IdentificationDocumentUpsertWithWhereUniqueWithoutPersonalInfoInput[]
    createMany?: IdentificationDocumentCreateManyPersonalInfoInputEnvelope
    set?: IdentificationDocumentWhereUniqueInput | IdentificationDocumentWhereUniqueInput[]
    disconnect?: IdentificationDocumentWhereUniqueInput | IdentificationDocumentWhereUniqueInput[]
    delete?: IdentificationDocumentWhereUniqueInput | IdentificationDocumentWhereUniqueInput[]
    connect?: IdentificationDocumentWhereUniqueInput | IdentificationDocumentWhereUniqueInput[]
    update?: IdentificationDocumentUpdateWithWhereUniqueWithoutPersonalInfoInput | IdentificationDocumentUpdateWithWhereUniqueWithoutPersonalInfoInput[]
    updateMany?: IdentificationDocumentUpdateManyWithWhereWithoutPersonalInfoInput | IdentificationDocumentUpdateManyWithWhereWithoutPersonalInfoInput[]
    deleteMany?: IdentificationDocumentScalarWhereInput | IdentificationDocumentScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutPersonalInfoNestedInput = {
    create?: XOR<AddressCreateWithoutPersonalInfoInput, AddressUncheckedCreateWithoutPersonalInfoInput> | AddressCreateWithoutPersonalInfoInput[] | AddressUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPersonalInfoInput | AddressCreateOrConnectWithoutPersonalInfoInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutPersonalInfoInput | AddressUpsertWithWhereUniqueWithoutPersonalInfoInput[]
    createMany?: AddressCreateManyPersonalInfoInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutPersonalInfoInput | AddressUpdateWithWhereUniqueWithoutPersonalInfoInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutPersonalInfoInput | AddressUpdateManyWithWhereWithoutPersonalInfoInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type BankAccountUncheckedUpdateManyWithoutPersonalInfoNestedInput = {
    create?: XOR<BankAccountCreateWithoutPersonalInfoInput, BankAccountUncheckedCreateWithoutPersonalInfoInput> | BankAccountCreateWithoutPersonalInfoInput[] | BankAccountUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutPersonalInfoInput | BankAccountCreateOrConnectWithoutPersonalInfoInput[]
    upsert?: BankAccountUpsertWithWhereUniqueWithoutPersonalInfoInput | BankAccountUpsertWithWhereUniqueWithoutPersonalInfoInput[]
    createMany?: BankAccountCreateManyPersonalInfoInputEnvelope
    set?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    disconnect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    delete?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    update?: BankAccountUpdateWithWhereUniqueWithoutPersonalInfoInput | BankAccountUpdateWithWhereUniqueWithoutPersonalInfoInput[]
    updateMany?: BankAccountUpdateManyWithWhereWithoutPersonalInfoInput | BankAccountUpdateManyWithWhereWithoutPersonalInfoInput[]
    deleteMany?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
  }

  export type LanguageSkillUncheckedUpdateManyWithoutPersonalInfoNestedInput = {
    create?: XOR<LanguageSkillCreateWithoutPersonalInfoInput, LanguageSkillUncheckedCreateWithoutPersonalInfoInput> | LanguageSkillCreateWithoutPersonalInfoInput[] | LanguageSkillUncheckedCreateWithoutPersonalInfoInput[]
    connectOrCreate?: LanguageSkillCreateOrConnectWithoutPersonalInfoInput | LanguageSkillCreateOrConnectWithoutPersonalInfoInput[]
    upsert?: LanguageSkillUpsertWithWhereUniqueWithoutPersonalInfoInput | LanguageSkillUpsertWithWhereUniqueWithoutPersonalInfoInput[]
    createMany?: LanguageSkillCreateManyPersonalInfoInputEnvelope
    set?: LanguageSkillWhereUniqueInput | LanguageSkillWhereUniqueInput[]
    disconnect?: LanguageSkillWhereUniqueInput | LanguageSkillWhereUniqueInput[]
    delete?: LanguageSkillWhereUniqueInput | LanguageSkillWhereUniqueInput[]
    connect?: LanguageSkillWhereUniqueInput | LanguageSkillWhereUniqueInput[]
    update?: LanguageSkillUpdateWithWhereUniqueWithoutPersonalInfoInput | LanguageSkillUpdateWithWhereUniqueWithoutPersonalInfoInput[]
    updateMany?: LanguageSkillUpdateManyWithWhereWithoutPersonalInfoInput | LanguageSkillUpdateManyWithWhereWithoutPersonalInfoInput[]
    deleteMany?: LanguageSkillScalarWhereInput | LanguageSkillScalarWhereInput[]
  }

  export type PersonalInfoCreateNestedOneWithoutIdentificationDocumentsInput = {
    create?: XOR<PersonalInfoCreateWithoutIdentificationDocumentsInput, PersonalInfoUncheckedCreateWithoutIdentificationDocumentsInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutIdentificationDocumentsInput
    connect?: PersonalInfoWhereUniqueInput
  }

  export type EnumIdentificationDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.IdentificationDocumentType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PersonalInfoUpdateOneRequiredWithoutIdentificationDocumentsNestedInput = {
    create?: XOR<PersonalInfoCreateWithoutIdentificationDocumentsInput, PersonalInfoUncheckedCreateWithoutIdentificationDocumentsInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutIdentificationDocumentsInput
    upsert?: PersonalInfoUpsertWithoutIdentificationDocumentsInput
    connect?: PersonalInfoWhereUniqueInput
    update?: XOR<XOR<PersonalInfoUpdateToOneWithWhereWithoutIdentificationDocumentsInput, PersonalInfoUpdateWithoutIdentificationDocumentsInput>, PersonalInfoUncheckedUpdateWithoutIdentificationDocumentsInput>
  }

  export type PersonalInfoCreateNestedOneWithoutAddressesInput = {
    create?: XOR<PersonalInfoCreateWithoutAddressesInput, PersonalInfoUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutAddressesInput
    connect?: PersonalInfoWhereUniqueInput
  }

  export type EnumAddressTypeFieldUpdateOperationsInput = {
    set?: $Enums.AddressType
  }

  export type PersonalInfoUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<PersonalInfoCreateWithoutAddressesInput, PersonalInfoUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutAddressesInput
    upsert?: PersonalInfoUpsertWithoutAddressesInput
    connect?: PersonalInfoWhereUniqueInput
    update?: XOR<XOR<PersonalInfoUpdateToOneWithWhereWithoutAddressesInput, PersonalInfoUpdateWithoutAddressesInput>, PersonalInfoUncheckedUpdateWithoutAddressesInput>
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type DependentMemberCreateNestedOneWithoutDocumentInput = {
    create?: XOR<DependentMemberCreateWithoutDocumentInput, DependentMemberUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: DependentMemberCreateOrConnectWithoutDocumentInput
    connect?: DependentMemberWhereUniqueInput
  }

  export type DocumentVerificationCreateNestedOneWithoutDocumentInput = {
    create?: XOR<DocumentVerificationCreateWithoutDocumentInput, DocumentVerificationUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutDocumentInput
    connect?: DocumentVerificationWhereUniqueInput
  }

  export type LanguageSkillCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<LanguageSkillCreateWithoutDocumentsInput, LanguageSkillUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LanguageSkillCreateOrConnectWithoutDocumentsInput
    connect?: LanguageSkillWhereUniqueInput
  }

  export type DocumentVerificationUncheckedCreateNestedOneWithoutDocumentInput = {
    create?: XOR<DocumentVerificationCreateWithoutDocumentInput, DocumentVerificationUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutDocumentInput
    connect?: DocumentVerificationWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type DependentMemberUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<DependentMemberCreateWithoutDocumentInput, DependentMemberUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: DependentMemberCreateOrConnectWithoutDocumentInput
    upsert?: DependentMemberUpsertWithoutDocumentInput
    disconnect?: DependentMemberWhereInput | boolean
    delete?: DependentMemberWhereInput | boolean
    connect?: DependentMemberWhereUniqueInput
    update?: XOR<XOR<DependentMemberUpdateToOneWithWhereWithoutDocumentInput, DependentMemberUpdateWithoutDocumentInput>, DependentMemberUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentVerificationUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<DocumentVerificationCreateWithoutDocumentInput, DocumentVerificationUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutDocumentInput
    upsert?: DocumentVerificationUpsertWithoutDocumentInput
    disconnect?: DocumentVerificationWhereInput | boolean
    delete?: DocumentVerificationWhereInput | boolean
    connect?: DocumentVerificationWhereUniqueInput
    update?: XOR<XOR<DocumentVerificationUpdateToOneWithWhereWithoutDocumentInput, DocumentVerificationUpdateWithoutDocumentInput>, DocumentVerificationUncheckedUpdateWithoutDocumentInput>
  }

  export type LanguageSkillUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<LanguageSkillCreateWithoutDocumentsInput, LanguageSkillUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LanguageSkillCreateOrConnectWithoutDocumentsInput
    upsert?: LanguageSkillUpsertWithoutDocumentsInput
    disconnect?: LanguageSkillWhereInput | boolean
    delete?: LanguageSkillWhereInput | boolean
    connect?: LanguageSkillWhereUniqueInput
    update?: XOR<XOR<LanguageSkillUpdateToOneWithWhereWithoutDocumentsInput, LanguageSkillUpdateWithoutDocumentsInput>, LanguageSkillUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentVerificationUncheckedUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<DocumentVerificationCreateWithoutDocumentInput, DocumentVerificationUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: DocumentVerificationCreateOrConnectWithoutDocumentInput
    upsert?: DocumentVerificationUpsertWithoutDocumentInput
    disconnect?: DocumentVerificationWhereInput | boolean
    delete?: DocumentVerificationWhereInput | boolean
    connect?: DocumentVerificationWhereUniqueInput
    update?: XOR<XOR<DocumentVerificationUpdateToOneWithWhereWithoutDocumentInput, DocumentVerificationUpdateWithoutDocumentInput>, DocumentVerificationUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentCreateNestedOneWithoutVerificationInput = {
    create?: XOR<DocumentCreateWithoutVerificationInput, DocumentUncheckedCreateWithoutVerificationInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutVerificationInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentReviewsInput = {
    create?: XOR<UserCreateWithoutDocumentReviewsInput, UserUncheckedCreateWithoutDocumentReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentVerificationInput = {
    create?: XOR<UserCreateWithoutDocumentVerificationInput, UserUncheckedCreateWithoutDocumentVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentVerificationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type DocumentUpdateOneRequiredWithoutVerificationNestedInput = {
    create?: XOR<DocumentCreateWithoutVerificationInput, DocumentUncheckedCreateWithoutVerificationInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutVerificationInput
    upsert?: DocumentUpsertWithoutVerificationInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutVerificationInput, DocumentUpdateWithoutVerificationInput>, DocumentUncheckedUpdateWithoutVerificationInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentReviewsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentReviewsInput, UserUncheckedCreateWithoutDocumentReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentReviewsInput
    upsert?: UserUpsertWithoutDocumentReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentReviewsInput, UserUpdateWithoutDocumentReviewsInput>, UserUncheckedUpdateWithoutDocumentReviewsInput>
  }

  export type UserUpdateOneWithoutDocumentVerificationNestedInput = {
    create?: XOR<UserCreateWithoutDocumentVerificationInput, UserUncheckedCreateWithoutDocumentVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentVerificationInput
    upsert?: UserUpsertWithoutDocumentVerificationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentVerificationInput, UserUpdateWithoutDocumentVerificationInput>, UserUncheckedUpdateWithoutDocumentVerificationInput>
  }

  export type UserCreateNestedOneWithoutOnboardingProgressInput = {
    create?: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingProgressInput
    connect?: UserWhereUniqueInput
  }

  export type JobApplicationCreateNestedOneWithoutOnboardingProgressInput = {
    create?: XOR<JobApplicationCreateWithoutOnboardingProgressInput, JobApplicationUncheckedCreateWithoutOnboardingProgressInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutOnboardingProgressInput
    connect?: JobApplicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManagedOnboardingsInput = {
    create?: XOR<UserCreateWithoutManagedOnboardingsInput, UserUncheckedCreateWithoutManagedOnboardingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedOnboardingsInput
    connect?: UserWhereUniqueInput
  }

  export type ContractCreateNestedOneWithoutOnboardingInput = {
    create?: XOR<ContractCreateWithoutOnboardingInput, ContractUncheckedCreateWithoutOnboardingInput>
    connectOrCreate?: ContractCreateOrConnectWithoutOnboardingInput
    connect?: ContractWhereUniqueInput
  }

  export type ContractUncheckedCreateNestedOneWithoutOnboardingInput = {
    create?: XOR<ContractCreateWithoutOnboardingInput, ContractUncheckedCreateWithoutOnboardingInput>
    connectOrCreate?: ContractCreateOrConnectWithoutOnboardingInput
    connect?: ContractWhereUniqueInput
  }

  export type EnumPhaseFieldUpdateOperationsInput = {
    set?: $Enums.Phase
  }

  export type EnumOnboardingStatusFieldUpdateOperationsInput = {
    set?: $Enums.OnboardingStatus
  }

  export type UserUpdateOneRequiredWithoutOnboardingProgressNestedInput = {
    create?: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingProgressInput
    upsert?: UserUpsertWithoutOnboardingProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOnboardingProgressInput, UserUpdateWithoutOnboardingProgressInput>, UserUncheckedUpdateWithoutOnboardingProgressInput>
  }

  export type JobApplicationUpdateOneRequiredWithoutOnboardingProgressNestedInput = {
    create?: XOR<JobApplicationCreateWithoutOnboardingProgressInput, JobApplicationUncheckedCreateWithoutOnboardingProgressInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutOnboardingProgressInput
    upsert?: JobApplicationUpsertWithoutOnboardingProgressInput
    connect?: JobApplicationWhereUniqueInput
    update?: XOR<XOR<JobApplicationUpdateToOneWithWhereWithoutOnboardingProgressInput, JobApplicationUpdateWithoutOnboardingProgressInput>, JobApplicationUncheckedUpdateWithoutOnboardingProgressInput>
  }

  export type UserUpdateOneRequiredWithoutManagedOnboardingsNestedInput = {
    create?: XOR<UserCreateWithoutManagedOnboardingsInput, UserUncheckedCreateWithoutManagedOnboardingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedOnboardingsInput
    upsert?: UserUpsertWithoutManagedOnboardingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedOnboardingsInput, UserUpdateWithoutManagedOnboardingsInput>, UserUncheckedUpdateWithoutManagedOnboardingsInput>
  }

  export type ContractUpdateOneWithoutOnboardingNestedInput = {
    create?: XOR<ContractCreateWithoutOnboardingInput, ContractUncheckedCreateWithoutOnboardingInput>
    connectOrCreate?: ContractCreateOrConnectWithoutOnboardingInput
    upsert?: ContractUpsertWithoutOnboardingInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutOnboardingInput, ContractUpdateWithoutOnboardingInput>, ContractUncheckedUpdateWithoutOnboardingInput>
  }

  export type ContractUncheckedUpdateOneWithoutOnboardingNestedInput = {
    create?: XOR<ContractCreateWithoutOnboardingInput, ContractUncheckedCreateWithoutOnboardingInput>
    connectOrCreate?: ContractCreateOrConnectWithoutOnboardingInput
    upsert?: ContractUpsertWithoutOnboardingInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutOnboardingInput, ContractUpdateWithoutOnboardingInput>, ContractUncheckedUpdateWithoutOnboardingInput>
  }

  export type JobApplicationCreateNestedOneWithoutOnboardingInvitationInput = {
    create?: XOR<JobApplicationCreateWithoutOnboardingInvitationInput, JobApplicationUncheckedCreateWithoutOnboardingInvitationInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutOnboardingInvitationInput
    connect?: JobApplicationWhereUniqueInput
  }

  export type JobApplicationUpdateOneRequiredWithoutOnboardingInvitationNestedInput = {
    create?: XOR<JobApplicationCreateWithoutOnboardingInvitationInput, JobApplicationUncheckedCreateWithoutOnboardingInvitationInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutOnboardingInvitationInput
    upsert?: JobApplicationUpsertWithoutOnboardingInvitationInput
    connect?: JobApplicationWhereUniqueInput
    update?: XOR<XOR<JobApplicationUpdateToOneWithWhereWithoutOnboardingInvitationInput, JobApplicationUpdateWithoutOnboardingInvitationInput>, JobApplicationUncheckedUpdateWithoutOnboardingInvitationInput>
  }

  export type UserCreateNestedOneWithoutEmergencyContactsInput = {
    create?: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyContactsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmergencyContactsNestedInput = {
    create?: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergencyContactsInput
    upsert?: UserUpsertWithoutEmergencyContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmergencyContactsInput, UserUpdateWithoutEmergencyContactsInput>, UserUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type UserCreateNestedOneWithoutDependentMembersInput = {
    create?: XOR<UserCreateWithoutDependentMembersInput, UserUncheckedCreateWithoutDependentMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDependentMembersInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutDependentMemberInput = {
    create?: XOR<DocumentCreateWithoutDependentMemberInput, DocumentUncheckedCreateWithoutDependentMemberInput> | DocumentCreateWithoutDependentMemberInput[] | DocumentUncheckedCreateWithoutDependentMemberInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDependentMemberInput | DocumentCreateOrConnectWithoutDependentMemberInput[]
    createMany?: DocumentCreateManyDependentMemberInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutDependentMemberInput = {
    create?: XOR<DocumentCreateWithoutDependentMemberInput, DocumentUncheckedCreateWithoutDependentMemberInput> | DocumentCreateWithoutDependentMemberInput[] | DocumentUncheckedCreateWithoutDependentMemberInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDependentMemberInput | DocumentCreateOrConnectWithoutDependentMemberInput[]
    createMany?: DocumentCreateManyDependentMemberInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDependentMembersNestedInput = {
    create?: XOR<UserCreateWithoutDependentMembersInput, UserUncheckedCreateWithoutDependentMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDependentMembersInput
    upsert?: UserUpsertWithoutDependentMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDependentMembersInput, UserUpdateWithoutDependentMembersInput>, UserUncheckedUpdateWithoutDependentMembersInput>
  }

  export type DocumentUpdateManyWithoutDependentMemberNestedInput = {
    create?: XOR<DocumentCreateWithoutDependentMemberInput, DocumentUncheckedCreateWithoutDependentMemberInput> | DocumentCreateWithoutDependentMemberInput[] | DocumentUncheckedCreateWithoutDependentMemberInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDependentMemberInput | DocumentCreateOrConnectWithoutDependentMemberInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDependentMemberInput | DocumentUpsertWithWhereUniqueWithoutDependentMemberInput[]
    createMany?: DocumentCreateManyDependentMemberInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDependentMemberInput | DocumentUpdateWithWhereUniqueWithoutDependentMemberInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDependentMemberInput | DocumentUpdateManyWithWhereWithoutDependentMemberInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutDependentMemberNestedInput = {
    create?: XOR<DocumentCreateWithoutDependentMemberInput, DocumentUncheckedCreateWithoutDependentMemberInput> | DocumentCreateWithoutDependentMemberInput[] | DocumentUncheckedCreateWithoutDependentMemberInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDependentMemberInput | DocumentCreateOrConnectWithoutDependentMemberInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDependentMemberInput | DocumentUpsertWithWhereUniqueWithoutDependentMemberInput[]
    createMany?: DocumentCreateManyDependentMemberInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDependentMemberInput | DocumentUpdateWithWhereUniqueWithoutDependentMemberInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDependentMemberInput | DocumentUpdateManyWithWhereWithoutDependentMemberInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmailsInput = {
    create?: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEmailTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmailType
  }

  export type UserUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailsInput
    upsert?: UserUpsertWithoutEmailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailsInput, UserUpdateWithoutEmailsInput>, UserUncheckedUpdateWithoutEmailsInput>
  }

  export type UserCreateNestedOneWithoutPhonesInput = {
    create?: XOR<UserCreateWithoutPhonesInput, UserUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhonesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPhoneTypeFieldUpdateOperationsInput = {
    set?: $Enums.PhoneType
  }

  export type UserUpdateOneRequiredWithoutPhonesNestedInput = {
    create?: XOR<UserCreateWithoutPhonesInput, UserUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhonesInput
    upsert?: UserUpsertWithoutPhonesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPhonesInput, UserUpdateWithoutPhonesInput>, UserUncheckedUpdateWithoutPhonesInput>
  }

  export type PersonalInfoCreateNestedOneWithoutBankAccountsInput = {
    create?: XOR<PersonalInfoCreateWithoutBankAccountsInput, PersonalInfoUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutBankAccountsInput
    connect?: PersonalInfoWhereUniqueInput
  }

  export type EnumGreekBankFieldUpdateOperationsInput = {
    set?: $Enums.GreekBank
  }

  export type PersonalInfoUpdateOneRequiredWithoutBankAccountsNestedInput = {
    create?: XOR<PersonalInfoCreateWithoutBankAccountsInput, PersonalInfoUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutBankAccountsInput
    upsert?: PersonalInfoUpsertWithoutBankAccountsInput
    connect?: PersonalInfoWhereUniqueInput
    update?: XOR<XOR<PersonalInfoUpdateToOneWithWhereWithoutBankAccountsInput, PersonalInfoUpdateWithoutBankAccountsInput>, PersonalInfoUncheckedUpdateWithoutBankAccountsInput>
  }

  export type OnboardingProgressCreateNestedOneWithoutContractInput = {
    create?: XOR<OnboardingProgressCreateWithoutContractInput, OnboardingProgressUncheckedCreateWithoutContractInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutContractInput
    connect?: OnboardingProgressWhereUniqueInput
  }

  export type EnumContractStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContractStatus
  }

  export type OnboardingProgressUpdateOneRequiredWithoutContractNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutContractInput, OnboardingProgressUncheckedCreateWithoutContractInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutContractInput
    upsert?: OnboardingProgressUpsertWithoutContractInput
    connect?: OnboardingProgressWhereUniqueInput
    update?: XOR<XOR<OnboardingProgressUpdateToOneWithWhereWithoutContractInput, OnboardingProgressUpdateWithoutContractInput>, OnboardingProgressUncheckedUpdateWithoutContractInput>
  }

  export type PersonalInfoCreateNestedOneWithoutLanguageSkillsInput = {
    create?: XOR<PersonalInfoCreateWithoutLanguageSkillsInput, PersonalInfoUncheckedCreateWithoutLanguageSkillsInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutLanguageSkillsInput
    connect?: PersonalInfoWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutLanguageSkillInput = {
    create?: XOR<DocumentCreateWithoutLanguageSkillInput, DocumentUncheckedCreateWithoutLanguageSkillInput> | DocumentCreateWithoutLanguageSkillInput[] | DocumentUncheckedCreateWithoutLanguageSkillInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLanguageSkillInput | DocumentCreateOrConnectWithoutLanguageSkillInput[]
    createMany?: DocumentCreateManyLanguageSkillInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutLanguageSkillInput = {
    create?: XOR<DocumentCreateWithoutLanguageSkillInput, DocumentUncheckedCreateWithoutLanguageSkillInput> | DocumentCreateWithoutLanguageSkillInput[] | DocumentUncheckedCreateWithoutLanguageSkillInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLanguageSkillInput | DocumentCreateOrConnectWithoutLanguageSkillInput[]
    createMany?: DocumentCreateManyLanguageSkillInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EnumLanguageFieldUpdateOperationsInput = {
    set?: $Enums.Language
  }

  export type EnumProficiencyFieldUpdateOperationsInput = {
    set?: $Enums.Proficiency
  }

  export type PersonalInfoUpdateOneRequiredWithoutLanguageSkillsNestedInput = {
    create?: XOR<PersonalInfoCreateWithoutLanguageSkillsInput, PersonalInfoUncheckedCreateWithoutLanguageSkillsInput>
    connectOrCreate?: PersonalInfoCreateOrConnectWithoutLanguageSkillsInput
    upsert?: PersonalInfoUpsertWithoutLanguageSkillsInput
    connect?: PersonalInfoWhereUniqueInput
    update?: XOR<XOR<PersonalInfoUpdateToOneWithWhereWithoutLanguageSkillsInput, PersonalInfoUpdateWithoutLanguageSkillsInput>, PersonalInfoUncheckedUpdateWithoutLanguageSkillsInput>
  }

  export type DocumentUpdateManyWithoutLanguageSkillNestedInput = {
    create?: XOR<DocumentCreateWithoutLanguageSkillInput, DocumentUncheckedCreateWithoutLanguageSkillInput> | DocumentCreateWithoutLanguageSkillInput[] | DocumentUncheckedCreateWithoutLanguageSkillInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLanguageSkillInput | DocumentCreateOrConnectWithoutLanguageSkillInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutLanguageSkillInput | DocumentUpsertWithWhereUniqueWithoutLanguageSkillInput[]
    createMany?: DocumentCreateManyLanguageSkillInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutLanguageSkillInput | DocumentUpdateWithWhereUniqueWithoutLanguageSkillInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutLanguageSkillInput | DocumentUpdateManyWithWhereWithoutLanguageSkillInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutLanguageSkillNestedInput = {
    create?: XOR<DocumentCreateWithoutLanguageSkillInput, DocumentUncheckedCreateWithoutLanguageSkillInput> | DocumentCreateWithoutLanguageSkillInput[] | DocumentUncheckedCreateWithoutLanguageSkillInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLanguageSkillInput | DocumentCreateOrConnectWithoutLanguageSkillInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutLanguageSkillInput | DocumentUpsertWithWhereUniqueWithoutLanguageSkillInput[]
    createMany?: DocumentCreateManyLanguageSkillInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutLanguageSkillInput | DocumentUpdateWithWhereUniqueWithoutLanguageSkillInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutLanguageSkillInput | DocumentUpdateManyWithWhereWithoutLanguageSkillInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRequestsMadeInput = {
    create?: XOR<UserCreateWithoutRequestsMadeInput, UserUncheckedCreateWithoutRequestsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestsToManageInput = {
    create?: XOR<UserCreateWithoutRequestsToManageInput, UserUncheckedCreateWithoutRequestsToManageInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsToManageInput
    connect?: UserWhereUniqueInput
  }

  export type RequestAttachmentCreateNestedManyWithoutRequestInput = {
    create?: XOR<RequestAttachmentCreateWithoutRequestInput, RequestAttachmentUncheckedCreateWithoutRequestInput> | RequestAttachmentCreateWithoutRequestInput[] | RequestAttachmentUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestAttachmentCreateOrConnectWithoutRequestInput | RequestAttachmentCreateOrConnectWithoutRequestInput[]
    createMany?: RequestAttachmentCreateManyRequestInputEnvelope
    connect?: RequestAttachmentWhereUniqueInput | RequestAttachmentWhereUniqueInput[]
  }

  export type RequestStatusHistoryCreateNestedManyWithoutRequestInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput> | RequestStatusHistoryCreateWithoutRequestInput[] | RequestStatusHistoryUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutRequestInput | RequestStatusHistoryCreateOrConnectWithoutRequestInput[]
    createMany?: RequestStatusHistoryCreateManyRequestInputEnvelope
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
  }

  export type RequestAttachmentUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<RequestAttachmentCreateWithoutRequestInput, RequestAttachmentUncheckedCreateWithoutRequestInput> | RequestAttachmentCreateWithoutRequestInput[] | RequestAttachmentUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestAttachmentCreateOrConnectWithoutRequestInput | RequestAttachmentCreateOrConnectWithoutRequestInput[]
    createMany?: RequestAttachmentCreateManyRequestInputEnvelope
    connect?: RequestAttachmentWhereUniqueInput | RequestAttachmentWhereUniqueInput[]
  }

  export type RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput> | RequestStatusHistoryCreateWithoutRequestInput[] | RequestStatusHistoryUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutRequestInput | RequestStatusHistoryCreateOrConnectWithoutRequestInput[]
    createMany?: RequestStatusHistoryCreateManyRequestInputEnvelope
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type UserUpdateOneRequiredWithoutRequestsMadeNestedInput = {
    create?: XOR<UserCreateWithoutRequestsMadeInput, UserUncheckedCreateWithoutRequestsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsMadeInput
    upsert?: UserUpsertWithoutRequestsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequestsMadeInput, UserUpdateWithoutRequestsMadeInput>, UserUncheckedUpdateWithoutRequestsMadeInput>
  }

  export type UserUpdateOneRequiredWithoutRequestsToManageNestedInput = {
    create?: XOR<UserCreateWithoutRequestsToManageInput, UserUncheckedCreateWithoutRequestsToManageInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsToManageInput
    upsert?: UserUpsertWithoutRequestsToManageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequestsToManageInput, UserUpdateWithoutRequestsToManageInput>, UserUncheckedUpdateWithoutRequestsToManageInput>
  }

  export type RequestAttachmentUpdateManyWithoutRequestNestedInput = {
    create?: XOR<RequestAttachmentCreateWithoutRequestInput, RequestAttachmentUncheckedCreateWithoutRequestInput> | RequestAttachmentCreateWithoutRequestInput[] | RequestAttachmentUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestAttachmentCreateOrConnectWithoutRequestInput | RequestAttachmentCreateOrConnectWithoutRequestInput[]
    upsert?: RequestAttachmentUpsertWithWhereUniqueWithoutRequestInput | RequestAttachmentUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: RequestAttachmentCreateManyRequestInputEnvelope
    set?: RequestAttachmentWhereUniqueInput | RequestAttachmentWhereUniqueInput[]
    disconnect?: RequestAttachmentWhereUniqueInput | RequestAttachmentWhereUniqueInput[]
    delete?: RequestAttachmentWhereUniqueInput | RequestAttachmentWhereUniqueInput[]
    connect?: RequestAttachmentWhereUniqueInput | RequestAttachmentWhereUniqueInput[]
    update?: RequestAttachmentUpdateWithWhereUniqueWithoutRequestInput | RequestAttachmentUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: RequestAttachmentUpdateManyWithWhereWithoutRequestInput | RequestAttachmentUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: RequestAttachmentScalarWhereInput | RequestAttachmentScalarWhereInput[]
  }

  export type RequestStatusHistoryUpdateManyWithoutRequestNestedInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput> | RequestStatusHistoryCreateWithoutRequestInput[] | RequestStatusHistoryUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutRequestInput | RequestStatusHistoryCreateOrConnectWithoutRequestInput[]
    upsert?: RequestStatusHistoryUpsertWithWhereUniqueWithoutRequestInput | RequestStatusHistoryUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: RequestStatusHistoryCreateManyRequestInputEnvelope
    set?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    disconnect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    delete?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    update?: RequestStatusHistoryUpdateWithWhereUniqueWithoutRequestInput | RequestStatusHistoryUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: RequestStatusHistoryUpdateManyWithWhereWithoutRequestInput | RequestStatusHistoryUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: RequestStatusHistoryScalarWhereInput | RequestStatusHistoryScalarWhereInput[]
  }

  export type RequestAttachmentUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<RequestAttachmentCreateWithoutRequestInput, RequestAttachmentUncheckedCreateWithoutRequestInput> | RequestAttachmentCreateWithoutRequestInput[] | RequestAttachmentUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestAttachmentCreateOrConnectWithoutRequestInput | RequestAttachmentCreateOrConnectWithoutRequestInput[]
    upsert?: RequestAttachmentUpsertWithWhereUniqueWithoutRequestInput | RequestAttachmentUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: RequestAttachmentCreateManyRequestInputEnvelope
    set?: RequestAttachmentWhereUniqueInput | RequestAttachmentWhereUniqueInput[]
    disconnect?: RequestAttachmentWhereUniqueInput | RequestAttachmentWhereUniqueInput[]
    delete?: RequestAttachmentWhereUniqueInput | RequestAttachmentWhereUniqueInput[]
    connect?: RequestAttachmentWhereUniqueInput | RequestAttachmentWhereUniqueInput[]
    update?: RequestAttachmentUpdateWithWhereUniqueWithoutRequestInput | RequestAttachmentUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: RequestAttachmentUpdateManyWithWhereWithoutRequestInput | RequestAttachmentUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: RequestAttachmentScalarWhereInput | RequestAttachmentScalarWhereInput[]
  }

  export type RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput> | RequestStatusHistoryCreateWithoutRequestInput[] | RequestStatusHistoryUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutRequestInput | RequestStatusHistoryCreateOrConnectWithoutRequestInput[]
    upsert?: RequestStatusHistoryUpsertWithWhereUniqueWithoutRequestInput | RequestStatusHistoryUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: RequestStatusHistoryCreateManyRequestInputEnvelope
    set?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    disconnect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    delete?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    connect?: RequestStatusHistoryWhereUniqueInput | RequestStatusHistoryWhereUniqueInput[]
    update?: RequestStatusHistoryUpdateWithWhereUniqueWithoutRequestInput | RequestStatusHistoryUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: RequestStatusHistoryUpdateManyWithWhereWithoutRequestInput | RequestStatusHistoryUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: RequestStatusHistoryScalarWhereInput | RequestStatusHistoryScalarWhereInput[]
  }

  export type RequestCreateNestedOneWithoutRequestStatusHistoryInput = {
    create?: XOR<RequestCreateWithoutRequestStatusHistoryInput, RequestUncheckedCreateWithoutRequestStatusHistoryInput>
    connectOrCreate?: RequestCreateOrConnectWithoutRequestStatusHistoryInput
    connect?: RequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestHistoryInput = {
    create?: XOR<UserCreateWithoutRequestHistoryInput, UserUncheckedCreateWithoutRequestHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type StatusAttachmentCreateNestedManyWithoutHistoryInput = {
    create?: XOR<StatusAttachmentCreateWithoutHistoryInput, StatusAttachmentUncheckedCreateWithoutHistoryInput> | StatusAttachmentCreateWithoutHistoryInput[] | StatusAttachmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: StatusAttachmentCreateOrConnectWithoutHistoryInput | StatusAttachmentCreateOrConnectWithoutHistoryInput[]
    createMany?: StatusAttachmentCreateManyHistoryInputEnvelope
    connect?: StatusAttachmentWhereUniqueInput | StatusAttachmentWhereUniqueInput[]
  }

  export type StatusAttachmentUncheckedCreateNestedManyWithoutHistoryInput = {
    create?: XOR<StatusAttachmentCreateWithoutHistoryInput, StatusAttachmentUncheckedCreateWithoutHistoryInput> | StatusAttachmentCreateWithoutHistoryInput[] | StatusAttachmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: StatusAttachmentCreateOrConnectWithoutHistoryInput | StatusAttachmentCreateOrConnectWithoutHistoryInput[]
    createMany?: StatusAttachmentCreateManyHistoryInputEnvelope
    connect?: StatusAttachmentWhereUniqueInput | StatusAttachmentWhereUniqueInput[]
  }

  export type RequestUpdateOneRequiredWithoutRequestStatusHistoryNestedInput = {
    create?: XOR<RequestCreateWithoutRequestStatusHistoryInput, RequestUncheckedCreateWithoutRequestStatusHistoryInput>
    connectOrCreate?: RequestCreateOrConnectWithoutRequestStatusHistoryInput
    upsert?: RequestUpsertWithoutRequestStatusHistoryInput
    connect?: RequestWhereUniqueInput
    update?: XOR<XOR<RequestUpdateToOneWithWhereWithoutRequestStatusHistoryInput, RequestUpdateWithoutRequestStatusHistoryInput>, RequestUncheckedUpdateWithoutRequestStatusHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutRequestHistoryNestedInput = {
    create?: XOR<UserCreateWithoutRequestHistoryInput, UserUncheckedCreateWithoutRequestHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestHistoryInput
    upsert?: UserUpsertWithoutRequestHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequestHistoryInput, UserUpdateWithoutRequestHistoryInput>, UserUncheckedUpdateWithoutRequestHistoryInput>
  }

  export type StatusAttachmentUpdateManyWithoutHistoryNestedInput = {
    create?: XOR<StatusAttachmentCreateWithoutHistoryInput, StatusAttachmentUncheckedCreateWithoutHistoryInput> | StatusAttachmentCreateWithoutHistoryInput[] | StatusAttachmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: StatusAttachmentCreateOrConnectWithoutHistoryInput | StatusAttachmentCreateOrConnectWithoutHistoryInput[]
    upsert?: StatusAttachmentUpsertWithWhereUniqueWithoutHistoryInput | StatusAttachmentUpsertWithWhereUniqueWithoutHistoryInput[]
    createMany?: StatusAttachmentCreateManyHistoryInputEnvelope
    set?: StatusAttachmentWhereUniqueInput | StatusAttachmentWhereUniqueInput[]
    disconnect?: StatusAttachmentWhereUniqueInput | StatusAttachmentWhereUniqueInput[]
    delete?: StatusAttachmentWhereUniqueInput | StatusAttachmentWhereUniqueInput[]
    connect?: StatusAttachmentWhereUniqueInput | StatusAttachmentWhereUniqueInput[]
    update?: StatusAttachmentUpdateWithWhereUniqueWithoutHistoryInput | StatusAttachmentUpdateWithWhereUniqueWithoutHistoryInput[]
    updateMany?: StatusAttachmentUpdateManyWithWhereWithoutHistoryInput | StatusAttachmentUpdateManyWithWhereWithoutHistoryInput[]
    deleteMany?: StatusAttachmentScalarWhereInput | StatusAttachmentScalarWhereInput[]
  }

  export type StatusAttachmentUncheckedUpdateManyWithoutHistoryNestedInput = {
    create?: XOR<StatusAttachmentCreateWithoutHistoryInput, StatusAttachmentUncheckedCreateWithoutHistoryInput> | StatusAttachmentCreateWithoutHistoryInput[] | StatusAttachmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: StatusAttachmentCreateOrConnectWithoutHistoryInput | StatusAttachmentCreateOrConnectWithoutHistoryInput[]
    upsert?: StatusAttachmentUpsertWithWhereUniqueWithoutHistoryInput | StatusAttachmentUpsertWithWhereUniqueWithoutHistoryInput[]
    createMany?: StatusAttachmentCreateManyHistoryInputEnvelope
    set?: StatusAttachmentWhereUniqueInput | StatusAttachmentWhereUniqueInput[]
    disconnect?: StatusAttachmentWhereUniqueInput | StatusAttachmentWhereUniqueInput[]
    delete?: StatusAttachmentWhereUniqueInput | StatusAttachmentWhereUniqueInput[]
    connect?: StatusAttachmentWhereUniqueInput | StatusAttachmentWhereUniqueInput[]
    update?: StatusAttachmentUpdateWithWhereUniqueWithoutHistoryInput | StatusAttachmentUpdateWithWhereUniqueWithoutHistoryInput[]
    updateMany?: StatusAttachmentUpdateManyWithWhereWithoutHistoryInput | StatusAttachmentUpdateManyWithWhereWithoutHistoryInput[]
    deleteMany?: StatusAttachmentScalarWhereInput | StatusAttachmentScalarWhereInput[]
  }

  export type RequestStatusHistoryCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutAttachmentsInput, RequestStatusHistoryUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutAttachmentsInput
    connect?: RequestStatusHistoryWhereUniqueInput
  }

  export type RequestStatusHistoryUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<RequestStatusHistoryCreateWithoutAttachmentsInput, RequestStatusHistoryUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: RequestStatusHistoryCreateOrConnectWithoutAttachmentsInput
    upsert?: RequestStatusHistoryUpsertWithoutAttachmentsInput
    connect?: RequestStatusHistoryWhereUniqueInput
    update?: XOR<XOR<RequestStatusHistoryUpdateToOneWithWhereWithoutAttachmentsInput, RequestStatusHistoryUpdateWithoutAttachmentsInput>, RequestStatusHistoryUncheckedUpdateWithoutAttachmentsInput>
  }

  export type RequestCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<RequestCreateWithoutAttachmentsInput, RequestUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: RequestCreateOrConnectWithoutAttachmentsInput
    connect?: RequestWhereUniqueInput
  }

  export type RequestUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<RequestCreateWithoutAttachmentsInput, RequestUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: RequestCreateOrConnectWithoutAttachmentsInput
    upsert?: RequestUpsertWithoutAttachmentsInput
    connect?: RequestWhereUniqueInput
    update?: XOR<XOR<RequestUpdateToOneWithWhereWithoutAttachmentsInput, RequestUpdateWithoutAttachmentsInput>, RequestUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserCreateNestedOneWithoutLeavesRequestedInput = {
    create?: XOR<UserCreateWithoutLeavesRequestedInput, UserUncheckedCreateWithoutLeavesRequestedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeavesRequestedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeavesToApproveInput = {
    create?: XOR<UserCreateWithoutLeavesToApproveInput, UserUncheckedCreateWithoutLeavesToApproveInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeavesToApproveInput
    connect?: UserWhereUniqueInput
  }

  export type LeaveAttachmentCreateNestedManyWithoutLeaveInput = {
    create?: XOR<LeaveAttachmentCreateWithoutLeaveInput, LeaveAttachmentUncheckedCreateWithoutLeaveInput> | LeaveAttachmentCreateWithoutLeaveInput[] | LeaveAttachmentUncheckedCreateWithoutLeaveInput[]
    connectOrCreate?: LeaveAttachmentCreateOrConnectWithoutLeaveInput | LeaveAttachmentCreateOrConnectWithoutLeaveInput[]
    createMany?: LeaveAttachmentCreateManyLeaveInputEnvelope
    connect?: LeaveAttachmentWhereUniqueInput | LeaveAttachmentWhereUniqueInput[]
  }

  export type LeaveStatusHistoryCreateNestedManyWithoutLeaveInput = {
    create?: XOR<LeaveStatusHistoryCreateWithoutLeaveInput, LeaveStatusHistoryUncheckedCreateWithoutLeaveInput> | LeaveStatusHistoryCreateWithoutLeaveInput[] | LeaveStatusHistoryUncheckedCreateWithoutLeaveInput[]
    connectOrCreate?: LeaveStatusHistoryCreateOrConnectWithoutLeaveInput | LeaveStatusHistoryCreateOrConnectWithoutLeaveInput[]
    createMany?: LeaveStatusHistoryCreateManyLeaveInputEnvelope
    connect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
  }

  export type LeaveAttachmentUncheckedCreateNestedManyWithoutLeaveInput = {
    create?: XOR<LeaveAttachmentCreateWithoutLeaveInput, LeaveAttachmentUncheckedCreateWithoutLeaveInput> | LeaveAttachmentCreateWithoutLeaveInput[] | LeaveAttachmentUncheckedCreateWithoutLeaveInput[]
    connectOrCreate?: LeaveAttachmentCreateOrConnectWithoutLeaveInput | LeaveAttachmentCreateOrConnectWithoutLeaveInput[]
    createMany?: LeaveAttachmentCreateManyLeaveInputEnvelope
    connect?: LeaveAttachmentWhereUniqueInput | LeaveAttachmentWhereUniqueInput[]
  }

  export type LeaveStatusHistoryUncheckedCreateNestedManyWithoutLeaveInput = {
    create?: XOR<LeaveStatusHistoryCreateWithoutLeaveInput, LeaveStatusHistoryUncheckedCreateWithoutLeaveInput> | LeaveStatusHistoryCreateWithoutLeaveInput[] | LeaveStatusHistoryUncheckedCreateWithoutLeaveInput[]
    connectOrCreate?: LeaveStatusHistoryCreateOrConnectWithoutLeaveInput | LeaveStatusHistoryCreateOrConnectWithoutLeaveInput[]
    createMany?: LeaveStatusHistoryCreateManyLeaveInputEnvelope
    connect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
  }

  export type EnumLeaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaveType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type UserUpdateOneRequiredWithoutLeavesRequestedNestedInput = {
    create?: XOR<UserCreateWithoutLeavesRequestedInput, UserUncheckedCreateWithoutLeavesRequestedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeavesRequestedInput
    upsert?: UserUpsertWithoutLeavesRequestedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeavesRequestedInput, UserUpdateWithoutLeavesRequestedInput>, UserUncheckedUpdateWithoutLeavesRequestedInput>
  }

  export type UserUpdateOneRequiredWithoutLeavesToApproveNestedInput = {
    create?: XOR<UserCreateWithoutLeavesToApproveInput, UserUncheckedCreateWithoutLeavesToApproveInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeavesToApproveInput
    upsert?: UserUpsertWithoutLeavesToApproveInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeavesToApproveInput, UserUpdateWithoutLeavesToApproveInput>, UserUncheckedUpdateWithoutLeavesToApproveInput>
  }

  export type LeaveAttachmentUpdateManyWithoutLeaveNestedInput = {
    create?: XOR<LeaveAttachmentCreateWithoutLeaveInput, LeaveAttachmentUncheckedCreateWithoutLeaveInput> | LeaveAttachmentCreateWithoutLeaveInput[] | LeaveAttachmentUncheckedCreateWithoutLeaveInput[]
    connectOrCreate?: LeaveAttachmentCreateOrConnectWithoutLeaveInput | LeaveAttachmentCreateOrConnectWithoutLeaveInput[]
    upsert?: LeaveAttachmentUpsertWithWhereUniqueWithoutLeaveInput | LeaveAttachmentUpsertWithWhereUniqueWithoutLeaveInput[]
    createMany?: LeaveAttachmentCreateManyLeaveInputEnvelope
    set?: LeaveAttachmentWhereUniqueInput | LeaveAttachmentWhereUniqueInput[]
    disconnect?: LeaveAttachmentWhereUniqueInput | LeaveAttachmentWhereUniqueInput[]
    delete?: LeaveAttachmentWhereUniqueInput | LeaveAttachmentWhereUniqueInput[]
    connect?: LeaveAttachmentWhereUniqueInput | LeaveAttachmentWhereUniqueInput[]
    update?: LeaveAttachmentUpdateWithWhereUniqueWithoutLeaveInput | LeaveAttachmentUpdateWithWhereUniqueWithoutLeaveInput[]
    updateMany?: LeaveAttachmentUpdateManyWithWhereWithoutLeaveInput | LeaveAttachmentUpdateManyWithWhereWithoutLeaveInput[]
    deleteMany?: LeaveAttachmentScalarWhereInput | LeaveAttachmentScalarWhereInput[]
  }

  export type LeaveStatusHistoryUpdateManyWithoutLeaveNestedInput = {
    create?: XOR<LeaveStatusHistoryCreateWithoutLeaveInput, LeaveStatusHistoryUncheckedCreateWithoutLeaveInput> | LeaveStatusHistoryCreateWithoutLeaveInput[] | LeaveStatusHistoryUncheckedCreateWithoutLeaveInput[]
    connectOrCreate?: LeaveStatusHistoryCreateOrConnectWithoutLeaveInput | LeaveStatusHistoryCreateOrConnectWithoutLeaveInput[]
    upsert?: LeaveStatusHistoryUpsertWithWhereUniqueWithoutLeaveInput | LeaveStatusHistoryUpsertWithWhereUniqueWithoutLeaveInput[]
    createMany?: LeaveStatusHistoryCreateManyLeaveInputEnvelope
    set?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    disconnect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    delete?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    connect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    update?: LeaveStatusHistoryUpdateWithWhereUniqueWithoutLeaveInput | LeaveStatusHistoryUpdateWithWhereUniqueWithoutLeaveInput[]
    updateMany?: LeaveStatusHistoryUpdateManyWithWhereWithoutLeaveInput | LeaveStatusHistoryUpdateManyWithWhereWithoutLeaveInput[]
    deleteMany?: LeaveStatusHistoryScalarWhereInput | LeaveStatusHistoryScalarWhereInput[]
  }

  export type LeaveAttachmentUncheckedUpdateManyWithoutLeaveNestedInput = {
    create?: XOR<LeaveAttachmentCreateWithoutLeaveInput, LeaveAttachmentUncheckedCreateWithoutLeaveInput> | LeaveAttachmentCreateWithoutLeaveInput[] | LeaveAttachmentUncheckedCreateWithoutLeaveInput[]
    connectOrCreate?: LeaveAttachmentCreateOrConnectWithoutLeaveInput | LeaveAttachmentCreateOrConnectWithoutLeaveInput[]
    upsert?: LeaveAttachmentUpsertWithWhereUniqueWithoutLeaveInput | LeaveAttachmentUpsertWithWhereUniqueWithoutLeaveInput[]
    createMany?: LeaveAttachmentCreateManyLeaveInputEnvelope
    set?: LeaveAttachmentWhereUniqueInput | LeaveAttachmentWhereUniqueInput[]
    disconnect?: LeaveAttachmentWhereUniqueInput | LeaveAttachmentWhereUniqueInput[]
    delete?: LeaveAttachmentWhereUniqueInput | LeaveAttachmentWhereUniqueInput[]
    connect?: LeaveAttachmentWhereUniqueInput | LeaveAttachmentWhereUniqueInput[]
    update?: LeaveAttachmentUpdateWithWhereUniqueWithoutLeaveInput | LeaveAttachmentUpdateWithWhereUniqueWithoutLeaveInput[]
    updateMany?: LeaveAttachmentUpdateManyWithWhereWithoutLeaveInput | LeaveAttachmentUpdateManyWithWhereWithoutLeaveInput[]
    deleteMany?: LeaveAttachmentScalarWhereInput | LeaveAttachmentScalarWhereInput[]
  }

  export type LeaveStatusHistoryUncheckedUpdateManyWithoutLeaveNestedInput = {
    create?: XOR<LeaveStatusHistoryCreateWithoutLeaveInput, LeaveStatusHistoryUncheckedCreateWithoutLeaveInput> | LeaveStatusHistoryCreateWithoutLeaveInput[] | LeaveStatusHistoryUncheckedCreateWithoutLeaveInput[]
    connectOrCreate?: LeaveStatusHistoryCreateOrConnectWithoutLeaveInput | LeaveStatusHistoryCreateOrConnectWithoutLeaveInput[]
    upsert?: LeaveStatusHistoryUpsertWithWhereUniqueWithoutLeaveInput | LeaveStatusHistoryUpsertWithWhereUniqueWithoutLeaveInput[]
    createMany?: LeaveStatusHistoryCreateManyLeaveInputEnvelope
    set?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    disconnect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    delete?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    connect?: LeaveStatusHistoryWhereUniqueInput | LeaveStatusHistoryWhereUniqueInput[]
    update?: LeaveStatusHistoryUpdateWithWhereUniqueWithoutLeaveInput | LeaveStatusHistoryUpdateWithWhereUniqueWithoutLeaveInput[]
    updateMany?: LeaveStatusHistoryUpdateManyWithWhereWithoutLeaveInput | LeaveStatusHistoryUpdateManyWithWhereWithoutLeaveInput[]
    deleteMany?: LeaveStatusHistoryScalarWhereInput | LeaveStatusHistoryScalarWhereInput[]
  }

  export type LeaveRequestCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<LeaveRequestCreateWithoutAttachmentsInput, LeaveRequestUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutAttachmentsInput
    connect?: LeaveRequestWhereUniqueInput
  }

  export type LeaveRequestUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutAttachmentsInput, LeaveRequestUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutAttachmentsInput
    upsert?: LeaveRequestUpsertWithoutAttachmentsInput
    connect?: LeaveRequestWhereUniqueInput
    update?: XOR<XOR<LeaveRequestUpdateToOneWithWhereWithoutAttachmentsInput, LeaveRequestUpdateWithoutAttachmentsInput>, LeaveRequestUncheckedUpdateWithoutAttachmentsInput>
  }

  export type LeaveRequestCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<LeaveRequestCreateWithoutStatusHistoryInput, LeaveRequestUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutStatusHistoryInput
    connect?: LeaveRequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeaveStatusHistoryInput = {
    create?: XOR<UserCreateWithoutLeaveStatusHistoryInput, UserUncheckedCreateWithoutLeaveStatusHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveStatusHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type LeaveStatusAttachmentCreateNestedManyWithoutHistoryInput = {
    create?: XOR<LeaveStatusAttachmentCreateWithoutHistoryInput, LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput> | LeaveStatusAttachmentCreateWithoutHistoryInput[] | LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: LeaveStatusAttachmentCreateOrConnectWithoutHistoryInput | LeaveStatusAttachmentCreateOrConnectWithoutHistoryInput[]
    createMany?: LeaveStatusAttachmentCreateManyHistoryInputEnvelope
    connect?: LeaveStatusAttachmentWhereUniqueInput | LeaveStatusAttachmentWhereUniqueInput[]
  }

  export type LeaveStatusAttachmentUncheckedCreateNestedManyWithoutHistoryInput = {
    create?: XOR<LeaveStatusAttachmentCreateWithoutHistoryInput, LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput> | LeaveStatusAttachmentCreateWithoutHistoryInput[] | LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: LeaveStatusAttachmentCreateOrConnectWithoutHistoryInput | LeaveStatusAttachmentCreateOrConnectWithoutHistoryInput[]
    createMany?: LeaveStatusAttachmentCreateManyHistoryInputEnvelope
    connect?: LeaveStatusAttachmentWhereUniqueInput | LeaveStatusAttachmentWhereUniqueInput[]
  }

  export type LeaveRequestUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutStatusHistoryInput, LeaveRequestUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutStatusHistoryInput
    upsert?: LeaveRequestUpsertWithoutStatusHistoryInput
    connect?: LeaveRequestWhereUniqueInput
    update?: XOR<XOR<LeaveRequestUpdateToOneWithWhereWithoutStatusHistoryInput, LeaveRequestUpdateWithoutStatusHistoryInput>, LeaveRequestUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutLeaveStatusHistoryNestedInput = {
    create?: XOR<UserCreateWithoutLeaveStatusHistoryInput, UserUncheckedCreateWithoutLeaveStatusHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveStatusHistoryInput
    upsert?: UserUpsertWithoutLeaveStatusHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaveStatusHistoryInput, UserUpdateWithoutLeaveStatusHistoryInput>, UserUncheckedUpdateWithoutLeaveStatusHistoryInput>
  }

  export type LeaveStatusAttachmentUpdateManyWithoutHistoryNestedInput = {
    create?: XOR<LeaveStatusAttachmentCreateWithoutHistoryInput, LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput> | LeaveStatusAttachmentCreateWithoutHistoryInput[] | LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: LeaveStatusAttachmentCreateOrConnectWithoutHistoryInput | LeaveStatusAttachmentCreateOrConnectWithoutHistoryInput[]
    upsert?: LeaveStatusAttachmentUpsertWithWhereUniqueWithoutHistoryInput | LeaveStatusAttachmentUpsertWithWhereUniqueWithoutHistoryInput[]
    createMany?: LeaveStatusAttachmentCreateManyHistoryInputEnvelope
    set?: LeaveStatusAttachmentWhereUniqueInput | LeaveStatusAttachmentWhereUniqueInput[]
    disconnect?: LeaveStatusAttachmentWhereUniqueInput | LeaveStatusAttachmentWhereUniqueInput[]
    delete?: LeaveStatusAttachmentWhereUniqueInput | LeaveStatusAttachmentWhereUniqueInput[]
    connect?: LeaveStatusAttachmentWhereUniqueInput | LeaveStatusAttachmentWhereUniqueInput[]
    update?: LeaveStatusAttachmentUpdateWithWhereUniqueWithoutHistoryInput | LeaveStatusAttachmentUpdateWithWhereUniqueWithoutHistoryInput[]
    updateMany?: LeaveStatusAttachmentUpdateManyWithWhereWithoutHistoryInput | LeaveStatusAttachmentUpdateManyWithWhereWithoutHistoryInput[]
    deleteMany?: LeaveStatusAttachmentScalarWhereInput | LeaveStatusAttachmentScalarWhereInput[]
  }

  export type LeaveStatusAttachmentUncheckedUpdateManyWithoutHistoryNestedInput = {
    create?: XOR<LeaveStatusAttachmentCreateWithoutHistoryInput, LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput> | LeaveStatusAttachmentCreateWithoutHistoryInput[] | LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput[]
    connectOrCreate?: LeaveStatusAttachmentCreateOrConnectWithoutHistoryInput | LeaveStatusAttachmentCreateOrConnectWithoutHistoryInput[]
    upsert?: LeaveStatusAttachmentUpsertWithWhereUniqueWithoutHistoryInput | LeaveStatusAttachmentUpsertWithWhereUniqueWithoutHistoryInput[]
    createMany?: LeaveStatusAttachmentCreateManyHistoryInputEnvelope
    set?: LeaveStatusAttachmentWhereUniqueInput | LeaveStatusAttachmentWhereUniqueInput[]
    disconnect?: LeaveStatusAttachmentWhereUniqueInput | LeaveStatusAttachmentWhereUniqueInput[]
    delete?: LeaveStatusAttachmentWhereUniqueInput | LeaveStatusAttachmentWhereUniqueInput[]
    connect?: LeaveStatusAttachmentWhereUniqueInput | LeaveStatusAttachmentWhereUniqueInput[]
    update?: LeaveStatusAttachmentUpdateWithWhereUniqueWithoutHistoryInput | LeaveStatusAttachmentUpdateWithWhereUniqueWithoutHistoryInput[]
    updateMany?: LeaveStatusAttachmentUpdateManyWithWhereWithoutHistoryInput | LeaveStatusAttachmentUpdateManyWithWhereWithoutHistoryInput[]
    deleteMany?: LeaveStatusAttachmentScalarWhereInput | LeaveStatusAttachmentScalarWhereInput[]
  }

  export type LeaveStatusHistoryCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<LeaveStatusHistoryCreateWithoutAttachmentsInput, LeaveStatusHistoryUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: LeaveStatusHistoryCreateOrConnectWithoutAttachmentsInput
    connect?: LeaveStatusHistoryWhereUniqueInput
  }

  export type LeaveStatusHistoryUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<LeaveStatusHistoryCreateWithoutAttachmentsInput, LeaveStatusHistoryUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: LeaveStatusHistoryCreateOrConnectWithoutAttachmentsInput
    upsert?: LeaveStatusHistoryUpsertWithoutAttachmentsInput
    connect?: LeaveStatusHistoryWhereUniqueInput
    update?: XOR<XOR<LeaveStatusHistoryUpdateToOneWithWhereWithoutAttachmentsInput, LeaveStatusHistoryUpdateWithoutAttachmentsInput>, LeaveStatusHistoryUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type JobListingCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<JobListingCreateWithoutDepartmentInput, JobListingUncheckedCreateWithoutDepartmentInput> | JobListingCreateWithoutDepartmentInput[] | JobListingUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutDepartmentInput | JobListingCreateOrConnectWithoutDepartmentInput[]
    createMany?: JobListingCreateManyDepartmentInputEnvelope
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type JobListingUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<JobListingCreateWithoutDepartmentInput, JobListingUncheckedCreateWithoutDepartmentInput> | JobListingCreateWithoutDepartmentInput[] | JobListingUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutDepartmentInput | JobListingCreateOrConnectWithoutDepartmentInput[]
    createMany?: JobListingCreateManyDepartmentInputEnvelope
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type JobListingUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<JobListingCreateWithoutDepartmentInput, JobListingUncheckedCreateWithoutDepartmentInput> | JobListingCreateWithoutDepartmentInput[] | JobListingUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutDepartmentInput | JobListingCreateOrConnectWithoutDepartmentInput[]
    upsert?: JobListingUpsertWithWhereUniqueWithoutDepartmentInput | JobListingUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: JobListingCreateManyDepartmentInputEnvelope
    set?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    disconnect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    delete?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    update?: JobListingUpdateWithWhereUniqueWithoutDepartmentInput | JobListingUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: JobListingUpdateManyWithWhereWithoutDepartmentInput | JobListingUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: JobListingScalarWhereInput | JobListingScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type JobListingUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<JobListingCreateWithoutDepartmentInput, JobListingUncheckedCreateWithoutDepartmentInput> | JobListingCreateWithoutDepartmentInput[] | JobListingUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutDepartmentInput | JobListingCreateOrConnectWithoutDepartmentInput[]
    upsert?: JobListingUpsertWithWhereUniqueWithoutDepartmentInput | JobListingUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: JobListingCreateManyDepartmentInputEnvelope
    set?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    disconnect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    delete?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    update?: JobListingUpdateWithWhereUniqueWithoutDepartmentInput | JobListingUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: JobListingUpdateManyWithWhereWithoutDepartmentInput | JobListingUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: JobListingScalarWhereInput | JobListingScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type JobListingCreateNestedManyWithoutLocationInput = {
    create?: XOR<JobListingCreateWithoutLocationInput, JobListingUncheckedCreateWithoutLocationInput> | JobListingCreateWithoutLocationInput[] | JobListingUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutLocationInput | JobListingCreateOrConnectWithoutLocationInput[]
    createMany?: JobListingCreateManyLocationInputEnvelope
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type JobListingUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<JobListingCreateWithoutLocationInput, JobListingUncheckedCreateWithoutLocationInput> | JobListingCreateWithoutLocationInput[] | JobListingUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutLocationInput | JobListingCreateOrConnectWithoutLocationInput[]
    createMany?: JobListingCreateManyLocationInputEnvelope
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationInput | UserUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationInput | UserUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationInput | UserUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type JobListingUpdateManyWithoutLocationNestedInput = {
    create?: XOR<JobListingCreateWithoutLocationInput, JobListingUncheckedCreateWithoutLocationInput> | JobListingCreateWithoutLocationInput[] | JobListingUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutLocationInput | JobListingCreateOrConnectWithoutLocationInput[]
    upsert?: JobListingUpsertWithWhereUniqueWithoutLocationInput | JobListingUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: JobListingCreateManyLocationInputEnvelope
    set?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    disconnect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    delete?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    update?: JobListingUpdateWithWhereUniqueWithoutLocationInput | JobListingUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: JobListingUpdateManyWithWhereWithoutLocationInput | JobListingUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: JobListingScalarWhereInput | JobListingScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationInput | UserUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationInput | UserUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationInput | UserUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type JobListingUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<JobListingCreateWithoutLocationInput, JobListingUncheckedCreateWithoutLocationInput> | JobListingCreateWithoutLocationInput[] | JobListingUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutLocationInput | JobListingCreateOrConnectWithoutLocationInput[]
    upsert?: JobListingUpsertWithWhereUniqueWithoutLocationInput | JobListingUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: JobListingCreateManyLocationInputEnvelope
    set?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    disconnect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    delete?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    update?: JobListingUpdateWithWhereUniqueWithoutLocationInput | JobListingUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: JobListingUpdateManyWithWhereWithoutLocationInput | JobListingUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: JobListingScalarWhereInput | JobListingScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutPositionInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type JobListingCreateNestedManyWithoutPositionInput = {
    create?: XOR<JobListingCreateWithoutPositionInput, JobListingUncheckedCreateWithoutPositionInput> | JobListingCreateWithoutPositionInput[] | JobListingUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutPositionInput | JobListingCreateOrConnectWithoutPositionInput[]
    createMany?: JobListingCreateManyPositionInputEnvelope
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type JobListingUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<JobListingCreateWithoutPositionInput, JobListingUncheckedCreateWithoutPositionInput> | JobListingCreateWithoutPositionInput[] | JobListingUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutPositionInput | JobListingCreateOrConnectWithoutPositionInput[]
    createMany?: JobListingCreateManyPositionInputEnvelope
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutPositionNestedInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPositionInput | UserUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPositionInput | UserUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPositionInput | UserUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type JobListingUpdateManyWithoutPositionNestedInput = {
    create?: XOR<JobListingCreateWithoutPositionInput, JobListingUncheckedCreateWithoutPositionInput> | JobListingCreateWithoutPositionInput[] | JobListingUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutPositionInput | JobListingCreateOrConnectWithoutPositionInput[]
    upsert?: JobListingUpsertWithWhereUniqueWithoutPositionInput | JobListingUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: JobListingCreateManyPositionInputEnvelope
    set?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    disconnect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    delete?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    update?: JobListingUpdateWithWhereUniqueWithoutPositionInput | JobListingUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: JobListingUpdateManyWithWhereWithoutPositionInput | JobListingUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: JobListingScalarWhereInput | JobListingScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPositionInput | UserUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPositionInput | UserUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPositionInput | UserUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type JobListingUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<JobListingCreateWithoutPositionInput, JobListingUncheckedCreateWithoutPositionInput> | JobListingCreateWithoutPositionInput[] | JobListingUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: JobListingCreateOrConnectWithoutPositionInput | JobListingCreateOrConnectWithoutPositionInput[]
    upsert?: JobListingUpsertWithWhereUniqueWithoutPositionInput | JobListingUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: JobListingCreateManyPositionInputEnvelope
    set?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    disconnect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    delete?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    connect?: JobListingWhereUniqueInput | JobListingWhereUniqueInput[]
    update?: JobListingUpdateWithWhereUniqueWithoutPositionInput | JobListingUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: JobListingUpdateManyWithWhereWithoutPositionInput | JobListingUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: JobListingScalarWhereInput | JobListingScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type EnumClientStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClientStatus
  }

  export type ProjectUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjectsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManagedProjectsInput = {
    create?: XOR<UserCreateWithoutManagedProjectsInput, UserUncheckedCreateWithoutManagedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type TimeEntryCreateNestedManyWithoutProjectInput = {
    create?: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput> | TimeEntryCreateWithoutProjectInput[] | TimeEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutProjectInput | TimeEntryCreateOrConnectWithoutProjectInput[]
    createMany?: TimeEntryCreateManyProjectInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type TimeEntryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput> | TimeEntryCreateWithoutProjectInput[] | TimeEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutProjectInput | TimeEntryCreateOrConnectWithoutProjectInput[]
    createMany?: TimeEntryCreateManyProjectInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type ClientUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjectsInput
    upsert?: ClientUpsertWithoutProjectsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutProjectsInput, ClientUpdateWithoutProjectsInput>, ClientUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateOneRequiredWithoutManagedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutManagedProjectsInput, UserUncheckedCreateWithoutManagedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedProjectsInput
    upsert?: UserUpsertWithoutManagedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedProjectsInput, UserUpdateWithoutManagedProjectsInput>, UserUncheckedUpdateWithoutManagedProjectsInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type TimeEntryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput> | TimeEntryCreateWithoutProjectInput[] | TimeEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutProjectInput | TimeEntryCreateOrConnectWithoutProjectInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutProjectInput | TimeEntryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TimeEntryCreateManyProjectInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutProjectInput | TimeEntryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutProjectInput | TimeEntryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type TimeEntryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput> | TimeEntryCreateWithoutProjectInput[] | TimeEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutProjectInput | TimeEntryCreateOrConnectWithoutProjectInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutProjectInput | TimeEntryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TimeEntryCreateManyProjectInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutProjectInput | TimeEntryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutProjectInput | TimeEntryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMembershipsInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumProjectMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.ProjectMemberRole
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    upsert?: UserUpsertWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMembershipsInput, UserUpdateWithoutProjectMembershipsInput>, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type ProjectCreateNestedOneWithoutTimeEntriesInput = {
    create?: XOR<ProjectCreateWithoutTimeEntriesInput, ProjectUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTimeEntriesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTimeEntriesInput = {
    create?: XOR<UserCreateWithoutTimeEntriesInput, UserUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTimeEntryStatusFieldUpdateOperationsInput = {
    set?: $Enums.TimeEntryStatus
  }

  export type ProjectUpdateOneRequiredWithoutTimeEntriesNestedInput = {
    create?: XOR<ProjectCreateWithoutTimeEntriesInput, ProjectUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTimeEntriesInput
    upsert?: ProjectUpsertWithoutTimeEntriesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTimeEntriesInput, ProjectUpdateWithoutTimeEntriesInput>, ProjectUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutTimeEntriesNestedInput = {
    create?: XOR<UserCreateWithoutTimeEntriesInput, UserUncheckedCreateWithoutTimeEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeEntriesInput
    upsert?: UserUpsertWithoutTimeEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimeEntriesInput, UserUpdateWithoutTimeEntriesInput>, UserUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type UserCreateNestedOneWithoutAnnouncementsChangedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsChangedInput, UserUncheckedCreateWithoutAnnouncementsChangedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsChangedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnnouncementsPublishedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsPublishedInput, UserUncheckedCreateWithoutAnnouncementsPublishedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsPublishedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAnnouncementsChangedNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsChangedInput, UserUncheckedCreateWithoutAnnouncementsChangedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsChangedInput
    upsert?: UserUpsertWithoutAnnouncementsChangedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnouncementsChangedInput, UserUpdateWithoutAnnouncementsChangedInput>, UserUncheckedUpdateWithoutAnnouncementsChangedInput>
  }

  export type UserUpdateOneRequiredWithoutAnnouncementsPublishedNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsPublishedInput, UserUncheckedCreateWithoutAnnouncementsPublishedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsPublishedInput
    upsert?: UserUpsertWithoutAnnouncementsPublishedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnouncementsPublishedInput, UserUpdateWithoutAnnouncementsPublishedInput>, UserUncheckedUpdateWithoutAnnouncementsPublishedInput>
  }

  export type ShiftEntryCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ShiftEntryCreateWithoutScheduleInput, ShiftEntryUncheckedCreateWithoutScheduleInput> | ShiftEntryCreateWithoutScheduleInput[] | ShiftEntryUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ShiftEntryCreateOrConnectWithoutScheduleInput | ShiftEntryCreateOrConnectWithoutScheduleInput[]
    createMany?: ShiftEntryCreateManyScheduleInputEnvelope
    connect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
  }

  export type ShiftEntryUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ShiftEntryCreateWithoutScheduleInput, ShiftEntryUncheckedCreateWithoutScheduleInput> | ShiftEntryCreateWithoutScheduleInput[] | ShiftEntryUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ShiftEntryCreateOrConnectWithoutScheduleInput | ShiftEntryCreateOrConnectWithoutScheduleInput[]
    createMany?: ShiftEntryCreateManyScheduleInputEnvelope
    connect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
  }

  export type ShiftEntryUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ShiftEntryCreateWithoutScheduleInput, ShiftEntryUncheckedCreateWithoutScheduleInput> | ShiftEntryCreateWithoutScheduleInput[] | ShiftEntryUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ShiftEntryCreateOrConnectWithoutScheduleInput | ShiftEntryCreateOrConnectWithoutScheduleInput[]
    upsert?: ShiftEntryUpsertWithWhereUniqueWithoutScheduleInput | ShiftEntryUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ShiftEntryCreateManyScheduleInputEnvelope
    set?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    disconnect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    delete?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    connect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    update?: ShiftEntryUpdateWithWhereUniqueWithoutScheduleInput | ShiftEntryUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ShiftEntryUpdateManyWithWhereWithoutScheduleInput | ShiftEntryUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ShiftEntryScalarWhereInput | ShiftEntryScalarWhereInput[]
  }

  export type ShiftEntryUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ShiftEntryCreateWithoutScheduleInput, ShiftEntryUncheckedCreateWithoutScheduleInput> | ShiftEntryCreateWithoutScheduleInput[] | ShiftEntryUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ShiftEntryCreateOrConnectWithoutScheduleInput | ShiftEntryCreateOrConnectWithoutScheduleInput[]
    upsert?: ShiftEntryUpsertWithWhereUniqueWithoutScheduleInput | ShiftEntryUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ShiftEntryCreateManyScheduleInputEnvelope
    set?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    disconnect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    delete?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    connect?: ShiftEntryWhereUniqueInput | ShiftEntryWhereUniqueInput[]
    update?: ShiftEntryUpdateWithWhereUniqueWithoutScheduleInput | ShiftEntryUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ShiftEntryUpdateManyWithWhereWithoutScheduleInput | ShiftEntryUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ShiftEntryScalarWhereInput | ShiftEntryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutShiftsInput = {
    create?: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftsInput
    connect?: UserWhereUniqueInput
  }

  export type TimeScheduleCreateNestedOneWithoutShiftsInput = {
    create?: XOR<TimeScheduleCreateWithoutShiftsInput, TimeScheduleUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: TimeScheduleCreateOrConnectWithoutShiftsInput
    connect?: TimeScheduleWhereUniqueInput
  }

  export type EnumShiftStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShiftStatus
  }

  export type UserUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftsInput
    upsert?: UserUpsertWithoutShiftsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShiftsInput, UserUpdateWithoutShiftsInput>, UserUncheckedUpdateWithoutShiftsInput>
  }

  export type TimeScheduleUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<TimeScheduleCreateWithoutShiftsInput, TimeScheduleUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: TimeScheduleCreateOrConnectWithoutShiftsInput
    upsert?: TimeScheduleUpsertWithoutShiftsInput
    connect?: TimeScheduleWhereUniqueInput
    update?: XOR<XOR<TimeScheduleUpdateToOneWithWhereWithoutShiftsInput, TimeScheduleUpdateWithoutShiftsInput>, TimeScheduleUncheckedUpdateWithoutShiftsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumEmploymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeFilter<$PrismaModel> | $Enums.EmploymentType
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumWorkplaceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkplaceType | EnumWorkplaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkplaceType[] | ListEnumWorkplaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkplaceType[] | ListEnumWorkplaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkplaceTypeFilter<$PrismaModel> | $Enums.WorkplaceType
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumWorkplaceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkplaceType | EnumWorkplaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkplaceType[] | ListEnumWorkplaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkplaceType[] | ListEnumWorkplaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkplaceTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkplaceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkplaceTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkplaceTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMaritalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaritalStatusFilter<$PrismaModel> | $Enums.MaritalStatus
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumEducationLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EducationLevel | EnumEducationLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEducationLevelNullableFilter<$PrismaModel> | $Enums.EducationLevel | null
  }

  export type NestedEnumMaritalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaritalStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumEducationLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EducationLevel | EnumEducationLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEducationLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.EducationLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEducationLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumEducationLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumIdentificationDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationDocumentType | EnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdentificationDocumentType[] | ListEnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentificationDocumentType[] | ListEnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentificationDocumentTypeFilter<$PrismaModel> | $Enums.IdentificationDocumentType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumIdentificationDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationDocumentType | EnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdentificationDocumentType[] | ListEnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentificationDocumentType[] | ListEnumIdentificationDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentificationDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.IdentificationDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdentificationDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumIdentificationDocumentTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType
  }

  export type NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.Phase | EnumPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.Phase[] | ListEnumPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.Phase[] | ListEnumPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumPhaseFilter<$PrismaModel> | $Enums.Phase
  }

  export type NestedEnumOnboardingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OnboardingStatus | EnumOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnboardingStatusFilter<$PrismaModel> | $Enums.OnboardingStatus
  }

  export type NestedEnumPhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Phase | EnumPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.Phase[] | ListEnumPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.Phase[] | ListEnumPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumPhaseWithAggregatesFilter<$PrismaModel> | $Enums.Phase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhaseFilter<$PrismaModel>
    _max?: NestedEnumPhaseFilter<$PrismaModel>
  }

  export type NestedEnumOnboardingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OnboardingStatus | EnumOnboardingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OnboardingStatus[] | ListEnumOnboardingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOnboardingStatusWithAggregatesFilter<$PrismaModel> | $Enums.OnboardingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOnboardingStatusFilter<$PrismaModel>
    _max?: NestedEnumOnboardingStatusFilter<$PrismaModel>
  }

  export type NestedEnumEmailTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailType | EnumEmailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTypeFilter<$PrismaModel> | $Enums.EmailType
  }

  export type NestedEnumEmailTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailType | EnumEmailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailType[] | ListEnumEmailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmailType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailTypeFilter<$PrismaModel>
    _max?: NestedEnumEmailTypeFilter<$PrismaModel>
  }

  export type NestedEnumPhoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneType | EnumPhoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhoneTypeFilter<$PrismaModel> | $Enums.PhoneType
  }

  export type NestedEnumPhoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneType | EnumPhoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.PhoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhoneTypeFilter<$PrismaModel>
    _max?: NestedEnumPhoneTypeFilter<$PrismaModel>
  }

  export type NestedEnumGreekBankFilter<$PrismaModel = never> = {
    equals?: $Enums.GreekBank | EnumGreekBankFieldRefInput<$PrismaModel>
    in?: $Enums.GreekBank[] | ListEnumGreekBankFieldRefInput<$PrismaModel>
    notIn?: $Enums.GreekBank[] | ListEnumGreekBankFieldRefInput<$PrismaModel>
    not?: NestedEnumGreekBankFilter<$PrismaModel> | $Enums.GreekBank
  }

  export type NestedEnumGreekBankWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GreekBank | EnumGreekBankFieldRefInput<$PrismaModel>
    in?: $Enums.GreekBank[] | ListEnumGreekBankFieldRefInput<$PrismaModel>
    notIn?: $Enums.GreekBank[] | ListEnumGreekBankFieldRefInput<$PrismaModel>
    not?: NestedEnumGreekBankWithAggregatesFilter<$PrismaModel> | $Enums.GreekBank
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGreekBankFilter<$PrismaModel>
    _max?: NestedEnumGreekBankFilter<$PrismaModel>
  }

  export type NestedEnumContractStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusFilter<$PrismaModel> | $Enums.ContractStatus
  }

  export type NestedEnumContractStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractStatusFilter<$PrismaModel>
    _max?: NestedEnumContractStatusFilter<$PrismaModel>
  }

  export type NestedEnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type NestedEnumProficiencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Proficiency | EnumProficiencyFieldRefInput<$PrismaModel>
    in?: $Enums.Proficiency[] | ListEnumProficiencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Proficiency[] | ListEnumProficiencyFieldRefInput<$PrismaModel>
    not?: NestedEnumProficiencyFilter<$PrismaModel> | $Enums.Proficiency
  }

  export type NestedEnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type NestedEnumProficiencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Proficiency | EnumProficiencyFieldRefInput<$PrismaModel>
    in?: $Enums.Proficiency[] | ListEnumProficiencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Proficiency[] | ListEnumProficiencyFieldRefInput<$PrismaModel>
    not?: NestedEnumProficiencyWithAggregatesFilter<$PrismaModel> | $Enums.Proficiency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProficiencyFilter<$PrismaModel>
    _max?: NestedEnumProficiencyFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type NestedEnumClientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusFilter<$PrismaModel> | $Enums.ClientStatus
  }

  export type NestedEnumClientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientStatusFilter<$PrismaModel>
    _max?: NestedEnumClientStatusFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumProjectMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectMemberRole | EnumProjectMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectMemberRoleFilter<$PrismaModel> | $Enums.ProjectMemberRole
  }

  export type NestedEnumProjectMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectMemberRole | EnumProjectMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectMemberRoleFilter<$PrismaModel>
  }

  export type NestedEnumTimeEntryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeEntryStatus | EnumTimeEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TimeEntryStatus[] | ListEnumTimeEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeEntryStatus[] | ListEnumTimeEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeEntryStatusFilter<$PrismaModel> | $Enums.TimeEntryStatus
  }

  export type NestedEnumTimeEntryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeEntryStatus | EnumTimeEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TimeEntryStatus[] | ListEnumTimeEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeEntryStatus[] | ListEnumTimeEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeEntryStatusWithAggregatesFilter<$PrismaModel> | $Enums.TimeEntryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimeEntryStatusFilter<$PrismaModel>
    _max?: NestedEnumTimeEntryStatusFilter<$PrismaModel>
  }

  export type NestedEnumShiftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftStatus | EnumShiftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftStatus[] | ListEnumShiftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftStatus[] | ListEnumShiftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftStatusFilter<$PrismaModel> | $Enums.ShiftStatus
  }

  export type NestedEnumShiftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftStatus | EnumShiftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftStatus[] | ListEnumShiftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShiftStatus[] | ListEnumShiftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShiftStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShiftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftStatusFilter<$PrismaModel>
    _max?: NestedEnumShiftStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type DepartmentCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    JobListing?: JobListingCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    JobListing?: JobListingUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutUsersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
  }

  export type CandidateNoteCreateWithoutCreatedByInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    candidate: CandidateCreateNestedOneWithoutNotesInput
  }

  export type CandidateNoteUncheckedCreateWithoutCreatedByInput = {
    id?: number
    candidateId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CandidateNoteCreateOrConnectWithoutCreatedByInput = {
    where: CandidateNoteWhereUniqueInput
    create: XOR<CandidateNoteCreateWithoutCreatedByInput, CandidateNoteUncheckedCreateWithoutCreatedByInput>
  }

  export type CandidateNoteCreateManyCreatedByInputEnvelope = {
    data: CandidateNoteCreateManyCreatedByInput | CandidateNoteCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type JobApplicationHistoryCreateWithoutChangedByInput = {
    status: $Enums.ApplicationStatus
    comment?: string | null
    createdAt?: Date | string
    application: JobApplicationCreateNestedOneWithoutHistoryInput
  }

  export type JobApplicationHistoryUncheckedCreateWithoutChangedByInput = {
    id?: number
    applicationId: number
    status: $Enums.ApplicationStatus
    comment?: string | null
    createdAt?: Date | string
  }

  export type JobApplicationHistoryCreateOrConnectWithoutChangedByInput = {
    where: JobApplicationHistoryWhereUniqueInput
    create: XOR<JobApplicationHistoryCreateWithoutChangedByInput, JobApplicationHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type JobApplicationHistoryCreateManyChangedByInputEnvelope = {
    data: JobApplicationHistoryCreateManyChangedByInput | JobApplicationHistoryCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserStatusHistoryCreateWithoutUserInput = {
    status: $Enums.UserStatus
    comment?: string | null
    createdAt?: Date | string
    changedBy: UserCreateNestedOneWithoutStatusChangesByInput
  }

  export type UserStatusHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    status: $Enums.UserStatus
    comment?: string | null
    createdAt?: Date | string
    changedById: string
  }

  export type UserStatusHistoryCreateOrConnectWithoutUserInput = {
    where: UserStatusHistoryWhereUniqueInput
    create: XOR<UserStatusHistoryCreateWithoutUserInput, UserStatusHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserStatusHistoryCreateManyUserInputEnvelope = {
    data: UserStatusHistoryCreateManyUserInput | UserStatusHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserStatusHistoryCreateWithoutChangedByInput = {
    status: $Enums.UserStatus
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStatusHistoryInput
  }

  export type UserStatusHistoryUncheckedCreateWithoutChangedByInput = {
    id?: number
    userId: string
    status: $Enums.UserStatus
    comment?: string | null
    createdAt?: Date | string
  }

  export type UserStatusHistoryCreateOrConnectWithoutChangedByInput = {
    where: UserStatusHistoryWhereUniqueInput
    create: XOR<UserStatusHistoryCreateWithoutChangedByInput, UserStatusHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type UserStatusHistoryCreateManyChangedByInputEnvelope = {
    data: UserStatusHistoryCreateManyChangedByInput | UserStatusHistoryCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type PersonalInfoCreateWithoutUserInput = {
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    identificationDocuments?: IdentificationDocumentCreateNestedManyWithoutPersonalInfoInput
    addresses?: AddressCreateNestedManyWithoutPersonalInfoInput
    bankAccounts?: BankAccountCreateNestedManyWithoutPersonalInfoInput
    languageSkills?: LanguageSkillCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoUncheckedCreateWithoutUserInput = {
    id?: number
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    identificationDocuments?: IdentificationDocumentUncheckedCreateNestedManyWithoutPersonalInfoInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonalInfoInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutPersonalInfoInput
    languageSkills?: LanguageSkillUncheckedCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoCreateOrConnectWithoutUserInput = {
    where: PersonalInfoWhereUniqueInput
    create: XOR<PersonalInfoCreateWithoutUserInput, PersonalInfoUncheckedCreateWithoutUserInput>
  }

  export type DocumentCreateWithoutUserInput = {
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    dependentMember?: DependentMemberCreateNestedOneWithoutDocumentInput
    verification?: DocumentVerificationCreateNestedOneWithoutDocumentInput
    languageSkill?: LanguageSkillCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: number
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    dependentMemberId?: number | null
    languageSkillId?: number | null
    verification?: DocumentVerificationUncheckedCreateNestedOneWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCreateManyUserInputEnvelope = {
    data: DocumentCreateManyUserInput | DocumentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentVerificationCreateWithoutReviewedByInput = {
    status?: $Enums.VerificationStatus
    comments?: string | null
    reviewedAt?: Date | string | null
    document: DocumentCreateNestedOneWithoutVerificationInput
    User?: UserCreateNestedOneWithoutDocumentVerificationInput
  }

  export type DocumentVerificationUncheckedCreateWithoutReviewedByInput = {
    id?: number
    documentId: number
    status?: $Enums.VerificationStatus
    comments?: string | null
    reviewedAt?: Date | string | null
    userId?: string | null
  }

  export type DocumentVerificationCreateOrConnectWithoutReviewedByInput = {
    where: DocumentVerificationWhereUniqueInput
    create: XOR<DocumentVerificationCreateWithoutReviewedByInput, DocumentVerificationUncheckedCreateWithoutReviewedByInput>
  }

  export type DocumentVerificationCreateManyReviewedByInputEnvelope = {
    data: DocumentVerificationCreateManyReviewedByInput | DocumentVerificationCreateManyReviewedByInput[]
    skipDuplicates?: boolean
  }

  export type DocumentVerificationCreateWithoutUserInput = {
    status?: $Enums.VerificationStatus
    comments?: string | null
    reviewedAt?: Date | string | null
    document: DocumentCreateNestedOneWithoutVerificationInput
    reviewedBy: UserCreateNestedOneWithoutDocumentReviewsInput
  }

  export type DocumentVerificationUncheckedCreateWithoutUserInput = {
    id?: number
    documentId: number
    status?: $Enums.VerificationStatus
    reviewedById: string
    comments?: string | null
    reviewedAt?: Date | string | null
  }

  export type DocumentVerificationCreateOrConnectWithoutUserInput = {
    where: DocumentVerificationWhereUniqueInput
    create: XOR<DocumentVerificationCreateWithoutUserInput, DocumentVerificationUncheckedCreateWithoutUserInput>
  }

  export type DocumentVerificationCreateManyUserInputEnvelope = {
    data: DocumentVerificationCreateManyUserInput | DocumentVerificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OnboardingProgressCreateWithoutUserInput = {
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    application: JobApplicationCreateNestedOneWithoutOnboardingProgressInput
    hiringManager: UserCreateNestedOneWithoutManagedOnboardingsInput
    contract?: ContractCreateNestedOneWithoutOnboardingInput
  }

  export type OnboardingProgressUncheckedCreateWithoutUserInput = {
    id?: number
    applicationId: number
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    hiringManagerId: string
    contract?: ContractUncheckedCreateNestedOneWithoutOnboardingInput
  }

  export type OnboardingProgressCreateOrConnectWithoutUserInput = {
    where: OnboardingProgressWhereUniqueInput
    create: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
  }

  export type EmergencyContactCreateWithoutUserInput = {
    fullName: string
    relationship: string
    primaryPhone: string
    secondaryPhone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactUncheckedCreateWithoutUserInput = {
    id?: number
    fullName: string
    relationship: string
    primaryPhone: string
    secondaryPhone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyContactCreateOrConnectWithoutUserInput = {
    where: EmergencyContactWhereUniqueInput
    create: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput>
  }

  export type EmergencyContactCreateManyUserInputEnvelope = {
    data: EmergencyContactCreateManyUserInput | EmergencyContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DependentMemberCreateWithoutUserInput = {
    firstName: string
    lastName: string
    middleName?: string | null
    birthDate: Date | string
    relationship: string
    isStudent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentCreateNestedManyWithoutDependentMemberInput
  }

  export type DependentMemberUncheckedCreateWithoutUserInput = {
    id?: number
    firstName: string
    lastName: string
    middleName?: string | null
    birthDate: Date | string
    relationship: string
    isStudent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentUncheckedCreateNestedManyWithoutDependentMemberInput
  }

  export type DependentMemberCreateOrConnectWithoutUserInput = {
    where: DependentMemberWhereUniqueInput
    create: XOR<DependentMemberCreateWithoutUserInput, DependentMemberUncheckedCreateWithoutUserInput>
  }

  export type DependentMemberCreateManyUserInputEnvelope = {
    data: DependentMemberCreateManyUserInput | DependentMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserEmailCreateWithoutUserInput = {
    email: string
    type: $Enums.EmailType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmailUncheckedCreateWithoutUserInput = {
    id?: number
    email: string
    type: $Enums.EmailType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmailCreateOrConnectWithoutUserInput = {
    where: UserEmailWhereUniqueInput
    create: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput>
  }

  export type UserEmailCreateManyUserInputEnvelope = {
    data: UserEmailCreateManyUserInput | UserEmailCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPhoneCreateWithoutUserInput = {
    phoneNumber: string
    countryCode?: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhoneUncheckedCreateWithoutUserInput = {
    id?: number
    phoneNumber: string
    countryCode?: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhoneCreateOrConnectWithoutUserInput = {
    where: UserPhoneWhereUniqueInput
    create: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
  }

  export type UserPhoneCreateManyUserInputEnvelope = {
    data: UserPhoneCreateManyUserInput | UserPhoneCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OnboardingProgressCreateWithoutHiringManagerInput = {
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    user: UserCreateNestedOneWithoutOnboardingProgressInput
    application: JobApplicationCreateNestedOneWithoutOnboardingProgressInput
    contract?: ContractCreateNestedOneWithoutOnboardingInput
  }

  export type OnboardingProgressUncheckedCreateWithoutHiringManagerInput = {
    id?: number
    userId: string
    applicationId: number
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutOnboardingInput
  }

  export type OnboardingProgressCreateOrConnectWithoutHiringManagerInput = {
    where: OnboardingProgressWhereUniqueInput
    create: XOR<OnboardingProgressCreateWithoutHiringManagerInput, OnboardingProgressUncheckedCreateWithoutHiringManagerInput>
  }

  export type OnboardingProgressCreateManyHiringManagerInputEnvelope = {
    data: OnboardingProgressCreateManyHiringManagerInput | OnboardingProgressCreateManyHiringManagerInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutEmployeesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutEmployeesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
  }

  export type UserCreateWithoutManagerInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutManagerInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserCreateManyManagerInputEnvelope = {
    data: UserCreateManyManagerInput | UserCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type RequestCreateWithoutRequesterInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: UserCreateNestedOneWithoutRequestsToManageInput
    attachments?: RequestAttachmentCreateNestedManyWithoutRequestInput
    RequestStatusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
  }

  export type RequestUncheckedCreateWithoutRequesterInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: RequestAttachmentUncheckedCreateNestedManyWithoutRequestInput
    RequestStatusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestCreateOrConnectWithoutRequesterInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput>
  }

  export type RequestCreateManyRequesterInputEnvelope = {
    data: RequestCreateManyRequesterInput | RequestCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type RequestCreateWithoutManagerInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutRequestsMadeInput
    attachments?: RequestAttachmentCreateNestedManyWithoutRequestInput
    RequestStatusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
  }

  export type RequestUncheckedCreateWithoutManagerInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    requesterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: RequestAttachmentUncheckedCreateNestedManyWithoutRequestInput
    RequestStatusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestCreateOrConnectWithoutManagerInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutManagerInput, RequestUncheckedCreateWithoutManagerInput>
  }

  export type RequestCreateManyManagerInputEnvelope = {
    data: RequestCreateManyManagerInput | RequestCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type RequestStatusHistoryCreateWithoutUserInput = {
    status: $Enums.RequestStatus
    comment?: string | null
    createdAt?: Date | string
    request: RequestCreateNestedOneWithoutRequestStatusHistoryInput
    attachments?: StatusAttachmentCreateNestedManyWithoutHistoryInput
  }

  export type RequestStatusHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    requestId: string
    status: $Enums.RequestStatus
    comment?: string | null
    createdAt?: Date | string
    attachments?: StatusAttachmentUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type RequestStatusHistoryCreateOrConnectWithoutUserInput = {
    where: RequestStatusHistoryWhereUniqueInput
    create: XOR<RequestStatusHistoryCreateWithoutUserInput, RequestStatusHistoryUncheckedCreateWithoutUserInput>
  }

  export type RequestStatusHistoryCreateManyUserInputEnvelope = {
    data: RequestStatusHistoryCreateManyUserInput | RequestStatusHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutEmployeeInput = {
    id?: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: UserCreateNestedOneWithoutLeavesToApproveInput
    attachments?: LeaveAttachmentCreateNestedManyWithoutLeaveInput
    statusHistory?: LeaveStatusHistoryCreateNestedManyWithoutLeaveInput
  }

  export type LeaveRequestUncheckedCreateWithoutEmployeeInput = {
    id?: string
    managerId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: LeaveAttachmentUncheckedCreateNestedManyWithoutLeaveInput
    statusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutLeaveInput
  }

  export type LeaveRequestCreateOrConnectWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestCreateManyEmployeeInputEnvelope = {
    data: LeaveRequestCreateManyEmployeeInput | LeaveRequestCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutManagerInput = {
    id?: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutLeavesRequestedInput
    attachments?: LeaveAttachmentCreateNestedManyWithoutLeaveInput
    statusHistory?: LeaveStatusHistoryCreateNestedManyWithoutLeaveInput
  }

  export type LeaveRequestUncheckedCreateWithoutManagerInput = {
    id?: string
    employeeId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: LeaveAttachmentUncheckedCreateNestedManyWithoutLeaveInput
    statusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutLeaveInput
  }

  export type LeaveRequestCreateOrConnectWithoutManagerInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutManagerInput, LeaveRequestUncheckedCreateWithoutManagerInput>
  }

  export type LeaveRequestCreateManyManagerInputEnvelope = {
    data: LeaveRequestCreateManyManagerInput | LeaveRequestCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type LeaveStatusHistoryCreateWithoutChangedByInput = {
    status: $Enums.LeaveStatus
    comment?: string | null
    createdAt?: Date | string
    leave: LeaveRequestCreateNestedOneWithoutStatusHistoryInput
    attachments?: LeaveStatusAttachmentCreateNestedManyWithoutHistoryInput
  }

  export type LeaveStatusHistoryUncheckedCreateWithoutChangedByInput = {
    id?: number
    leaveId: string
    status: $Enums.LeaveStatus
    comment?: string | null
    createdAt?: Date | string
    attachments?: LeaveStatusAttachmentUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type LeaveStatusHistoryCreateOrConnectWithoutChangedByInput = {
    where: LeaveStatusHistoryWhereUniqueInput
    create: XOR<LeaveStatusHistoryCreateWithoutChangedByInput, LeaveStatusHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type LeaveStatusHistoryCreateManyChangedByInputEnvelope = {
    data: LeaveStatusHistoryCreateManyChangedByInput | LeaveStatusHistoryCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutManagerInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutManagerInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutManagerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput>
  }

  export type ProjectCreateManyManagerInputEnvelope = {
    data: ProjectCreateManyManagerInput | ProjectCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.ProjectMemberRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    role?: $Enums.ProjectMemberRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TimeEntryCreateWithoutUserInput = {
    id?: string
    description: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    status?: $Enums.TimeEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTimeEntriesInput
  }

  export type TimeEntryUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    description: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    status?: $Enums.TimeEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryCreateOrConnectWithoutUserInput = {
    where: TimeEntryWhereUniqueInput
    create: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput>
  }

  export type TimeEntryCreateManyUserInputEnvelope = {
    data: TimeEntryCreateManyUserInput | TimeEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShiftEntryCreateWithoutUserInput = {
    id?: string
    date: Date | string
    status?: $Enums.ShiftStatus
    isNightShift?: boolean
    workplaceType?: $Enums.WorkplaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    schedule: TimeScheduleCreateNestedOneWithoutShiftsInput
  }

  export type ShiftEntryUncheckedCreateWithoutUserInput = {
    id?: string
    scheduleId: string
    date: Date | string
    status?: $Enums.ShiftStatus
    isNightShift?: boolean
    workplaceType?: $Enums.WorkplaceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftEntryCreateOrConnectWithoutUserInput = {
    where: ShiftEntryWhereUniqueInput
    create: XOR<ShiftEntryCreateWithoutUserInput, ShiftEntryUncheckedCreateWithoutUserInput>
  }

  export type ShiftEntryCreateManyUserInputEnvelope = {
    data: ShiftEntryCreateManyUserInput | ShiftEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutChangedByUserInput = {
    id?: string
    title: string
    content: string
    publishedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedByUser: UserCreateNestedOneWithoutAnnouncementsPublishedInput
  }

  export type AnnouncementUncheckedCreateWithoutChangedByUserInput = {
    id?: string
    title: string
    content: string
    publishedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedBy: string
  }

  export type AnnouncementCreateOrConnectWithoutChangedByUserInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutChangedByUserInput, AnnouncementUncheckedCreateWithoutChangedByUserInput>
  }

  export type AnnouncementCreateManyChangedByUserInputEnvelope = {
    data: AnnouncementCreateManyChangedByUserInput | AnnouncementCreateManyChangedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutPublishedByUserInput = {
    id?: string
    title: string
    content: string
    publishedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    changedByUser: UserCreateNestedOneWithoutAnnouncementsChangedInput
  }

  export type AnnouncementUncheckedCreateWithoutPublishedByUserInput = {
    id?: string
    title: string
    content: string
    publishedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    changedBy: string
  }

  export type AnnouncementCreateOrConnectWithoutPublishedByUserInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutPublishedByUserInput, AnnouncementUncheckedCreateWithoutPublishedByUserInput>
  }

  export type AnnouncementCreateManyPublishedByUserInputEnvelope = {
    data: AnnouncementCreateManyPublishedByUserInput | AnnouncementCreateManyPublishedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PositionCreateWithoutUsersInput = {
    id?: string
    title: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    jobListings?: JobListingCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutUsersInput = {
    id?: string
    title: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    jobListings?: JobListingUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutUsersInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
  }

  export type LocationCreateWithoutUsersInput = {
    id?: string
    name: string
    address: string
    city: string
    region: string
    postalCode: string
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    JobListing?: JobListingCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    address: string
    city: string
    region: string
    postalCode: string
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    JobListing?: JobListingUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutUsersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput>
  }

  export type DepartmentUpsertWithoutUsersInput = {
    update: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutUsersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobListing?: JobListingUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobListing?: JobListingUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type CandidateNoteUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CandidateNoteWhereUniqueInput
    update: XOR<CandidateNoteUpdateWithoutCreatedByInput, CandidateNoteUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CandidateNoteCreateWithoutCreatedByInput, CandidateNoteUncheckedCreateWithoutCreatedByInput>
  }

  export type CandidateNoteUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CandidateNoteWhereUniqueInput
    data: XOR<CandidateNoteUpdateWithoutCreatedByInput, CandidateNoteUncheckedUpdateWithoutCreatedByInput>
  }

  export type CandidateNoteUpdateManyWithWhereWithoutCreatedByInput = {
    where: CandidateNoteScalarWhereInput
    data: XOR<CandidateNoteUpdateManyMutationInput, CandidateNoteUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CandidateNoteScalarWhereInput = {
    AND?: CandidateNoteScalarWhereInput | CandidateNoteScalarWhereInput[]
    OR?: CandidateNoteScalarWhereInput[]
    NOT?: CandidateNoteScalarWhereInput | CandidateNoteScalarWhereInput[]
    id?: IntFilter<"CandidateNote"> | number
    candidateId?: StringFilter<"CandidateNote"> | string
    content?: StringFilter<"CandidateNote"> | string
    createdAt?: DateTimeFilter<"CandidateNote"> | Date | string
    updatedAt?: DateTimeFilter<"CandidateNote"> | Date | string
    userId?: StringFilter<"CandidateNote"> | string
  }

  export type JobApplicationHistoryUpsertWithWhereUniqueWithoutChangedByInput = {
    where: JobApplicationHistoryWhereUniqueInput
    update: XOR<JobApplicationHistoryUpdateWithoutChangedByInput, JobApplicationHistoryUncheckedUpdateWithoutChangedByInput>
    create: XOR<JobApplicationHistoryCreateWithoutChangedByInput, JobApplicationHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type JobApplicationHistoryUpdateWithWhereUniqueWithoutChangedByInput = {
    where: JobApplicationHistoryWhereUniqueInput
    data: XOR<JobApplicationHistoryUpdateWithoutChangedByInput, JobApplicationHistoryUncheckedUpdateWithoutChangedByInput>
  }

  export type JobApplicationHistoryUpdateManyWithWhereWithoutChangedByInput = {
    where: JobApplicationHistoryScalarWhereInput
    data: XOR<JobApplicationHistoryUpdateManyMutationInput, JobApplicationHistoryUncheckedUpdateManyWithoutChangedByInput>
  }

  export type JobApplicationHistoryScalarWhereInput = {
    AND?: JobApplicationHistoryScalarWhereInput | JobApplicationHistoryScalarWhereInput[]
    OR?: JobApplicationHistoryScalarWhereInput[]
    NOT?: JobApplicationHistoryScalarWhereInput | JobApplicationHistoryScalarWhereInput[]
    id?: IntFilter<"JobApplicationHistory"> | number
    applicationId?: IntFilter<"JobApplicationHistory"> | number
    status?: EnumApplicationStatusFilter<"JobApplicationHistory"> | $Enums.ApplicationStatus
    comment?: StringNullableFilter<"JobApplicationHistory"> | string | null
    createdAt?: DateTimeFilter<"JobApplicationHistory"> | Date | string
    changedByUserId?: StringNullableFilter<"JobApplicationHistory"> | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserStatusHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserStatusHistoryWhereUniqueInput
    update: XOR<UserStatusHistoryUpdateWithoutUserInput, UserStatusHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserStatusHistoryCreateWithoutUserInput, UserStatusHistoryUncheckedCreateWithoutUserInput>
  }

  export type UserStatusHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserStatusHistoryWhereUniqueInput
    data: XOR<UserStatusHistoryUpdateWithoutUserInput, UserStatusHistoryUncheckedUpdateWithoutUserInput>
  }

  export type UserStatusHistoryUpdateManyWithWhereWithoutUserInput = {
    where: UserStatusHistoryScalarWhereInput
    data: XOR<UserStatusHistoryUpdateManyMutationInput, UserStatusHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserStatusHistoryScalarWhereInput = {
    AND?: UserStatusHistoryScalarWhereInput | UserStatusHistoryScalarWhereInput[]
    OR?: UserStatusHistoryScalarWhereInput[]
    NOT?: UserStatusHistoryScalarWhereInput | UserStatusHistoryScalarWhereInput[]
    id?: IntFilter<"UserStatusHistory"> | number
    userId?: StringFilter<"UserStatusHistory"> | string
    status?: EnumUserStatusFilter<"UserStatusHistory"> | $Enums.UserStatus
    comment?: StringNullableFilter<"UserStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"UserStatusHistory"> | Date | string
    changedById?: StringFilter<"UserStatusHistory"> | string
  }

  export type UserStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput = {
    where: UserStatusHistoryWhereUniqueInput
    update: XOR<UserStatusHistoryUpdateWithoutChangedByInput, UserStatusHistoryUncheckedUpdateWithoutChangedByInput>
    create: XOR<UserStatusHistoryCreateWithoutChangedByInput, UserStatusHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type UserStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput = {
    where: UserStatusHistoryWhereUniqueInput
    data: XOR<UserStatusHistoryUpdateWithoutChangedByInput, UserStatusHistoryUncheckedUpdateWithoutChangedByInput>
  }

  export type UserStatusHistoryUpdateManyWithWhereWithoutChangedByInput = {
    where: UserStatusHistoryScalarWhereInput
    data: XOR<UserStatusHistoryUpdateManyMutationInput, UserStatusHistoryUncheckedUpdateManyWithoutChangedByInput>
  }

  export type PersonalInfoUpsertWithoutUserInput = {
    update: XOR<PersonalInfoUpdateWithoutUserInput, PersonalInfoUncheckedUpdateWithoutUserInput>
    create: XOR<PersonalInfoCreateWithoutUserInput, PersonalInfoUncheckedCreateWithoutUserInput>
    where?: PersonalInfoWhereInput
  }

  export type PersonalInfoUpdateToOneWithWhereWithoutUserInput = {
    where?: PersonalInfoWhereInput
    data: XOR<PersonalInfoUpdateWithoutUserInput, PersonalInfoUncheckedUpdateWithoutUserInput>
  }

  export type PersonalInfoUpdateWithoutUserInput = {
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    identificationDocuments?: IdentificationDocumentUpdateManyWithoutPersonalInfoNestedInput
    addresses?: AddressUpdateManyWithoutPersonalInfoNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutPersonalInfoNestedInput
    languageSkills?: LanguageSkillUpdateManyWithoutPersonalInfoNestedInput
  }

  export type PersonalInfoUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    identificationDocuments?: IdentificationDocumentUncheckedUpdateManyWithoutPersonalInfoNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonalInfoNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutPersonalInfoNestedInput
    languageSkills?: LanguageSkillUncheckedUpdateManyWithoutPersonalInfoNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: IntFilter<"Document"> | number
    userId?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    key?: StringFilter<"Document"> | string
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    dependentMemberId?: IntNullableFilter<"Document"> | number | null
    languageSkillId?: IntNullableFilter<"Document"> | number | null
  }

  export type DocumentVerificationUpsertWithWhereUniqueWithoutReviewedByInput = {
    where: DocumentVerificationWhereUniqueInput
    update: XOR<DocumentVerificationUpdateWithoutReviewedByInput, DocumentVerificationUncheckedUpdateWithoutReviewedByInput>
    create: XOR<DocumentVerificationCreateWithoutReviewedByInput, DocumentVerificationUncheckedCreateWithoutReviewedByInput>
  }

  export type DocumentVerificationUpdateWithWhereUniqueWithoutReviewedByInput = {
    where: DocumentVerificationWhereUniqueInput
    data: XOR<DocumentVerificationUpdateWithoutReviewedByInput, DocumentVerificationUncheckedUpdateWithoutReviewedByInput>
  }

  export type DocumentVerificationUpdateManyWithWhereWithoutReviewedByInput = {
    where: DocumentVerificationScalarWhereInput
    data: XOR<DocumentVerificationUpdateManyMutationInput, DocumentVerificationUncheckedUpdateManyWithoutReviewedByInput>
  }

  export type DocumentVerificationScalarWhereInput = {
    AND?: DocumentVerificationScalarWhereInput | DocumentVerificationScalarWhereInput[]
    OR?: DocumentVerificationScalarWhereInput[]
    NOT?: DocumentVerificationScalarWhereInput | DocumentVerificationScalarWhereInput[]
    id?: IntFilter<"DocumentVerification"> | number
    documentId?: IntFilter<"DocumentVerification"> | number
    status?: EnumVerificationStatusFilter<"DocumentVerification"> | $Enums.VerificationStatus
    reviewedById?: StringFilter<"DocumentVerification"> | string
    comments?: StringNullableFilter<"DocumentVerification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"DocumentVerification"> | Date | string | null
    userId?: StringNullableFilter<"DocumentVerification"> | string | null
  }

  export type DocumentVerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentVerificationWhereUniqueInput
    update: XOR<DocumentVerificationUpdateWithoutUserInput, DocumentVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentVerificationCreateWithoutUserInput, DocumentVerificationUncheckedCreateWithoutUserInput>
  }

  export type DocumentVerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentVerificationWhereUniqueInput
    data: XOR<DocumentVerificationUpdateWithoutUserInput, DocumentVerificationUncheckedUpdateWithoutUserInput>
  }

  export type DocumentVerificationUpdateManyWithWhereWithoutUserInput = {
    where: DocumentVerificationScalarWhereInput
    data: XOR<DocumentVerificationUpdateManyMutationInput, DocumentVerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type OnboardingProgressUpsertWithoutUserInput = {
    update: XOR<OnboardingProgressUpdateWithoutUserInput, OnboardingProgressUncheckedUpdateWithoutUserInput>
    create: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    where?: OnboardingProgressWhereInput
  }

  export type OnboardingProgressUpdateToOneWithWhereWithoutUserInput = {
    where?: OnboardingProgressWhereInput
    data: XOR<OnboardingProgressUpdateWithoutUserInput, OnboardingProgressUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingProgressUpdateWithoutUserInput = {
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: JobApplicationUpdateOneRequiredWithoutOnboardingProgressNestedInput
    hiringManager?: UserUpdateOneRequiredWithoutManagedOnboardingsNestedInput
    contract?: ContractUpdateOneWithoutOnboardingNestedInput
  }

  export type OnboardingProgressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicationId?: IntFieldUpdateOperationsInput | number
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hiringManagerId?: StringFieldUpdateOperationsInput | string
    contract?: ContractUncheckedUpdateOneWithoutOnboardingNestedInput
  }

  export type EmergencyContactUpsertWithWhereUniqueWithoutUserInput = {
    where: EmergencyContactWhereUniqueInput
    update: XOR<EmergencyContactUpdateWithoutUserInput, EmergencyContactUncheckedUpdateWithoutUserInput>
    create: XOR<EmergencyContactCreateWithoutUserInput, EmergencyContactUncheckedCreateWithoutUserInput>
  }

  export type EmergencyContactUpdateWithWhereUniqueWithoutUserInput = {
    where: EmergencyContactWhereUniqueInput
    data: XOR<EmergencyContactUpdateWithoutUserInput, EmergencyContactUncheckedUpdateWithoutUserInput>
  }

  export type EmergencyContactUpdateManyWithWhereWithoutUserInput = {
    where: EmergencyContactScalarWhereInput
    data: XOR<EmergencyContactUpdateManyMutationInput, EmergencyContactUncheckedUpdateManyWithoutUserInput>
  }

  export type EmergencyContactScalarWhereInput = {
    AND?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
    OR?: EmergencyContactScalarWhereInput[]
    NOT?: EmergencyContactScalarWhereInput | EmergencyContactScalarWhereInput[]
    id?: IntFilter<"EmergencyContact"> | number
    userId?: StringFilter<"EmergencyContact"> | string
    fullName?: StringFilter<"EmergencyContact"> | string
    relationship?: StringFilter<"EmergencyContact"> | string
    primaryPhone?: StringFilter<"EmergencyContact"> | string
    secondaryPhone?: StringNullableFilter<"EmergencyContact"> | string | null
    email?: StringNullableFilter<"EmergencyContact"> | string | null
    createdAt?: DateTimeFilter<"EmergencyContact"> | Date | string
    updatedAt?: DateTimeFilter<"EmergencyContact"> | Date | string
  }

  export type DependentMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: DependentMemberWhereUniqueInput
    update: XOR<DependentMemberUpdateWithoutUserInput, DependentMemberUncheckedUpdateWithoutUserInput>
    create: XOR<DependentMemberCreateWithoutUserInput, DependentMemberUncheckedCreateWithoutUserInput>
  }

  export type DependentMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: DependentMemberWhereUniqueInput
    data: XOR<DependentMemberUpdateWithoutUserInput, DependentMemberUncheckedUpdateWithoutUserInput>
  }

  export type DependentMemberUpdateManyWithWhereWithoutUserInput = {
    where: DependentMemberScalarWhereInput
    data: XOR<DependentMemberUpdateManyMutationInput, DependentMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type DependentMemberScalarWhereInput = {
    AND?: DependentMemberScalarWhereInput | DependentMemberScalarWhereInput[]
    OR?: DependentMemberScalarWhereInput[]
    NOT?: DependentMemberScalarWhereInput | DependentMemberScalarWhereInput[]
    id?: IntFilter<"DependentMember"> | number
    userId?: StringFilter<"DependentMember"> | string
    firstName?: StringFilter<"DependentMember"> | string
    lastName?: StringFilter<"DependentMember"> | string
    middleName?: StringNullableFilter<"DependentMember"> | string | null
    birthDate?: DateTimeFilter<"DependentMember"> | Date | string
    relationship?: StringFilter<"DependentMember"> | string
    isStudent?: BoolFilter<"DependentMember"> | boolean
    createdAt?: DateTimeFilter<"DependentMember"> | Date | string
    updatedAt?: DateTimeFilter<"DependentMember"> | Date | string
  }

  export type UserEmailUpsertWithWhereUniqueWithoutUserInput = {
    where: UserEmailWhereUniqueInput
    update: XOR<UserEmailUpdateWithoutUserInput, UserEmailUncheckedUpdateWithoutUserInput>
    create: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput>
  }

  export type UserEmailUpdateWithWhereUniqueWithoutUserInput = {
    where: UserEmailWhereUniqueInput
    data: XOR<UserEmailUpdateWithoutUserInput, UserEmailUncheckedUpdateWithoutUserInput>
  }

  export type UserEmailUpdateManyWithWhereWithoutUserInput = {
    where: UserEmailScalarWhereInput
    data: XOR<UserEmailUpdateManyMutationInput, UserEmailUncheckedUpdateManyWithoutUserInput>
  }

  export type UserEmailScalarWhereInput = {
    AND?: UserEmailScalarWhereInput | UserEmailScalarWhereInput[]
    OR?: UserEmailScalarWhereInput[]
    NOT?: UserEmailScalarWhereInput | UserEmailScalarWhereInput[]
    id?: IntFilter<"UserEmail"> | number
    userId?: StringFilter<"UserEmail"> | string
    email?: StringFilter<"UserEmail"> | string
    type?: EnumEmailTypeFilter<"UserEmail"> | $Enums.EmailType
    isPrimary?: BoolFilter<"UserEmail"> | boolean
    createdAt?: DateTimeFilter<"UserEmail"> | Date | string
    updatedAt?: DateTimeFilter<"UserEmail"> | Date | string
  }

  export type UserPhoneUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPhoneWhereUniqueInput
    update: XOR<UserPhoneUpdateWithoutUserInput, UserPhoneUncheckedUpdateWithoutUserInput>
    create: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
  }

  export type UserPhoneUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPhoneWhereUniqueInput
    data: XOR<UserPhoneUpdateWithoutUserInput, UserPhoneUncheckedUpdateWithoutUserInput>
  }

  export type UserPhoneUpdateManyWithWhereWithoutUserInput = {
    where: UserPhoneScalarWhereInput
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPhoneScalarWhereInput = {
    AND?: UserPhoneScalarWhereInput | UserPhoneScalarWhereInput[]
    OR?: UserPhoneScalarWhereInput[]
    NOT?: UserPhoneScalarWhereInput | UserPhoneScalarWhereInput[]
    id?: IntFilter<"UserPhone"> | number
    userId?: StringFilter<"UserPhone"> | string
    phoneNumber?: StringFilter<"UserPhone"> | string
    countryCode?: StringFilter<"UserPhone"> | string
    type?: EnumPhoneTypeFilter<"UserPhone"> | $Enums.PhoneType
    isPrimary?: BoolFilter<"UserPhone"> | boolean
    createdAt?: DateTimeFilter<"UserPhone"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhone"> | Date | string
  }

  export type OnboardingProgressUpsertWithWhereUniqueWithoutHiringManagerInput = {
    where: OnboardingProgressWhereUniqueInput
    update: XOR<OnboardingProgressUpdateWithoutHiringManagerInput, OnboardingProgressUncheckedUpdateWithoutHiringManagerInput>
    create: XOR<OnboardingProgressCreateWithoutHiringManagerInput, OnboardingProgressUncheckedCreateWithoutHiringManagerInput>
  }

  export type OnboardingProgressUpdateWithWhereUniqueWithoutHiringManagerInput = {
    where: OnboardingProgressWhereUniqueInput
    data: XOR<OnboardingProgressUpdateWithoutHiringManagerInput, OnboardingProgressUncheckedUpdateWithoutHiringManagerInput>
  }

  export type OnboardingProgressUpdateManyWithWhereWithoutHiringManagerInput = {
    where: OnboardingProgressScalarWhereInput
    data: XOR<OnboardingProgressUpdateManyMutationInput, OnboardingProgressUncheckedUpdateManyWithoutHiringManagerInput>
  }

  export type OnboardingProgressScalarWhereInput = {
    AND?: OnboardingProgressScalarWhereInput | OnboardingProgressScalarWhereInput[]
    OR?: OnboardingProgressScalarWhereInput[]
    NOT?: OnboardingProgressScalarWhereInput | OnboardingProgressScalarWhereInput[]
    id?: IntFilter<"OnboardingProgress"> | number
    userId?: StringFilter<"OnboardingProgress"> | string
    applicationId?: IntFilter<"OnboardingProgress"> | number
    currentPhase?: EnumPhaseFilter<"OnboardingProgress"> | $Enums.Phase
    startedAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"OnboardingProgress"> | Date | string | null
    status?: EnumOnboardingStatusFilter<"OnboardingProgress"> | $Enums.OnboardingStatus
    hireDate?: DateTimeFilter<"OnboardingProgress"> | Date | string
    hiringManagerId?: StringFilter<"OnboardingProgress"> | string
  }

  export type UserUpsertWithoutEmployeesInput = {
    update: XOR<UserUpdateWithoutEmployeesInput, UserUncheckedUpdateWithoutEmployeesInput>
    create: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeesInput, UserUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
  }

  export type UserUpdateManyWithWhereWithoutManagerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutManagerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFilter<"User"> | $Enums.EmploymentType
    jobStartDate?: DateTimeNullableFilter<"User"> | Date | string | null
    jobEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    managerId?: StringNullableFilter<"User"> | string | null
    positionId?: StringNullableFilter<"User"> | string | null
    locationId?: StringNullableFilter<"User"> | string | null
  }

  export type RequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: RequestWhereUniqueInput
    update: XOR<RequestUpdateWithoutRequesterInput, RequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput>
  }

  export type RequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: RequestWhereUniqueInput
    data: XOR<RequestUpdateWithoutRequesterInput, RequestUncheckedUpdateWithoutRequesterInput>
  }

  export type RequestUpdateManyWithWhereWithoutRequesterInput = {
    where: RequestScalarWhereInput
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyWithoutRequesterInput>
  }

  export type RequestScalarWhereInput = {
    AND?: RequestScalarWhereInput | RequestScalarWhereInput[]
    OR?: RequestScalarWhereInput[]
    NOT?: RequestScalarWhereInput | RequestScalarWhereInput[]
    id?: StringFilter<"Request"> | string
    title?: StringFilter<"Request"> | string
    description?: StringFilter<"Request"> | string
    status?: EnumRequestStatusFilter<"Request"> | $Enums.RequestStatus
    requesterId?: StringFilter<"Request"> | string
    managerId?: StringFilter<"Request"> | string
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
  }

  export type RequestUpsertWithWhereUniqueWithoutManagerInput = {
    where: RequestWhereUniqueInput
    update: XOR<RequestUpdateWithoutManagerInput, RequestUncheckedUpdateWithoutManagerInput>
    create: XOR<RequestCreateWithoutManagerInput, RequestUncheckedCreateWithoutManagerInput>
  }

  export type RequestUpdateWithWhereUniqueWithoutManagerInput = {
    where: RequestWhereUniqueInput
    data: XOR<RequestUpdateWithoutManagerInput, RequestUncheckedUpdateWithoutManagerInput>
  }

  export type RequestUpdateManyWithWhereWithoutManagerInput = {
    where: RequestScalarWhereInput
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyWithoutManagerInput>
  }

  export type RequestStatusHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: RequestStatusHistoryWhereUniqueInput
    update: XOR<RequestStatusHistoryUpdateWithoutUserInput, RequestStatusHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<RequestStatusHistoryCreateWithoutUserInput, RequestStatusHistoryUncheckedCreateWithoutUserInput>
  }

  export type RequestStatusHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: RequestStatusHistoryWhereUniqueInput
    data: XOR<RequestStatusHistoryUpdateWithoutUserInput, RequestStatusHistoryUncheckedUpdateWithoutUserInput>
  }

  export type RequestStatusHistoryUpdateManyWithWhereWithoutUserInput = {
    where: RequestStatusHistoryScalarWhereInput
    data: XOR<RequestStatusHistoryUpdateManyMutationInput, RequestStatusHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type RequestStatusHistoryScalarWhereInput = {
    AND?: RequestStatusHistoryScalarWhereInput | RequestStatusHistoryScalarWhereInput[]
    OR?: RequestStatusHistoryScalarWhereInput[]
    NOT?: RequestStatusHistoryScalarWhereInput | RequestStatusHistoryScalarWhereInput[]
    id?: IntFilter<"RequestStatusHistory"> | number
    requestId?: StringFilter<"RequestStatusHistory"> | string
    status?: EnumRequestStatusFilter<"RequestStatusHistory"> | $Enums.RequestStatus
    comment?: StringNullableFilter<"RequestStatusHistory"> | string | null
    changedBy?: StringFilter<"RequestStatusHistory"> | string
    createdAt?: DateTimeFilter<"RequestStatusHistory"> | Date | string
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveRequestScalarWhereInput = {
    AND?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    OR?: LeaveRequestScalarWhereInput[]
    NOT?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    managerId?: StringFilter<"LeaveRequest"> | string
    type?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    duration?: FloatFilter<"LeaveRequest"> | number
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutManagerInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutManagerInput, LeaveRequestUncheckedUpdateWithoutManagerInput>
    create: XOR<LeaveRequestCreateWithoutManagerInput, LeaveRequestUncheckedCreateWithoutManagerInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutManagerInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutManagerInput, LeaveRequestUncheckedUpdateWithoutManagerInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutManagerInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutManagerInput>
  }

  export type LeaveStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput = {
    where: LeaveStatusHistoryWhereUniqueInput
    update: XOR<LeaveStatusHistoryUpdateWithoutChangedByInput, LeaveStatusHistoryUncheckedUpdateWithoutChangedByInput>
    create: XOR<LeaveStatusHistoryCreateWithoutChangedByInput, LeaveStatusHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type LeaveStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput = {
    where: LeaveStatusHistoryWhereUniqueInput
    data: XOR<LeaveStatusHistoryUpdateWithoutChangedByInput, LeaveStatusHistoryUncheckedUpdateWithoutChangedByInput>
  }

  export type LeaveStatusHistoryUpdateManyWithWhereWithoutChangedByInput = {
    where: LeaveStatusHistoryScalarWhereInput
    data: XOR<LeaveStatusHistoryUpdateManyMutationInput, LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByInput>
  }

  export type LeaveStatusHistoryScalarWhereInput = {
    AND?: LeaveStatusHistoryScalarWhereInput | LeaveStatusHistoryScalarWhereInput[]
    OR?: LeaveStatusHistoryScalarWhereInput[]
    NOT?: LeaveStatusHistoryScalarWhereInput | LeaveStatusHistoryScalarWhereInput[]
    id?: IntFilter<"LeaveStatusHistory"> | number
    leaveId?: StringFilter<"LeaveStatusHistory"> | string
    status?: EnumLeaveStatusFilter<"LeaveStatusHistory"> | $Enums.LeaveStatus
    comment?: StringNullableFilter<"LeaveStatusHistory"> | string | null
    changedById?: StringFilter<"LeaveStatusHistory"> | string
    createdAt?: DateTimeFilter<"LeaveStatusHistory"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutManagerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutManagerInput, ProjectUncheckedUpdateWithoutManagerInput>
    create: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutManagerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutManagerInput, ProjectUncheckedUpdateWithoutManagerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutManagerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutManagerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    clientId?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    managerId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectMemberRoleFilter<"ProjectMember"> | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    leftAt?: DateTimeNullableFilter<"ProjectMember"> | Date | string | null
  }

  export type TimeEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: TimeEntryWhereUniqueInput
    update: XOR<TimeEntryUpdateWithoutUserInput, TimeEntryUncheckedUpdateWithoutUserInput>
    create: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput>
  }

  export type TimeEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: TimeEntryWhereUniqueInput
    data: XOR<TimeEntryUpdateWithoutUserInput, TimeEntryUncheckedUpdateWithoutUserInput>
  }

  export type TimeEntryUpdateManyWithWhereWithoutUserInput = {
    where: TimeEntryScalarWhereInput
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type TimeEntryScalarWhereInput = {
    AND?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
    OR?: TimeEntryScalarWhereInput[]
    NOT?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
    id?: StringFilter<"TimeEntry"> | string
    projectId?: StringFilter<"TimeEntry"> | string
    userId?: StringFilter<"TimeEntry"> | string
    description?: StringFilter<"TimeEntry"> | string
    startTime?: DateTimeFilter<"TimeEntry"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    duration?: IntFilter<"TimeEntry"> | number
    status?: EnumTimeEntryStatusFilter<"TimeEntry"> | $Enums.TimeEntryStatus
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
  }

  export type ShiftEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: ShiftEntryWhereUniqueInput
    update: XOR<ShiftEntryUpdateWithoutUserInput, ShiftEntryUncheckedUpdateWithoutUserInput>
    create: XOR<ShiftEntryCreateWithoutUserInput, ShiftEntryUncheckedCreateWithoutUserInput>
  }

  export type ShiftEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: ShiftEntryWhereUniqueInput
    data: XOR<ShiftEntryUpdateWithoutUserInput, ShiftEntryUncheckedUpdateWithoutUserInput>
  }

  export type ShiftEntryUpdateManyWithWhereWithoutUserInput = {
    where: ShiftEntryScalarWhereInput
    data: XOR<ShiftEntryUpdateManyMutationInput, ShiftEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type ShiftEntryScalarWhereInput = {
    AND?: ShiftEntryScalarWhereInput | ShiftEntryScalarWhereInput[]
    OR?: ShiftEntryScalarWhereInput[]
    NOT?: ShiftEntryScalarWhereInput | ShiftEntryScalarWhereInput[]
    id?: StringFilter<"ShiftEntry"> | string
    userId?: StringFilter<"ShiftEntry"> | string
    scheduleId?: StringFilter<"ShiftEntry"> | string
    date?: DateTimeFilter<"ShiftEntry"> | Date | string
    status?: EnumShiftStatusFilter<"ShiftEntry"> | $Enums.ShiftStatus
    isNightShift?: BoolFilter<"ShiftEntry"> | boolean
    workplaceType?: EnumWorkplaceTypeFilter<"ShiftEntry"> | $Enums.WorkplaceType
    createdAt?: DateTimeFilter<"ShiftEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftEntry"> | Date | string
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutChangedByUserInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutChangedByUserInput, AnnouncementUncheckedUpdateWithoutChangedByUserInput>
    create: XOR<AnnouncementCreateWithoutChangedByUserInput, AnnouncementUncheckedCreateWithoutChangedByUserInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutChangedByUserInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutChangedByUserInput, AnnouncementUncheckedUpdateWithoutChangedByUserInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutChangedByUserInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutChangedByUserInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    publishedAt?: DateTimeFilter<"Announcement"> | Date | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    changedBy?: StringFilter<"Announcement"> | string
    publishedBy?: StringFilter<"Announcement"> | string
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutPublishedByUserInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutPublishedByUserInput, AnnouncementUncheckedUpdateWithoutPublishedByUserInput>
    create: XOR<AnnouncementCreateWithoutPublishedByUserInput, AnnouncementUncheckedCreateWithoutPublishedByUserInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutPublishedByUserInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutPublishedByUserInput, AnnouncementUncheckedUpdateWithoutPublishedByUserInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutPublishedByUserInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutPublishedByUserInput>
  }

  export type PositionUpsertWithoutUsersInput = {
    update: XOR<PositionUpdateWithoutUsersInput, PositionUncheckedUpdateWithoutUsersInput>
    create: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutUsersInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutUsersInput, PositionUncheckedUpdateWithoutUsersInput>
  }

  export type PositionUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobListings?: JobListingUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobListings?: JobListingUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type LocationUpsertWithoutUsersInput = {
    update: XOR<LocationUpdateWithoutUsersInput, LocationUncheckedUpdateWithoutUsersInput>
    create: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutUsersInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutUsersInput, LocationUncheckedUpdateWithoutUsersInput>
  }

  export type LocationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobListing?: JobListingUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobListing?: JobListingUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type UserCreateWithoutStatusHistoryInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutStatusHistoryInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutStatusHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatusHistoryInput, UserUncheckedCreateWithoutStatusHistoryInput>
  }

  export type UserCreateWithoutStatusChangesByInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutStatusChangesByInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutStatusChangesByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatusChangesByInput, UserUncheckedCreateWithoutStatusChangesByInput>
  }

  export type UserUpsertWithoutStatusHistoryInput = {
    update: XOR<UserUpdateWithoutStatusHistoryInput, UserUncheckedUpdateWithoutStatusHistoryInput>
    create: XOR<UserCreateWithoutStatusHistoryInput, UserUncheckedCreateWithoutStatusHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatusHistoryInput, UserUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type UserUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserUpsertWithoutStatusChangesByInput = {
    update: XOR<UserUpdateWithoutStatusChangesByInput, UserUncheckedUpdateWithoutStatusChangesByInput>
    create: XOR<UserCreateWithoutStatusChangesByInput, UserUncheckedCreateWithoutStatusChangesByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatusChangesByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatusChangesByInput, UserUncheckedUpdateWithoutStatusChangesByInput>
  }

  export type UserUpdateWithoutStatusChangesByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutStatusChangesByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type CandidateCreateWithoutNotesInput = {
    id?: string
    name: string
    surname: string
    email: string
    phone: string
    linkedin?: string | null
    github?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: JobApplicationCreateNestedManyWithoutCandidateInput
  }

  export type CandidateUncheckedCreateWithoutNotesInput = {
    id?: string
    name: string
    surname: string
    email: string
    phone: string
    linkedin?: string | null
    github?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: JobApplicationUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type CandidateCreateOrConnectWithoutNotesInput = {
    where: CandidateWhereUniqueInput
    create: XOR<CandidateCreateWithoutNotesInput, CandidateUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutCandidateNotesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCandidateNotesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutCandidateNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCandidateNotesInput, UserUncheckedCreateWithoutCandidateNotesInput>
  }

  export type CandidateUpsertWithoutNotesInput = {
    update: XOR<CandidateUpdateWithoutNotesInput, CandidateUncheckedUpdateWithoutNotesInput>
    create: XOR<CandidateCreateWithoutNotesInput, CandidateUncheckedCreateWithoutNotesInput>
    where?: CandidateWhereInput
  }

  export type CandidateUpdateToOneWithWhereWithoutNotesInput = {
    where?: CandidateWhereInput
    data: XOR<CandidateUpdateWithoutNotesInput, CandidateUncheckedUpdateWithoutNotesInput>
  }

  export type CandidateUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: JobApplicationUpdateManyWithoutCandidateNestedInput
  }

  export type CandidateUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: JobApplicationUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type UserUpsertWithoutCandidateNotesInput = {
    update: XOR<UserUpdateWithoutCandidateNotesInput, UserUncheckedUpdateWithoutCandidateNotesInput>
    create: XOR<UserCreateWithoutCandidateNotesInput, UserUncheckedCreateWithoutCandidateNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCandidateNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCandidateNotesInput, UserUncheckedUpdateWithoutCandidateNotesInput>
  }

  export type UserUpdateWithoutCandidateNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCandidateNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type DepartmentCreateWithoutJobListingInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutJobListingInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutJobListingInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutJobListingInput, DepartmentUncheckedCreateWithoutJobListingInput>
  }

  export type LocationCreateWithoutJobListingInput = {
    id?: string
    name: string
    address: string
    city: string
    region: string
    postalCode: string
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutJobListingInput = {
    id?: string
    name: string
    address: string
    city: string
    region: string
    postalCode: string
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutJobListingInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutJobListingInput, LocationUncheckedCreateWithoutJobListingInput>
  }

  export type JobApplicationCreateWithoutJobListingInput = {
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    candidate: CandidateCreateNestedOneWithoutApplicationsInput
    history?: JobApplicationHistoryCreateNestedManyWithoutApplicationInput
    cvAnalysis?: CvAnalysisCreateNestedOneWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutJobListingInput = {
    id?: number
    candidateId: string
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    history?: JobApplicationHistoryUncheckedCreateNestedManyWithoutApplicationInput
    cvAnalysis?: CvAnalysisUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutJobListingInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutJobListingInput, JobApplicationUncheckedCreateWithoutJobListingInput>
  }

  export type JobApplicationCreateManyJobListingInputEnvelope = {
    data: JobApplicationCreateManyJobListingInput | JobApplicationCreateManyJobListingInput[]
    skipDuplicates?: boolean
  }

  export type PositionCreateWithoutJobListingsInput = {
    id?: string
    title: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutJobListingsInput = {
    id?: string
    title: string
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutJobListingsInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutJobListingsInput, PositionUncheckedCreateWithoutJobListingsInput>
  }

  export type DepartmentUpsertWithoutJobListingInput = {
    update: XOR<DepartmentUpdateWithoutJobListingInput, DepartmentUncheckedUpdateWithoutJobListingInput>
    create: XOR<DepartmentCreateWithoutJobListingInput, DepartmentUncheckedCreateWithoutJobListingInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutJobListingInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutJobListingInput, DepartmentUncheckedUpdateWithoutJobListingInput>
  }

  export type DepartmentUpdateWithoutJobListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutJobListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type LocationUpsertWithoutJobListingInput = {
    update: XOR<LocationUpdateWithoutJobListingInput, LocationUncheckedUpdateWithoutJobListingInput>
    create: XOR<LocationCreateWithoutJobListingInput, LocationUncheckedCreateWithoutJobListingInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutJobListingInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutJobListingInput, LocationUncheckedUpdateWithoutJobListingInput>
  }

  export type LocationUpdateWithoutJobListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutJobListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type JobApplicationUpsertWithWhereUniqueWithoutJobListingInput = {
    where: JobApplicationWhereUniqueInput
    update: XOR<JobApplicationUpdateWithoutJobListingInput, JobApplicationUncheckedUpdateWithoutJobListingInput>
    create: XOR<JobApplicationCreateWithoutJobListingInput, JobApplicationUncheckedCreateWithoutJobListingInput>
  }

  export type JobApplicationUpdateWithWhereUniqueWithoutJobListingInput = {
    where: JobApplicationWhereUniqueInput
    data: XOR<JobApplicationUpdateWithoutJobListingInput, JobApplicationUncheckedUpdateWithoutJobListingInput>
  }

  export type JobApplicationUpdateManyWithWhereWithoutJobListingInput = {
    where: JobApplicationScalarWhereInput
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyWithoutJobListingInput>
  }

  export type JobApplicationScalarWhereInput = {
    AND?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
    OR?: JobApplicationScalarWhereInput[]
    NOT?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
    id?: IntFilter<"JobApplication"> | number
    candidateId?: StringFilter<"JobApplication"> | string
    resumeKey?: StringNullableFilter<"JobApplication"> | string | null
    additionalNotes?: StringNullableFilter<"JobApplication"> | string | null
    referralSource?: StringNullableFilter<"JobApplication"> | string | null
    status?: EnumApplicationStatusFilter<"JobApplication"> | $Enums.ApplicationStatus
    jobListingId?: IntFilter<"JobApplication"> | number
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
  }

  export type PositionUpsertWithoutJobListingsInput = {
    update: XOR<PositionUpdateWithoutJobListingsInput, PositionUncheckedUpdateWithoutJobListingsInput>
    create: XOR<PositionCreateWithoutJobListingsInput, PositionUncheckedCreateWithoutJobListingsInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutJobListingsInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutJobListingsInput, PositionUncheckedUpdateWithoutJobListingsInput>
  }

  export type PositionUpdateWithoutJobListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutJobListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type JobApplicationCreateWithoutCandidateInput = {
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    jobListing: JobListingCreateNestedOneWithoutApplicationsInput
    history?: JobApplicationHistoryCreateNestedManyWithoutApplicationInput
    cvAnalysis?: CvAnalysisCreateNestedOneWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutCandidateInput = {
    id?: number
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    jobListingId: number
    createdAt?: Date | string
    history?: JobApplicationHistoryUncheckedCreateNestedManyWithoutApplicationInput
    cvAnalysis?: CvAnalysisUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutCandidateInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutCandidateInput, JobApplicationUncheckedCreateWithoutCandidateInput>
  }

  export type JobApplicationCreateManyCandidateInputEnvelope = {
    data: JobApplicationCreateManyCandidateInput | JobApplicationCreateManyCandidateInput[]
    skipDuplicates?: boolean
  }

  export type CandidateNoteCreateWithoutCandidateInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCandidateNotesInput
  }

  export type CandidateNoteUncheckedCreateWithoutCandidateInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type CandidateNoteCreateOrConnectWithoutCandidateInput = {
    where: CandidateNoteWhereUniqueInput
    create: XOR<CandidateNoteCreateWithoutCandidateInput, CandidateNoteUncheckedCreateWithoutCandidateInput>
  }

  export type CandidateNoteCreateManyCandidateInputEnvelope = {
    data: CandidateNoteCreateManyCandidateInput | CandidateNoteCreateManyCandidateInput[]
    skipDuplicates?: boolean
  }

  export type JobApplicationUpsertWithWhereUniqueWithoutCandidateInput = {
    where: JobApplicationWhereUniqueInput
    update: XOR<JobApplicationUpdateWithoutCandidateInput, JobApplicationUncheckedUpdateWithoutCandidateInput>
    create: XOR<JobApplicationCreateWithoutCandidateInput, JobApplicationUncheckedCreateWithoutCandidateInput>
  }

  export type JobApplicationUpdateWithWhereUniqueWithoutCandidateInput = {
    where: JobApplicationWhereUniqueInput
    data: XOR<JobApplicationUpdateWithoutCandidateInput, JobApplicationUncheckedUpdateWithoutCandidateInput>
  }

  export type JobApplicationUpdateManyWithWhereWithoutCandidateInput = {
    where: JobApplicationScalarWhereInput
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyWithoutCandidateInput>
  }

  export type CandidateNoteUpsertWithWhereUniqueWithoutCandidateInput = {
    where: CandidateNoteWhereUniqueInput
    update: XOR<CandidateNoteUpdateWithoutCandidateInput, CandidateNoteUncheckedUpdateWithoutCandidateInput>
    create: XOR<CandidateNoteCreateWithoutCandidateInput, CandidateNoteUncheckedCreateWithoutCandidateInput>
  }

  export type CandidateNoteUpdateWithWhereUniqueWithoutCandidateInput = {
    where: CandidateNoteWhereUniqueInput
    data: XOR<CandidateNoteUpdateWithoutCandidateInput, CandidateNoteUncheckedUpdateWithoutCandidateInput>
  }

  export type CandidateNoteUpdateManyWithWhereWithoutCandidateInput = {
    where: CandidateNoteScalarWhereInput
    data: XOR<CandidateNoteUpdateManyMutationInput, CandidateNoteUncheckedUpdateManyWithoutCandidateInput>
  }

  export type CandidateCreateWithoutApplicationsInput = {
    id?: string
    name: string
    surname: string
    email: string
    phone: string
    linkedin?: string | null
    github?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: CandidateNoteCreateNestedManyWithoutCandidateInput
  }

  export type CandidateUncheckedCreateWithoutApplicationsInput = {
    id?: string
    name: string
    surname: string
    email: string
    phone: string
    linkedin?: string | null
    github?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: CandidateNoteUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type CandidateCreateOrConnectWithoutApplicationsInput = {
    where: CandidateWhereUniqueInput
    create: XOR<CandidateCreateWithoutApplicationsInput, CandidateUncheckedCreateWithoutApplicationsInput>
  }

  export type JobListingCreateWithoutApplicationsInput = {
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutJobListingInput
    location?: LocationCreateNestedOneWithoutJobListingInput
    position?: PositionCreateNestedOneWithoutJobListingsInput
  }

  export type JobListingUncheckedCreateWithoutApplicationsInput = {
    id?: number
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    departmentId?: string | null
    locationId?: string | null
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
  }

  export type JobListingCreateOrConnectWithoutApplicationsInput = {
    where: JobListingWhereUniqueInput
    create: XOR<JobListingCreateWithoutApplicationsInput, JobListingUncheckedCreateWithoutApplicationsInput>
  }

  export type JobApplicationHistoryCreateWithoutApplicationInput = {
    status: $Enums.ApplicationStatus
    comment?: string | null
    createdAt?: Date | string
    changedBy?: UserCreateNestedOneWithoutJobApplicationHistoryInput
  }

  export type JobApplicationHistoryUncheckedCreateWithoutApplicationInput = {
    id?: number
    status: $Enums.ApplicationStatus
    comment?: string | null
    createdAt?: Date | string
    changedByUserId?: string | null
  }

  export type JobApplicationHistoryCreateOrConnectWithoutApplicationInput = {
    where: JobApplicationHistoryWhereUniqueInput
    create: XOR<JobApplicationHistoryCreateWithoutApplicationInput, JobApplicationHistoryUncheckedCreateWithoutApplicationInput>
  }

  export type JobApplicationHistoryCreateManyApplicationInputEnvelope = {
    data: JobApplicationHistoryCreateManyApplicationInput | JobApplicationHistoryCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type CvAnalysisCreateWithoutApplicationInput = {
    totalScore?: number | null
    technicalScore?: number | null
    experienceScore?: number | null
    educationScore?: number | null
    cvQualityScore?: number | null
    softSkillsScore?: number | null
    analysis?: string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CvAnalysisUncheckedCreateWithoutApplicationInput = {
    id?: number
    totalScore?: number | null
    technicalScore?: number | null
    experienceScore?: number | null
    educationScore?: number | null
    cvQualityScore?: number | null
    softSkillsScore?: number | null
    analysis?: string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CvAnalysisCreateOrConnectWithoutApplicationInput = {
    where: CvAnalysisWhereUniqueInput
    create: XOR<CvAnalysisCreateWithoutApplicationInput, CvAnalysisUncheckedCreateWithoutApplicationInput>
  }

  export type OnboardingProgressCreateWithoutApplicationInput = {
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    user: UserCreateNestedOneWithoutOnboardingProgressInput
    hiringManager: UserCreateNestedOneWithoutManagedOnboardingsInput
    contract?: ContractCreateNestedOneWithoutOnboardingInput
  }

  export type OnboardingProgressUncheckedCreateWithoutApplicationInput = {
    id?: number
    userId: string
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    hiringManagerId: string
    contract?: ContractUncheckedCreateNestedOneWithoutOnboardingInput
  }

  export type OnboardingProgressCreateOrConnectWithoutApplicationInput = {
    where: OnboardingProgressWhereUniqueInput
    create: XOR<OnboardingProgressCreateWithoutApplicationInput, OnboardingProgressUncheckedCreateWithoutApplicationInput>
  }

  export type OnboardingInvitationCreateWithoutApplicationInput = {
    id?: string
    email: string
    token: string
    otp?: string | null
    otpExpiresAt?: Date | string | null
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    lastAccessedAt?: Date | string
    sessionToken?: string | null
    sessionExpiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OnboardingInvitationUncheckedCreateWithoutApplicationInput = {
    id?: string
    email: string
    token: string
    otp?: string | null
    otpExpiresAt?: Date | string | null
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    lastAccessedAt?: Date | string
    sessionToken?: string | null
    sessionExpiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OnboardingInvitationCreateOrConnectWithoutApplicationInput = {
    where: OnboardingInvitationWhereUniqueInput
    create: XOR<OnboardingInvitationCreateWithoutApplicationInput, OnboardingInvitationUncheckedCreateWithoutApplicationInput>
  }

  export type CandidateUpsertWithoutApplicationsInput = {
    update: XOR<CandidateUpdateWithoutApplicationsInput, CandidateUncheckedUpdateWithoutApplicationsInput>
    create: XOR<CandidateCreateWithoutApplicationsInput, CandidateUncheckedCreateWithoutApplicationsInput>
    where?: CandidateWhereInput
  }

  export type CandidateUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: CandidateWhereInput
    data: XOR<CandidateUpdateWithoutApplicationsInput, CandidateUncheckedUpdateWithoutApplicationsInput>
  }

  export type CandidateUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: CandidateNoteUpdateManyWithoutCandidateNestedInput
  }

  export type CandidateUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: CandidateNoteUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type JobListingUpsertWithoutApplicationsInput = {
    update: XOR<JobListingUpdateWithoutApplicationsInput, JobListingUncheckedUpdateWithoutApplicationsInput>
    create: XOR<JobListingCreateWithoutApplicationsInput, JobListingUncheckedCreateWithoutApplicationsInput>
    where?: JobListingWhereInput
  }

  export type JobListingUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: JobListingWhereInput
    data: XOR<JobListingUpdateWithoutApplicationsInput, JobListingUncheckedUpdateWithoutApplicationsInput>
  }

  export type JobListingUpdateWithoutApplicationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutJobListingNestedInput
    location?: LocationUpdateOneWithoutJobListingNestedInput
    position?: PositionUpdateOneWithoutJobListingsNestedInput
  }

  export type JobListingUncheckedUpdateWithoutApplicationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobApplicationHistoryUpsertWithWhereUniqueWithoutApplicationInput = {
    where: JobApplicationHistoryWhereUniqueInput
    update: XOR<JobApplicationHistoryUpdateWithoutApplicationInput, JobApplicationHistoryUncheckedUpdateWithoutApplicationInput>
    create: XOR<JobApplicationHistoryCreateWithoutApplicationInput, JobApplicationHistoryUncheckedCreateWithoutApplicationInput>
  }

  export type JobApplicationHistoryUpdateWithWhereUniqueWithoutApplicationInput = {
    where: JobApplicationHistoryWhereUniqueInput
    data: XOR<JobApplicationHistoryUpdateWithoutApplicationInput, JobApplicationHistoryUncheckedUpdateWithoutApplicationInput>
  }

  export type JobApplicationHistoryUpdateManyWithWhereWithoutApplicationInput = {
    where: JobApplicationHistoryScalarWhereInput
    data: XOR<JobApplicationHistoryUpdateManyMutationInput, JobApplicationHistoryUncheckedUpdateManyWithoutApplicationInput>
  }

  export type CvAnalysisUpsertWithoutApplicationInput = {
    update: XOR<CvAnalysisUpdateWithoutApplicationInput, CvAnalysisUncheckedUpdateWithoutApplicationInput>
    create: XOR<CvAnalysisCreateWithoutApplicationInput, CvAnalysisUncheckedCreateWithoutApplicationInput>
    where?: CvAnalysisWhereInput
  }

  export type CvAnalysisUpdateToOneWithWhereWithoutApplicationInput = {
    where?: CvAnalysisWhereInput
    data: XOR<CvAnalysisUpdateWithoutApplicationInput, CvAnalysisUncheckedUpdateWithoutApplicationInput>
  }

  export type CvAnalysisUpdateWithoutApplicationInput = {
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    educationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    cvQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    softSkillsScore?: NullableFloatFieldUpdateOperationsInput | number | null
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CvAnalysisUncheckedUpdateWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    educationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    cvQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    softSkillsScore?: NullableFloatFieldUpdateOperationsInput | number | null
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    parsedContent?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressUpsertWithoutApplicationInput = {
    update: XOR<OnboardingProgressUpdateWithoutApplicationInput, OnboardingProgressUncheckedUpdateWithoutApplicationInput>
    create: XOR<OnboardingProgressCreateWithoutApplicationInput, OnboardingProgressUncheckedCreateWithoutApplicationInput>
    where?: OnboardingProgressWhereInput
  }

  export type OnboardingProgressUpdateToOneWithWhereWithoutApplicationInput = {
    where?: OnboardingProgressWhereInput
    data: XOR<OnboardingProgressUpdateWithoutApplicationInput, OnboardingProgressUncheckedUpdateWithoutApplicationInput>
  }

  export type OnboardingProgressUpdateWithoutApplicationInput = {
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingProgressNestedInput
    hiringManager?: UserUpdateOneRequiredWithoutManagedOnboardingsNestedInput
    contract?: ContractUpdateOneWithoutOnboardingNestedInput
  }

  export type OnboardingProgressUncheckedUpdateWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hiringManagerId?: StringFieldUpdateOperationsInput | string
    contract?: ContractUncheckedUpdateOneWithoutOnboardingNestedInput
  }

  export type OnboardingInvitationUpsertWithoutApplicationInput = {
    update: XOR<OnboardingInvitationUpdateWithoutApplicationInput, OnboardingInvitationUncheckedUpdateWithoutApplicationInput>
    create: XOR<OnboardingInvitationCreateWithoutApplicationInput, OnboardingInvitationUncheckedCreateWithoutApplicationInput>
    where?: OnboardingInvitationWhereInput
  }

  export type OnboardingInvitationUpdateToOneWithWhereWithoutApplicationInput = {
    where?: OnboardingInvitationWhereInput
    data: XOR<OnboardingInvitationUpdateWithoutApplicationInput, OnboardingInvitationUncheckedUpdateWithoutApplicationInput>
  }

  export type OnboardingInvitationUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingInvitationUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationCreateWithoutCvAnalysisInput = {
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    candidate: CandidateCreateNestedOneWithoutApplicationsInput
    jobListing: JobListingCreateNestedOneWithoutApplicationsInput
    history?: JobApplicationHistoryCreateNestedManyWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutCvAnalysisInput = {
    id?: number
    candidateId: string
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    jobListingId: number
    createdAt?: Date | string
    history?: JobApplicationHistoryUncheckedCreateNestedManyWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutCvAnalysisInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutCvAnalysisInput, JobApplicationUncheckedCreateWithoutCvAnalysisInput>
  }

  export type JobApplicationUpsertWithoutCvAnalysisInput = {
    update: XOR<JobApplicationUpdateWithoutCvAnalysisInput, JobApplicationUncheckedUpdateWithoutCvAnalysisInput>
    create: XOR<JobApplicationCreateWithoutCvAnalysisInput, JobApplicationUncheckedCreateWithoutCvAnalysisInput>
    where?: JobApplicationWhereInput
  }

  export type JobApplicationUpdateToOneWithWhereWithoutCvAnalysisInput = {
    where?: JobApplicationWhereInput
    data: XOR<JobApplicationUpdateWithoutCvAnalysisInput, JobApplicationUncheckedUpdateWithoutCvAnalysisInput>
  }

  export type JobApplicationUpdateWithoutCvAnalysisInput = {
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidate?: CandidateUpdateOneRequiredWithoutApplicationsNestedInput
    jobListing?: JobListingUpdateOneRequiredWithoutApplicationsNestedInput
    history?: JobApplicationHistoryUpdateManyWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutCvAnalysisInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    jobListingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: JobApplicationHistoryUncheckedUpdateManyWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationCreateWithoutHistoryInput = {
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    candidate: CandidateCreateNestedOneWithoutApplicationsInput
    jobListing: JobListingCreateNestedOneWithoutApplicationsInput
    cvAnalysis?: CvAnalysisCreateNestedOneWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutHistoryInput = {
    id?: number
    candidateId: string
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    jobListingId: number
    createdAt?: Date | string
    cvAnalysis?: CvAnalysisUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutHistoryInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutHistoryInput, JobApplicationUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutJobApplicationHistoryInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutJobApplicationHistoryInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutJobApplicationHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobApplicationHistoryInput, UserUncheckedCreateWithoutJobApplicationHistoryInput>
  }

  export type JobApplicationUpsertWithoutHistoryInput = {
    update: XOR<JobApplicationUpdateWithoutHistoryInput, JobApplicationUncheckedUpdateWithoutHistoryInput>
    create: XOR<JobApplicationCreateWithoutHistoryInput, JobApplicationUncheckedCreateWithoutHistoryInput>
    where?: JobApplicationWhereInput
  }

  export type JobApplicationUpdateToOneWithWhereWithoutHistoryInput = {
    where?: JobApplicationWhereInput
    data: XOR<JobApplicationUpdateWithoutHistoryInput, JobApplicationUncheckedUpdateWithoutHistoryInput>
  }

  export type JobApplicationUpdateWithoutHistoryInput = {
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidate?: CandidateUpdateOneRequiredWithoutApplicationsNestedInput
    jobListing?: JobListingUpdateOneRequiredWithoutApplicationsNestedInput
    cvAnalysis?: CvAnalysisUpdateOneWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    jobListingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cvAnalysis?: CvAnalysisUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type UserUpsertWithoutJobApplicationHistoryInput = {
    update: XOR<UserUpdateWithoutJobApplicationHistoryInput, UserUncheckedUpdateWithoutJobApplicationHistoryInput>
    create: XOR<UserCreateWithoutJobApplicationHistoryInput, UserUncheckedCreateWithoutJobApplicationHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobApplicationHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobApplicationHistoryInput, UserUncheckedUpdateWithoutJobApplicationHistoryInput>
  }

  export type UserUpdateWithoutJobApplicationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutJobApplicationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserCreateWithoutPersonalInfoInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPersonalInfoInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutPersonalInfoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalInfoInput, UserUncheckedCreateWithoutPersonalInfoInput>
  }

  export type IdentificationDocumentCreateWithoutPersonalInfoInput = {
    type: $Enums.IdentificationDocumentType
    documentNumber: string
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuingAuthority: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput = {
    id?: number
    type: $Enums.IdentificationDocumentType
    documentNumber: string
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuingAuthority: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentificationDocumentCreateOrConnectWithoutPersonalInfoInput = {
    where: IdentificationDocumentWhereUniqueInput
    create: XOR<IdentificationDocumentCreateWithoutPersonalInfoInput, IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput>
  }

  export type IdentificationDocumentCreateManyPersonalInfoInputEnvelope = {
    data: IdentificationDocumentCreateManyPersonalInfoInput | IdentificationDocumentCreateManyPersonalInfoInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutPersonalInfoInput = {
    type?: $Enums.AddressType
    street: string
    streetNumber: string
    city: string
    region: string
    postalCode: string
    country: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutPersonalInfoInput = {
    id?: number
    type?: $Enums.AddressType
    street: string
    streetNumber: string
    city: string
    region: string
    postalCode: string
    country: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutPersonalInfoInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutPersonalInfoInput, AddressUncheckedCreateWithoutPersonalInfoInput>
  }

  export type AddressCreateManyPersonalInfoInputEnvelope = {
    data: AddressCreateManyPersonalInfoInput | AddressCreateManyPersonalInfoInput[]
    skipDuplicates?: boolean
  }

  export type BankAccountCreateWithoutPersonalInfoInput = {
    bank?: $Enums.GreekBank
    iban: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUncheckedCreateWithoutPersonalInfoInput = {
    id?: number
    bank?: $Enums.GreekBank
    iban: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountCreateOrConnectWithoutPersonalInfoInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutPersonalInfoInput, BankAccountUncheckedCreateWithoutPersonalInfoInput>
  }

  export type BankAccountCreateManyPersonalInfoInputEnvelope = {
    data: BankAccountCreateManyPersonalInfoInput | BankAccountCreateManyPersonalInfoInput[]
    skipDuplicates?: boolean
  }

  export type LanguageSkillCreateWithoutPersonalInfoInput = {
    language: $Enums.Language
    proficiency: $Enums.Proficiency
    certificate?: string | null
    issueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutLanguageSkillInput
  }

  export type LanguageSkillUncheckedCreateWithoutPersonalInfoInput = {
    id?: number
    language: $Enums.Language
    proficiency: $Enums.Proficiency
    certificate?: string | null
    issueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutLanguageSkillInput
  }

  export type LanguageSkillCreateOrConnectWithoutPersonalInfoInput = {
    where: LanguageSkillWhereUniqueInput
    create: XOR<LanguageSkillCreateWithoutPersonalInfoInput, LanguageSkillUncheckedCreateWithoutPersonalInfoInput>
  }

  export type LanguageSkillCreateManyPersonalInfoInputEnvelope = {
    data: LanguageSkillCreateManyPersonalInfoInput | LanguageSkillCreateManyPersonalInfoInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPersonalInfoInput = {
    update: XOR<UserUpdateWithoutPersonalInfoInput, UserUncheckedUpdateWithoutPersonalInfoInput>
    create: XOR<UserCreateWithoutPersonalInfoInput, UserUncheckedCreateWithoutPersonalInfoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonalInfoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonalInfoInput, UserUncheckedUpdateWithoutPersonalInfoInput>
  }

  export type UserUpdateWithoutPersonalInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type IdentificationDocumentUpsertWithWhereUniqueWithoutPersonalInfoInput = {
    where: IdentificationDocumentWhereUniqueInput
    update: XOR<IdentificationDocumentUpdateWithoutPersonalInfoInput, IdentificationDocumentUncheckedUpdateWithoutPersonalInfoInput>
    create: XOR<IdentificationDocumentCreateWithoutPersonalInfoInput, IdentificationDocumentUncheckedCreateWithoutPersonalInfoInput>
  }

  export type IdentificationDocumentUpdateWithWhereUniqueWithoutPersonalInfoInput = {
    where: IdentificationDocumentWhereUniqueInput
    data: XOR<IdentificationDocumentUpdateWithoutPersonalInfoInput, IdentificationDocumentUncheckedUpdateWithoutPersonalInfoInput>
  }

  export type IdentificationDocumentUpdateManyWithWhereWithoutPersonalInfoInput = {
    where: IdentificationDocumentScalarWhereInput
    data: XOR<IdentificationDocumentUpdateManyMutationInput, IdentificationDocumentUncheckedUpdateManyWithoutPersonalInfoInput>
  }

  export type IdentificationDocumentScalarWhereInput = {
    AND?: IdentificationDocumentScalarWhereInput | IdentificationDocumentScalarWhereInput[]
    OR?: IdentificationDocumentScalarWhereInput[]
    NOT?: IdentificationDocumentScalarWhereInput | IdentificationDocumentScalarWhereInput[]
    id?: IntFilter<"IdentificationDocument"> | number
    personalInfoId?: IntFilter<"IdentificationDocument"> | number
    type?: EnumIdentificationDocumentTypeFilter<"IdentificationDocument"> | $Enums.IdentificationDocumentType
    documentNumber?: StringFilter<"IdentificationDocument"> | string
    issueDate?: DateTimeFilter<"IdentificationDocument"> | Date | string
    expiryDate?: DateTimeNullableFilter<"IdentificationDocument"> | Date | string | null
    issuingAuthority?: StringFilter<"IdentificationDocument"> | string
    isPrimary?: BoolFilter<"IdentificationDocument"> | boolean
    createdAt?: DateTimeFilter<"IdentificationDocument"> | Date | string
    updatedAt?: DateTimeFilter<"IdentificationDocument"> | Date | string
  }

  export type AddressUpsertWithWhereUniqueWithoutPersonalInfoInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutPersonalInfoInput, AddressUncheckedUpdateWithoutPersonalInfoInput>
    create: XOR<AddressCreateWithoutPersonalInfoInput, AddressUncheckedCreateWithoutPersonalInfoInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutPersonalInfoInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutPersonalInfoInput, AddressUncheckedUpdateWithoutPersonalInfoInput>
  }

  export type AddressUpdateManyWithWhereWithoutPersonalInfoInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutPersonalInfoInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: IntFilter<"Address"> | number
    personalInfoId?: IntFilter<"Address"> | number
    type?: EnumAddressTypeFilter<"Address"> | $Enums.AddressType
    street?: StringFilter<"Address"> | string
    streetNumber?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    region?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    isPrimary?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type BankAccountUpsertWithWhereUniqueWithoutPersonalInfoInput = {
    where: BankAccountWhereUniqueInput
    update: XOR<BankAccountUpdateWithoutPersonalInfoInput, BankAccountUncheckedUpdateWithoutPersonalInfoInput>
    create: XOR<BankAccountCreateWithoutPersonalInfoInput, BankAccountUncheckedCreateWithoutPersonalInfoInput>
  }

  export type BankAccountUpdateWithWhereUniqueWithoutPersonalInfoInput = {
    where: BankAccountWhereUniqueInput
    data: XOR<BankAccountUpdateWithoutPersonalInfoInput, BankAccountUncheckedUpdateWithoutPersonalInfoInput>
  }

  export type BankAccountUpdateManyWithWhereWithoutPersonalInfoInput = {
    where: BankAccountScalarWhereInput
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyWithoutPersonalInfoInput>
  }

  export type BankAccountScalarWhereInput = {
    AND?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
    OR?: BankAccountScalarWhereInput[]
    NOT?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
    id?: IntFilter<"BankAccount"> | number
    personalInfoId?: IntFilter<"BankAccount"> | number
    bank?: EnumGreekBankFilter<"BankAccount"> | $Enums.GreekBank
    iban?: StringFilter<"BankAccount"> | string
    isPrimary?: BoolFilter<"BankAccount"> | boolean
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
  }

  export type LanguageSkillUpsertWithWhereUniqueWithoutPersonalInfoInput = {
    where: LanguageSkillWhereUniqueInput
    update: XOR<LanguageSkillUpdateWithoutPersonalInfoInput, LanguageSkillUncheckedUpdateWithoutPersonalInfoInput>
    create: XOR<LanguageSkillCreateWithoutPersonalInfoInput, LanguageSkillUncheckedCreateWithoutPersonalInfoInput>
  }

  export type LanguageSkillUpdateWithWhereUniqueWithoutPersonalInfoInput = {
    where: LanguageSkillWhereUniqueInput
    data: XOR<LanguageSkillUpdateWithoutPersonalInfoInput, LanguageSkillUncheckedUpdateWithoutPersonalInfoInput>
  }

  export type LanguageSkillUpdateManyWithWhereWithoutPersonalInfoInput = {
    where: LanguageSkillScalarWhereInput
    data: XOR<LanguageSkillUpdateManyMutationInput, LanguageSkillUncheckedUpdateManyWithoutPersonalInfoInput>
  }

  export type LanguageSkillScalarWhereInput = {
    AND?: LanguageSkillScalarWhereInput | LanguageSkillScalarWhereInput[]
    OR?: LanguageSkillScalarWhereInput[]
    NOT?: LanguageSkillScalarWhereInput | LanguageSkillScalarWhereInput[]
    id?: IntFilter<"LanguageSkill"> | number
    personalInfoId?: IntFilter<"LanguageSkill"> | number
    language?: EnumLanguageFilter<"LanguageSkill"> | $Enums.Language
    proficiency?: EnumProficiencyFilter<"LanguageSkill"> | $Enums.Proficiency
    certificate?: StringNullableFilter<"LanguageSkill"> | string | null
    issueDate?: DateTimeNullableFilter<"LanguageSkill"> | Date | string | null
    createdAt?: DateTimeFilter<"LanguageSkill"> | Date | string
    updatedAt?: DateTimeFilter<"LanguageSkill"> | Date | string
  }

  export type PersonalInfoCreateWithoutIdentificationDocumentsInput = {
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    user: UserCreateNestedOneWithoutPersonalInfoInput
    addresses?: AddressCreateNestedManyWithoutPersonalInfoInput
    bankAccounts?: BankAccountCreateNestedManyWithoutPersonalInfoInput
    languageSkills?: LanguageSkillCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoUncheckedCreateWithoutIdentificationDocumentsInput = {
    id?: number
    userId: string
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonalInfoInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutPersonalInfoInput
    languageSkills?: LanguageSkillUncheckedCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoCreateOrConnectWithoutIdentificationDocumentsInput = {
    where: PersonalInfoWhereUniqueInput
    create: XOR<PersonalInfoCreateWithoutIdentificationDocumentsInput, PersonalInfoUncheckedCreateWithoutIdentificationDocumentsInput>
  }

  export type PersonalInfoUpsertWithoutIdentificationDocumentsInput = {
    update: XOR<PersonalInfoUpdateWithoutIdentificationDocumentsInput, PersonalInfoUncheckedUpdateWithoutIdentificationDocumentsInput>
    create: XOR<PersonalInfoCreateWithoutIdentificationDocumentsInput, PersonalInfoUncheckedCreateWithoutIdentificationDocumentsInput>
    where?: PersonalInfoWhereInput
  }

  export type PersonalInfoUpdateToOneWithWhereWithoutIdentificationDocumentsInput = {
    where?: PersonalInfoWhereInput
    data: XOR<PersonalInfoUpdateWithoutIdentificationDocumentsInput, PersonalInfoUncheckedUpdateWithoutIdentificationDocumentsInput>
  }

  export type PersonalInfoUpdateWithoutIdentificationDocumentsInput = {
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutPersonalInfoNestedInput
    addresses?: AddressUpdateManyWithoutPersonalInfoNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutPersonalInfoNestedInput
    languageSkills?: LanguageSkillUpdateManyWithoutPersonalInfoNestedInput
  }

  export type PersonalInfoUncheckedUpdateWithoutIdentificationDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    addresses?: AddressUncheckedUpdateManyWithoutPersonalInfoNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutPersonalInfoNestedInput
    languageSkills?: LanguageSkillUncheckedUpdateManyWithoutPersonalInfoNestedInput
  }

  export type PersonalInfoCreateWithoutAddressesInput = {
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    user: UserCreateNestedOneWithoutPersonalInfoInput
    identificationDocuments?: IdentificationDocumentCreateNestedManyWithoutPersonalInfoInput
    bankAccounts?: BankAccountCreateNestedManyWithoutPersonalInfoInput
    languageSkills?: LanguageSkillCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoUncheckedCreateWithoutAddressesInput = {
    id?: number
    userId: string
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    identificationDocuments?: IdentificationDocumentUncheckedCreateNestedManyWithoutPersonalInfoInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutPersonalInfoInput
    languageSkills?: LanguageSkillUncheckedCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoCreateOrConnectWithoutAddressesInput = {
    where: PersonalInfoWhereUniqueInput
    create: XOR<PersonalInfoCreateWithoutAddressesInput, PersonalInfoUncheckedCreateWithoutAddressesInput>
  }

  export type PersonalInfoUpsertWithoutAddressesInput = {
    update: XOR<PersonalInfoUpdateWithoutAddressesInput, PersonalInfoUncheckedUpdateWithoutAddressesInput>
    create: XOR<PersonalInfoCreateWithoutAddressesInput, PersonalInfoUncheckedCreateWithoutAddressesInput>
    where?: PersonalInfoWhereInput
  }

  export type PersonalInfoUpdateToOneWithWhereWithoutAddressesInput = {
    where?: PersonalInfoWhereInput
    data: XOR<PersonalInfoUpdateWithoutAddressesInput, PersonalInfoUncheckedUpdateWithoutAddressesInput>
  }

  export type PersonalInfoUpdateWithoutAddressesInput = {
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutPersonalInfoNestedInput
    identificationDocuments?: IdentificationDocumentUpdateManyWithoutPersonalInfoNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutPersonalInfoNestedInput
    languageSkills?: LanguageSkillUpdateManyWithoutPersonalInfoNestedInput
  }

  export type PersonalInfoUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    identificationDocuments?: IdentificationDocumentUncheckedUpdateManyWithoutPersonalInfoNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutPersonalInfoNestedInput
    languageSkills?: LanguageSkillUncheckedUpdateManyWithoutPersonalInfoNestedInput
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type DependentMemberCreateWithoutDocumentInput = {
    firstName: string
    lastName: string
    middleName?: string | null
    birthDate: Date | string
    relationship: string
    isStudent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDependentMembersInput
  }

  export type DependentMemberUncheckedCreateWithoutDocumentInput = {
    id?: number
    userId: string
    firstName: string
    lastName: string
    middleName?: string | null
    birthDate: Date | string
    relationship: string
    isStudent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DependentMemberCreateOrConnectWithoutDocumentInput = {
    where: DependentMemberWhereUniqueInput
    create: XOR<DependentMemberCreateWithoutDocumentInput, DependentMemberUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentVerificationCreateWithoutDocumentInput = {
    status?: $Enums.VerificationStatus
    comments?: string | null
    reviewedAt?: Date | string | null
    reviewedBy: UserCreateNestedOneWithoutDocumentReviewsInput
    User?: UserCreateNestedOneWithoutDocumentVerificationInput
  }

  export type DocumentVerificationUncheckedCreateWithoutDocumentInput = {
    id?: number
    status?: $Enums.VerificationStatus
    reviewedById: string
    comments?: string | null
    reviewedAt?: Date | string | null
    userId?: string | null
  }

  export type DocumentVerificationCreateOrConnectWithoutDocumentInput = {
    where: DocumentVerificationWhereUniqueInput
    create: XOR<DocumentVerificationCreateWithoutDocumentInput, DocumentVerificationUncheckedCreateWithoutDocumentInput>
  }

  export type LanguageSkillCreateWithoutDocumentsInput = {
    language: $Enums.Language
    proficiency: $Enums.Proficiency
    certificate?: string | null
    issueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo: PersonalInfoCreateNestedOneWithoutLanguageSkillsInput
  }

  export type LanguageSkillUncheckedCreateWithoutDocumentsInput = {
    id?: number
    personalInfoId: number
    language: $Enums.Language
    proficiency: $Enums.Proficiency
    certificate?: string | null
    issueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageSkillCreateOrConnectWithoutDocumentsInput = {
    where: LanguageSkillWhereUniqueInput
    create: XOR<LanguageSkillCreateWithoutDocumentsInput, LanguageSkillUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type DependentMemberUpsertWithoutDocumentInput = {
    update: XOR<DependentMemberUpdateWithoutDocumentInput, DependentMemberUncheckedUpdateWithoutDocumentInput>
    create: XOR<DependentMemberCreateWithoutDocumentInput, DependentMemberUncheckedCreateWithoutDocumentInput>
    where?: DependentMemberWhereInput
  }

  export type DependentMemberUpdateToOneWithWhereWithoutDocumentInput = {
    where?: DependentMemberWhereInput
    data: XOR<DependentMemberUpdateWithoutDocumentInput, DependentMemberUncheckedUpdateWithoutDocumentInput>
  }

  export type DependentMemberUpdateWithoutDocumentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDependentMembersNestedInput
  }

  export type DependentMemberUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVerificationUpsertWithoutDocumentInput = {
    update: XOR<DocumentVerificationUpdateWithoutDocumentInput, DocumentVerificationUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentVerificationCreateWithoutDocumentInput, DocumentVerificationUncheckedCreateWithoutDocumentInput>
    where?: DocumentVerificationWhereInput
  }

  export type DocumentVerificationUpdateToOneWithWhereWithoutDocumentInput = {
    where?: DocumentVerificationWhereInput
    data: XOR<DocumentVerificationUpdateWithoutDocumentInput, DocumentVerificationUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentVerificationUpdateWithoutDocumentInput = {
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: UserUpdateOneRequiredWithoutDocumentReviewsNestedInput
    User?: UserUpdateOneWithoutDocumentVerificationNestedInput
  }

  export type DocumentVerificationUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedById?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LanguageSkillUpsertWithoutDocumentsInput = {
    update: XOR<LanguageSkillUpdateWithoutDocumentsInput, LanguageSkillUncheckedUpdateWithoutDocumentsInput>
    create: XOR<LanguageSkillCreateWithoutDocumentsInput, LanguageSkillUncheckedCreateWithoutDocumentsInput>
    where?: LanguageSkillWhereInput
  }

  export type LanguageSkillUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: LanguageSkillWhereInput
    data: XOR<LanguageSkillUpdateWithoutDocumentsInput, LanguageSkillUncheckedUpdateWithoutDocumentsInput>
  }

  export type LanguageSkillUpdateWithoutDocumentsInput = {
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    proficiency?: EnumProficiencyFieldUpdateOperationsInput | $Enums.Proficiency
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: PersonalInfoUpdateOneRequiredWithoutLanguageSkillsNestedInput
  }

  export type LanguageSkillUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    personalInfoId?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    proficiency?: EnumProficiencyFieldUpdateOperationsInput | $Enums.Proficiency
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateWithoutVerificationInput = {
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    dependentMember?: DependentMemberCreateNestedOneWithoutDocumentInput
    languageSkill?: LanguageSkillCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutVerificationInput = {
    id?: number
    userId: string
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    dependentMemberId?: number | null
    languageSkillId?: number | null
  }

  export type DocumentCreateOrConnectWithoutVerificationInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutVerificationInput, DocumentUncheckedCreateWithoutVerificationInput>
  }

  export type UserCreateWithoutDocumentReviewsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDocumentReviewsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutDocumentReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentReviewsInput, UserUncheckedCreateWithoutDocumentReviewsInput>
  }

  export type UserCreateWithoutDocumentVerificationInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDocumentVerificationInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutDocumentVerificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentVerificationInput, UserUncheckedCreateWithoutDocumentVerificationInput>
  }

  export type DocumentUpsertWithoutVerificationInput = {
    update: XOR<DocumentUpdateWithoutVerificationInput, DocumentUncheckedUpdateWithoutVerificationInput>
    create: XOR<DocumentCreateWithoutVerificationInput, DocumentUncheckedCreateWithoutVerificationInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutVerificationInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutVerificationInput, DocumentUncheckedUpdateWithoutVerificationInput>
  }

  export type DocumentUpdateWithoutVerificationInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    dependentMember?: DependentMemberUpdateOneWithoutDocumentNestedInput
    languageSkill?: LanguageSkillUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutVerificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    languageSkillId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpsertWithoutDocumentReviewsInput = {
    update: XOR<UserUpdateWithoutDocumentReviewsInput, UserUncheckedUpdateWithoutDocumentReviewsInput>
    create: XOR<UserCreateWithoutDocumentReviewsInput, UserUncheckedCreateWithoutDocumentReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentReviewsInput, UserUncheckedUpdateWithoutDocumentReviewsInput>
  }

  export type UserUpdateWithoutDocumentReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserUpsertWithoutDocumentVerificationInput = {
    update: XOR<UserUpdateWithoutDocumentVerificationInput, UserUncheckedUpdateWithoutDocumentVerificationInput>
    create: XOR<UserCreateWithoutDocumentVerificationInput, UserUncheckedCreateWithoutDocumentVerificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentVerificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentVerificationInput, UserUncheckedUpdateWithoutDocumentVerificationInput>
  }

  export type UserUpdateWithoutDocumentVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserCreateWithoutOnboardingProgressInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutOnboardingProgressInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutOnboardingProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
  }

  export type JobApplicationCreateWithoutOnboardingProgressInput = {
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    candidate: CandidateCreateNestedOneWithoutApplicationsInput
    jobListing: JobListingCreateNestedOneWithoutApplicationsInput
    history?: JobApplicationHistoryCreateNestedManyWithoutApplicationInput
    cvAnalysis?: CvAnalysisCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutOnboardingProgressInput = {
    id?: number
    candidateId: string
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    jobListingId: number
    createdAt?: Date | string
    history?: JobApplicationHistoryUncheckedCreateNestedManyWithoutApplicationInput
    cvAnalysis?: CvAnalysisUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingInvitation?: OnboardingInvitationUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutOnboardingProgressInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutOnboardingProgressInput, JobApplicationUncheckedCreateWithoutOnboardingProgressInput>
  }

  export type UserCreateWithoutManagedOnboardingsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutManagedOnboardingsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutManagedOnboardingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedOnboardingsInput, UserUncheckedCreateWithoutManagedOnboardingsInput>
  }

  export type ContractCreateWithoutOnboardingInput = {
    draftKey?: string | null
    signedKey?: string | null
    uploadedAt?: Date | string
    signedAt?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUncheckedCreateWithoutOnboardingInput = {
    id?: number
    draftKey?: string | null
    signedKey?: string | null
    uploadedAt?: Date | string
    signedAt?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractCreateOrConnectWithoutOnboardingInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutOnboardingInput, ContractUncheckedCreateWithoutOnboardingInput>
  }

  export type UserUpsertWithoutOnboardingProgressInput = {
    update: XOR<UserUpdateWithoutOnboardingProgressInput, UserUncheckedUpdateWithoutOnboardingProgressInput>
    create: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOnboardingProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOnboardingProgressInput, UserUncheckedUpdateWithoutOnboardingProgressInput>
  }

  export type UserUpdateWithoutOnboardingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutOnboardingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type JobApplicationUpsertWithoutOnboardingProgressInput = {
    update: XOR<JobApplicationUpdateWithoutOnboardingProgressInput, JobApplicationUncheckedUpdateWithoutOnboardingProgressInput>
    create: XOR<JobApplicationCreateWithoutOnboardingProgressInput, JobApplicationUncheckedCreateWithoutOnboardingProgressInput>
    where?: JobApplicationWhereInput
  }

  export type JobApplicationUpdateToOneWithWhereWithoutOnboardingProgressInput = {
    where?: JobApplicationWhereInput
    data: XOR<JobApplicationUpdateWithoutOnboardingProgressInput, JobApplicationUncheckedUpdateWithoutOnboardingProgressInput>
  }

  export type JobApplicationUpdateWithoutOnboardingProgressInput = {
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidate?: CandidateUpdateOneRequiredWithoutApplicationsNestedInput
    jobListing?: JobListingUpdateOneRequiredWithoutApplicationsNestedInput
    history?: JobApplicationHistoryUpdateManyWithoutApplicationNestedInput
    cvAnalysis?: CvAnalysisUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutOnboardingProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    jobListingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: JobApplicationHistoryUncheckedUpdateManyWithoutApplicationNestedInput
    cvAnalysis?: CvAnalysisUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type UserUpsertWithoutManagedOnboardingsInput = {
    update: XOR<UserUpdateWithoutManagedOnboardingsInput, UserUncheckedUpdateWithoutManagedOnboardingsInput>
    create: XOR<UserCreateWithoutManagedOnboardingsInput, UserUncheckedCreateWithoutManagedOnboardingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedOnboardingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedOnboardingsInput, UserUncheckedUpdateWithoutManagedOnboardingsInput>
  }

  export type UserUpdateWithoutManagedOnboardingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedOnboardingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type ContractUpsertWithoutOnboardingInput = {
    update: XOR<ContractUpdateWithoutOnboardingInput, ContractUncheckedUpdateWithoutOnboardingInput>
    create: XOR<ContractCreateWithoutOnboardingInput, ContractUncheckedCreateWithoutOnboardingInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutOnboardingInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutOnboardingInput, ContractUncheckedUpdateWithoutOnboardingInput>
  }

  export type ContractUpdateWithoutOnboardingInput = {
    draftKey?: NullableStringFieldUpdateOperationsInput | string | null
    signedKey?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateWithoutOnboardingInput = {
    id?: IntFieldUpdateOperationsInput | number
    draftKey?: NullableStringFieldUpdateOperationsInput | string | null
    signedKey?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationCreateWithoutOnboardingInvitationInput = {
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    candidate: CandidateCreateNestedOneWithoutApplicationsInput
    jobListing: JobListingCreateNestedOneWithoutApplicationsInput
    history?: JobApplicationHistoryCreateNestedManyWithoutApplicationInput
    cvAnalysis?: CvAnalysisCreateNestedOneWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutOnboardingInvitationInput = {
    id?: number
    candidateId: string
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    jobListingId: number
    createdAt?: Date | string
    history?: JobApplicationHistoryUncheckedCreateNestedManyWithoutApplicationInput
    cvAnalysis?: CvAnalysisUncheckedCreateNestedOneWithoutApplicationInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutOnboardingInvitationInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutOnboardingInvitationInput, JobApplicationUncheckedCreateWithoutOnboardingInvitationInput>
  }

  export type JobApplicationUpsertWithoutOnboardingInvitationInput = {
    update: XOR<JobApplicationUpdateWithoutOnboardingInvitationInput, JobApplicationUncheckedUpdateWithoutOnboardingInvitationInput>
    create: XOR<JobApplicationCreateWithoutOnboardingInvitationInput, JobApplicationUncheckedCreateWithoutOnboardingInvitationInput>
    where?: JobApplicationWhereInput
  }

  export type JobApplicationUpdateToOneWithWhereWithoutOnboardingInvitationInput = {
    where?: JobApplicationWhereInput
    data: XOR<JobApplicationUpdateWithoutOnboardingInvitationInput, JobApplicationUncheckedUpdateWithoutOnboardingInvitationInput>
  }

  export type JobApplicationUpdateWithoutOnboardingInvitationInput = {
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidate?: CandidateUpdateOneRequiredWithoutApplicationsNestedInput
    jobListing?: JobListingUpdateOneRequiredWithoutApplicationsNestedInput
    history?: JobApplicationHistoryUpdateManyWithoutApplicationNestedInput
    cvAnalysis?: CvAnalysisUpdateOneWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutOnboardingInvitationInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    jobListingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: JobApplicationHistoryUncheckedUpdateManyWithoutApplicationNestedInput
    cvAnalysis?: CvAnalysisUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type UserCreateWithoutEmergencyContactsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEmergencyContactsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutEmergencyContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
  }

  export type UserUpsertWithoutEmergencyContactsInput = {
    update: XOR<UserUpdateWithoutEmergencyContactsInput, UserUncheckedUpdateWithoutEmergencyContactsInput>
    create: XOR<UserCreateWithoutEmergencyContactsInput, UserUncheckedCreateWithoutEmergencyContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmergencyContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmergencyContactsInput, UserUncheckedUpdateWithoutEmergencyContactsInput>
  }

  export type UserUpdateWithoutEmergencyContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEmergencyContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserCreateWithoutDependentMembersInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDependentMembersInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutDependentMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDependentMembersInput, UserUncheckedCreateWithoutDependentMembersInput>
  }

  export type DocumentCreateWithoutDependentMemberInput = {
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    verification?: DocumentVerificationCreateNestedOneWithoutDocumentInput
    languageSkill?: LanguageSkillCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutDependentMemberInput = {
    id?: number
    userId: string
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    languageSkillId?: number | null
    verification?: DocumentVerificationUncheckedCreateNestedOneWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutDependentMemberInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDependentMemberInput, DocumentUncheckedCreateWithoutDependentMemberInput>
  }

  export type DocumentCreateManyDependentMemberInputEnvelope = {
    data: DocumentCreateManyDependentMemberInput | DocumentCreateManyDependentMemberInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDependentMembersInput = {
    update: XOR<UserUpdateWithoutDependentMembersInput, UserUncheckedUpdateWithoutDependentMembersInput>
    create: XOR<UserCreateWithoutDependentMembersInput, UserUncheckedCreateWithoutDependentMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDependentMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDependentMembersInput, UserUncheckedUpdateWithoutDependentMembersInput>
  }

  export type UserUpdateWithoutDependentMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDependentMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutDependentMemberInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutDependentMemberInput, DocumentUncheckedUpdateWithoutDependentMemberInput>
    create: XOR<DocumentCreateWithoutDependentMemberInput, DocumentUncheckedCreateWithoutDependentMemberInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutDependentMemberInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutDependentMemberInput, DocumentUncheckedUpdateWithoutDependentMemberInput>
  }

  export type DocumentUpdateManyWithWhereWithoutDependentMemberInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDependentMemberInput>
  }

  export type UserCreateWithoutEmailsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEmailsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutEmailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
  }

  export type UserUpsertWithoutEmailsInput = {
    update: XOR<UserUpdateWithoutEmailsInput, UserUncheckedUpdateWithoutEmailsInput>
    create: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailsInput, UserUncheckedUpdateWithoutEmailsInput>
  }

  export type UserUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserCreateWithoutPhonesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPhonesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutPhonesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPhonesInput, UserUncheckedCreateWithoutPhonesInput>
  }

  export type UserUpsertWithoutPhonesInput = {
    update: XOR<UserUpdateWithoutPhonesInput, UserUncheckedUpdateWithoutPhonesInput>
    create: XOR<UserCreateWithoutPhonesInput, UserUncheckedCreateWithoutPhonesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPhonesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPhonesInput, UserUncheckedUpdateWithoutPhonesInput>
  }

  export type UserUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type PersonalInfoCreateWithoutBankAccountsInput = {
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    user: UserCreateNestedOneWithoutPersonalInfoInput
    identificationDocuments?: IdentificationDocumentCreateNestedManyWithoutPersonalInfoInput
    addresses?: AddressCreateNestedManyWithoutPersonalInfoInput
    languageSkills?: LanguageSkillCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoUncheckedCreateWithoutBankAccountsInput = {
    id?: number
    userId: string
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    identificationDocuments?: IdentificationDocumentUncheckedCreateNestedManyWithoutPersonalInfoInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonalInfoInput
    languageSkills?: LanguageSkillUncheckedCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoCreateOrConnectWithoutBankAccountsInput = {
    where: PersonalInfoWhereUniqueInput
    create: XOR<PersonalInfoCreateWithoutBankAccountsInput, PersonalInfoUncheckedCreateWithoutBankAccountsInput>
  }

  export type PersonalInfoUpsertWithoutBankAccountsInput = {
    update: XOR<PersonalInfoUpdateWithoutBankAccountsInput, PersonalInfoUncheckedUpdateWithoutBankAccountsInput>
    create: XOR<PersonalInfoCreateWithoutBankAccountsInput, PersonalInfoUncheckedCreateWithoutBankAccountsInput>
    where?: PersonalInfoWhereInput
  }

  export type PersonalInfoUpdateToOneWithWhereWithoutBankAccountsInput = {
    where?: PersonalInfoWhereInput
    data: XOR<PersonalInfoUpdateWithoutBankAccountsInput, PersonalInfoUncheckedUpdateWithoutBankAccountsInput>
  }

  export type PersonalInfoUpdateWithoutBankAccountsInput = {
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutPersonalInfoNestedInput
    identificationDocuments?: IdentificationDocumentUpdateManyWithoutPersonalInfoNestedInput
    addresses?: AddressUpdateManyWithoutPersonalInfoNestedInput
    languageSkills?: LanguageSkillUpdateManyWithoutPersonalInfoNestedInput
  }

  export type PersonalInfoUncheckedUpdateWithoutBankAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    identificationDocuments?: IdentificationDocumentUncheckedUpdateManyWithoutPersonalInfoNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonalInfoNestedInput
    languageSkills?: LanguageSkillUncheckedUpdateManyWithoutPersonalInfoNestedInput
  }

  export type OnboardingProgressCreateWithoutContractInput = {
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    user: UserCreateNestedOneWithoutOnboardingProgressInput
    application: JobApplicationCreateNestedOneWithoutOnboardingProgressInput
    hiringManager: UserCreateNestedOneWithoutManagedOnboardingsInput
  }

  export type OnboardingProgressUncheckedCreateWithoutContractInput = {
    id?: number
    userId: string
    applicationId: number
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
    hiringManagerId: string
  }

  export type OnboardingProgressCreateOrConnectWithoutContractInput = {
    where: OnboardingProgressWhereUniqueInput
    create: XOR<OnboardingProgressCreateWithoutContractInput, OnboardingProgressUncheckedCreateWithoutContractInput>
  }

  export type OnboardingProgressUpsertWithoutContractInput = {
    update: XOR<OnboardingProgressUpdateWithoutContractInput, OnboardingProgressUncheckedUpdateWithoutContractInput>
    create: XOR<OnboardingProgressCreateWithoutContractInput, OnboardingProgressUncheckedCreateWithoutContractInput>
    where?: OnboardingProgressWhereInput
  }

  export type OnboardingProgressUpdateToOneWithWhereWithoutContractInput = {
    where?: OnboardingProgressWhereInput
    data: XOR<OnboardingProgressUpdateWithoutContractInput, OnboardingProgressUncheckedUpdateWithoutContractInput>
  }

  export type OnboardingProgressUpdateWithoutContractInput = {
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingProgressNestedInput
    application?: JobApplicationUpdateOneRequiredWithoutOnboardingProgressNestedInput
    hiringManager?: UserUpdateOneRequiredWithoutManagedOnboardingsNestedInput
  }

  export type OnboardingProgressUncheckedUpdateWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    applicationId?: IntFieldUpdateOperationsInput | number
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hiringManagerId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonalInfoCreateWithoutLanguageSkillsInput = {
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    user: UserCreateNestedOneWithoutPersonalInfoInput
    identificationDocuments?: IdentificationDocumentCreateNestedManyWithoutPersonalInfoInput
    addresses?: AddressCreateNestedManyWithoutPersonalInfoInput
    bankAccounts?: BankAccountCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoUncheckedCreateWithoutLanguageSkillsInput = {
    id?: number
    userId: string
    amka?: string | null
    afm?: string | null
    doy?: string | null
    middleName?: string | null
    birthDate: Date | string
    birthPlace: string
    maritalStatus?: $Enums.MaritalStatus
    numberOfChildren?: number
    citizenship?: string | null
    nationality?: string | null
    gender?: $Enums.Gender | null
    createdAt?: Date | string
    updatedAt?: Date | string
    educationLevel?: $Enums.EducationLevel | null
    educationTitle?: string | null
    educationInstitution?: string | null
    graduationYear?: number | null
    identificationDocuments?: IdentificationDocumentUncheckedCreateNestedManyWithoutPersonalInfoInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPersonalInfoInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutPersonalInfoInput
  }

  export type PersonalInfoCreateOrConnectWithoutLanguageSkillsInput = {
    where: PersonalInfoWhereUniqueInput
    create: XOR<PersonalInfoCreateWithoutLanguageSkillsInput, PersonalInfoUncheckedCreateWithoutLanguageSkillsInput>
  }

  export type DocumentCreateWithoutLanguageSkillInput = {
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    dependentMember?: DependentMemberCreateNestedOneWithoutDocumentInput
    verification?: DocumentVerificationCreateNestedOneWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutLanguageSkillInput = {
    id?: number
    userId: string
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    dependentMemberId?: number | null
    verification?: DocumentVerificationUncheckedCreateNestedOneWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutLanguageSkillInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutLanguageSkillInput, DocumentUncheckedCreateWithoutLanguageSkillInput>
  }

  export type DocumentCreateManyLanguageSkillInputEnvelope = {
    data: DocumentCreateManyLanguageSkillInput | DocumentCreateManyLanguageSkillInput[]
    skipDuplicates?: boolean
  }

  export type PersonalInfoUpsertWithoutLanguageSkillsInput = {
    update: XOR<PersonalInfoUpdateWithoutLanguageSkillsInput, PersonalInfoUncheckedUpdateWithoutLanguageSkillsInput>
    create: XOR<PersonalInfoCreateWithoutLanguageSkillsInput, PersonalInfoUncheckedCreateWithoutLanguageSkillsInput>
    where?: PersonalInfoWhereInput
  }

  export type PersonalInfoUpdateToOneWithWhereWithoutLanguageSkillsInput = {
    where?: PersonalInfoWhereInput
    data: XOR<PersonalInfoUpdateWithoutLanguageSkillsInput, PersonalInfoUncheckedUpdateWithoutLanguageSkillsInput>
  }

  export type PersonalInfoUpdateWithoutLanguageSkillsInput = {
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutPersonalInfoNestedInput
    identificationDocuments?: IdentificationDocumentUpdateManyWithoutPersonalInfoNestedInput
    addresses?: AddressUpdateManyWithoutPersonalInfoNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutPersonalInfoNestedInput
  }

  export type PersonalInfoUncheckedUpdateWithoutLanguageSkillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    amka?: NullableStringFieldUpdateOperationsInput | string | null
    afm?: NullableStringFieldUpdateOperationsInput | string | null
    doy?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    birthPlace?: StringFieldUpdateOperationsInput | string
    maritalStatus?: EnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    educationLevel?: NullableEnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel | null
    educationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    identificationDocuments?: IdentificationDocumentUncheckedUpdateManyWithoutPersonalInfoNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPersonalInfoNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutPersonalInfoNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutLanguageSkillInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutLanguageSkillInput, DocumentUncheckedUpdateWithoutLanguageSkillInput>
    create: XOR<DocumentCreateWithoutLanguageSkillInput, DocumentUncheckedCreateWithoutLanguageSkillInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutLanguageSkillInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutLanguageSkillInput, DocumentUncheckedUpdateWithoutLanguageSkillInput>
  }

  export type DocumentUpdateManyWithWhereWithoutLanguageSkillInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutLanguageSkillInput>
  }

  export type UserCreateWithoutRequestsMadeInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRequestsMadeInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutRequestsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestsMadeInput, UserUncheckedCreateWithoutRequestsMadeInput>
  }

  export type UserCreateWithoutRequestsToManageInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRequestsToManageInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutRequestsToManageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestsToManageInput, UserUncheckedCreateWithoutRequestsToManageInput>
  }

  export type RequestAttachmentCreateWithoutRequestInput = {
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type RequestAttachmentUncheckedCreateWithoutRequestInput = {
    id?: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type RequestAttachmentCreateOrConnectWithoutRequestInput = {
    where: RequestAttachmentWhereUniqueInput
    create: XOR<RequestAttachmentCreateWithoutRequestInput, RequestAttachmentUncheckedCreateWithoutRequestInput>
  }

  export type RequestAttachmentCreateManyRequestInputEnvelope = {
    data: RequestAttachmentCreateManyRequestInput | RequestAttachmentCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type RequestStatusHistoryCreateWithoutRequestInput = {
    status: $Enums.RequestStatus
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRequestHistoryInput
    attachments?: StatusAttachmentCreateNestedManyWithoutHistoryInput
  }

  export type RequestStatusHistoryUncheckedCreateWithoutRequestInput = {
    id?: number
    status: $Enums.RequestStatus
    comment?: string | null
    changedBy: string
    createdAt?: Date | string
    attachments?: StatusAttachmentUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type RequestStatusHistoryCreateOrConnectWithoutRequestInput = {
    where: RequestStatusHistoryWhereUniqueInput
    create: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput>
  }

  export type RequestStatusHistoryCreateManyRequestInputEnvelope = {
    data: RequestStatusHistoryCreateManyRequestInput | RequestStatusHistoryCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRequestsMadeInput = {
    update: XOR<UserUpdateWithoutRequestsMadeInput, UserUncheckedUpdateWithoutRequestsMadeInput>
    create: XOR<UserCreateWithoutRequestsMadeInput, UserUncheckedCreateWithoutRequestsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequestsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequestsMadeInput, UserUncheckedUpdateWithoutRequestsMadeInput>
  }

  export type UserUpdateWithoutRequestsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserUpsertWithoutRequestsToManageInput = {
    update: XOR<UserUpdateWithoutRequestsToManageInput, UserUncheckedUpdateWithoutRequestsToManageInput>
    create: XOR<UserCreateWithoutRequestsToManageInput, UserUncheckedCreateWithoutRequestsToManageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequestsToManageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequestsToManageInput, UserUncheckedUpdateWithoutRequestsToManageInput>
  }

  export type UserUpdateWithoutRequestsToManageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestsToManageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type RequestAttachmentUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestAttachmentWhereUniqueInput
    update: XOR<RequestAttachmentUpdateWithoutRequestInput, RequestAttachmentUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestAttachmentCreateWithoutRequestInput, RequestAttachmentUncheckedCreateWithoutRequestInput>
  }

  export type RequestAttachmentUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestAttachmentWhereUniqueInput
    data: XOR<RequestAttachmentUpdateWithoutRequestInput, RequestAttachmentUncheckedUpdateWithoutRequestInput>
  }

  export type RequestAttachmentUpdateManyWithWhereWithoutRequestInput = {
    where: RequestAttachmentScalarWhereInput
    data: XOR<RequestAttachmentUpdateManyMutationInput, RequestAttachmentUncheckedUpdateManyWithoutRequestInput>
  }

  export type RequestAttachmentScalarWhereInput = {
    AND?: RequestAttachmentScalarWhereInput | RequestAttachmentScalarWhereInput[]
    OR?: RequestAttachmentScalarWhereInput[]
    NOT?: RequestAttachmentScalarWhereInput | RequestAttachmentScalarWhereInput[]
    id?: IntFilter<"RequestAttachment"> | number
    requestId?: StringFilter<"RequestAttachment"> | string
    fileName?: StringFilter<"RequestAttachment"> | string
    fileKey?: StringFilter<"RequestAttachment"> | string
    fileType?: StringFilter<"RequestAttachment"> | string
    uploadedAt?: DateTimeFilter<"RequestAttachment"> | Date | string
  }

  export type RequestStatusHistoryUpsertWithWhereUniqueWithoutRequestInput = {
    where: RequestStatusHistoryWhereUniqueInput
    update: XOR<RequestStatusHistoryUpdateWithoutRequestInput, RequestStatusHistoryUncheckedUpdateWithoutRequestInput>
    create: XOR<RequestStatusHistoryCreateWithoutRequestInput, RequestStatusHistoryUncheckedCreateWithoutRequestInput>
  }

  export type RequestStatusHistoryUpdateWithWhereUniqueWithoutRequestInput = {
    where: RequestStatusHistoryWhereUniqueInput
    data: XOR<RequestStatusHistoryUpdateWithoutRequestInput, RequestStatusHistoryUncheckedUpdateWithoutRequestInput>
  }

  export type RequestStatusHistoryUpdateManyWithWhereWithoutRequestInput = {
    where: RequestStatusHistoryScalarWhereInput
    data: XOR<RequestStatusHistoryUpdateManyMutationInput, RequestStatusHistoryUncheckedUpdateManyWithoutRequestInput>
  }

  export type RequestCreateWithoutRequestStatusHistoryInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutRequestsMadeInput
    manager: UserCreateNestedOneWithoutRequestsToManageInput
    attachments?: RequestAttachmentCreateNestedManyWithoutRequestInput
  }

  export type RequestUncheckedCreateWithoutRequestStatusHistoryInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    requesterId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: RequestAttachmentUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestCreateOrConnectWithoutRequestStatusHistoryInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutRequestStatusHistoryInput, RequestUncheckedCreateWithoutRequestStatusHistoryInput>
  }

  export type UserCreateWithoutRequestHistoryInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRequestHistoryInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutRequestHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestHistoryInput, UserUncheckedCreateWithoutRequestHistoryInput>
  }

  export type StatusAttachmentCreateWithoutHistoryInput = {
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type StatusAttachmentUncheckedCreateWithoutHistoryInput = {
    id?: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type StatusAttachmentCreateOrConnectWithoutHistoryInput = {
    where: StatusAttachmentWhereUniqueInput
    create: XOR<StatusAttachmentCreateWithoutHistoryInput, StatusAttachmentUncheckedCreateWithoutHistoryInput>
  }

  export type StatusAttachmentCreateManyHistoryInputEnvelope = {
    data: StatusAttachmentCreateManyHistoryInput | StatusAttachmentCreateManyHistoryInput[]
    skipDuplicates?: boolean
  }

  export type RequestUpsertWithoutRequestStatusHistoryInput = {
    update: XOR<RequestUpdateWithoutRequestStatusHistoryInput, RequestUncheckedUpdateWithoutRequestStatusHistoryInput>
    create: XOR<RequestCreateWithoutRequestStatusHistoryInput, RequestUncheckedCreateWithoutRequestStatusHistoryInput>
    where?: RequestWhereInput
  }

  export type RequestUpdateToOneWithWhereWithoutRequestStatusHistoryInput = {
    where?: RequestWhereInput
    data: XOR<RequestUpdateWithoutRequestStatusHistoryInput, RequestUncheckedUpdateWithoutRequestStatusHistoryInput>
  }

  export type RequestUpdateWithoutRequestStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutRequestsMadeNestedInput
    manager?: UserUpdateOneRequiredWithoutRequestsToManageNestedInput
    attachments?: RequestAttachmentUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateWithoutRequestStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    requesterId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: RequestAttachmentUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type UserUpsertWithoutRequestHistoryInput = {
    update: XOR<UserUpdateWithoutRequestHistoryInput, UserUncheckedUpdateWithoutRequestHistoryInput>
    create: XOR<UserCreateWithoutRequestHistoryInput, UserUncheckedCreateWithoutRequestHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequestHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequestHistoryInput, UserUncheckedUpdateWithoutRequestHistoryInput>
  }

  export type UserUpdateWithoutRequestHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type StatusAttachmentUpsertWithWhereUniqueWithoutHistoryInput = {
    where: StatusAttachmentWhereUniqueInput
    update: XOR<StatusAttachmentUpdateWithoutHistoryInput, StatusAttachmentUncheckedUpdateWithoutHistoryInput>
    create: XOR<StatusAttachmentCreateWithoutHistoryInput, StatusAttachmentUncheckedCreateWithoutHistoryInput>
  }

  export type StatusAttachmentUpdateWithWhereUniqueWithoutHistoryInput = {
    where: StatusAttachmentWhereUniqueInput
    data: XOR<StatusAttachmentUpdateWithoutHistoryInput, StatusAttachmentUncheckedUpdateWithoutHistoryInput>
  }

  export type StatusAttachmentUpdateManyWithWhereWithoutHistoryInput = {
    where: StatusAttachmentScalarWhereInput
    data: XOR<StatusAttachmentUpdateManyMutationInput, StatusAttachmentUncheckedUpdateManyWithoutHistoryInput>
  }

  export type StatusAttachmentScalarWhereInput = {
    AND?: StatusAttachmentScalarWhereInput | StatusAttachmentScalarWhereInput[]
    OR?: StatusAttachmentScalarWhereInput[]
    NOT?: StatusAttachmentScalarWhereInput | StatusAttachmentScalarWhereInput[]
    id?: IntFilter<"StatusAttachment"> | number
    historyId?: IntFilter<"StatusAttachment"> | number
    fileName?: StringFilter<"StatusAttachment"> | string
    fileKey?: StringFilter<"StatusAttachment"> | string
    fileType?: StringFilter<"StatusAttachment"> | string
    uploadedAt?: DateTimeFilter<"StatusAttachment"> | Date | string
  }

  export type RequestStatusHistoryCreateWithoutAttachmentsInput = {
    status: $Enums.RequestStatus
    comment?: string | null
    createdAt?: Date | string
    request: RequestCreateNestedOneWithoutRequestStatusHistoryInput
    user: UserCreateNestedOneWithoutRequestHistoryInput
  }

  export type RequestStatusHistoryUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    requestId: string
    status: $Enums.RequestStatus
    comment?: string | null
    changedBy: string
    createdAt?: Date | string
  }

  export type RequestStatusHistoryCreateOrConnectWithoutAttachmentsInput = {
    where: RequestStatusHistoryWhereUniqueInput
    create: XOR<RequestStatusHistoryCreateWithoutAttachmentsInput, RequestStatusHistoryUncheckedCreateWithoutAttachmentsInput>
  }

  export type RequestStatusHistoryUpsertWithoutAttachmentsInput = {
    update: XOR<RequestStatusHistoryUpdateWithoutAttachmentsInput, RequestStatusHistoryUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<RequestStatusHistoryCreateWithoutAttachmentsInput, RequestStatusHistoryUncheckedCreateWithoutAttachmentsInput>
    where?: RequestStatusHistoryWhereInput
  }

  export type RequestStatusHistoryUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: RequestStatusHistoryWhereInput
    data: XOR<RequestStatusHistoryUpdateWithoutAttachmentsInput, RequestStatusHistoryUncheckedUpdateWithoutAttachmentsInput>
  }

  export type RequestStatusHistoryUpdateWithoutAttachmentsInput = {
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: RequestUpdateOneRequiredWithoutRequestStatusHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutRequestHistoryNestedInput
  }

  export type RequestStatusHistoryUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutRequestsMadeInput
    manager: UserCreateNestedOneWithoutRequestsToManageInput
    RequestStatusHistory?: RequestStatusHistoryCreateNestedManyWithoutRequestInput
  }

  export type RequestUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    requesterId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    RequestStatusHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestCreateOrConnectWithoutAttachmentsInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutAttachmentsInput, RequestUncheckedCreateWithoutAttachmentsInput>
  }

  export type RequestUpsertWithoutAttachmentsInput = {
    update: XOR<RequestUpdateWithoutAttachmentsInput, RequestUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<RequestCreateWithoutAttachmentsInput, RequestUncheckedCreateWithoutAttachmentsInput>
    where?: RequestWhereInput
  }

  export type RequestUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: RequestWhereInput
    data: XOR<RequestUpdateWithoutAttachmentsInput, RequestUncheckedUpdateWithoutAttachmentsInput>
  }

  export type RequestUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutRequestsMadeNestedInput
    manager?: UserUpdateOneRequiredWithoutRequestsToManageNestedInput
    RequestStatusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    requesterId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestStatusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type UserCreateWithoutLeavesRequestedInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutLeavesRequestedInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutLeavesRequestedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeavesRequestedInput, UserUncheckedCreateWithoutLeavesRequestedInput>
  }

  export type UserCreateWithoutLeavesToApproveInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutLeavesToApproveInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutLeavesToApproveInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeavesToApproveInput, UserUncheckedCreateWithoutLeavesToApproveInput>
  }

  export type LeaveAttachmentCreateWithoutLeaveInput = {
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type LeaveAttachmentUncheckedCreateWithoutLeaveInput = {
    id?: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type LeaveAttachmentCreateOrConnectWithoutLeaveInput = {
    where: LeaveAttachmentWhereUniqueInput
    create: XOR<LeaveAttachmentCreateWithoutLeaveInput, LeaveAttachmentUncheckedCreateWithoutLeaveInput>
  }

  export type LeaveAttachmentCreateManyLeaveInputEnvelope = {
    data: LeaveAttachmentCreateManyLeaveInput | LeaveAttachmentCreateManyLeaveInput[]
    skipDuplicates?: boolean
  }

  export type LeaveStatusHistoryCreateWithoutLeaveInput = {
    status: $Enums.LeaveStatus
    comment?: string | null
    createdAt?: Date | string
    changedBy: UserCreateNestedOneWithoutLeaveStatusHistoryInput
    attachments?: LeaveStatusAttachmentCreateNestedManyWithoutHistoryInput
  }

  export type LeaveStatusHistoryUncheckedCreateWithoutLeaveInput = {
    id?: number
    status: $Enums.LeaveStatus
    comment?: string | null
    changedById: string
    createdAt?: Date | string
    attachments?: LeaveStatusAttachmentUncheckedCreateNestedManyWithoutHistoryInput
  }

  export type LeaveStatusHistoryCreateOrConnectWithoutLeaveInput = {
    where: LeaveStatusHistoryWhereUniqueInput
    create: XOR<LeaveStatusHistoryCreateWithoutLeaveInput, LeaveStatusHistoryUncheckedCreateWithoutLeaveInput>
  }

  export type LeaveStatusHistoryCreateManyLeaveInputEnvelope = {
    data: LeaveStatusHistoryCreateManyLeaveInput | LeaveStatusHistoryCreateManyLeaveInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLeavesRequestedInput = {
    update: XOR<UserUpdateWithoutLeavesRequestedInput, UserUncheckedUpdateWithoutLeavesRequestedInput>
    create: XOR<UserCreateWithoutLeavesRequestedInput, UserUncheckedCreateWithoutLeavesRequestedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeavesRequestedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeavesRequestedInput, UserUncheckedUpdateWithoutLeavesRequestedInput>
  }

  export type UserUpdateWithoutLeavesRequestedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutLeavesRequestedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserUpsertWithoutLeavesToApproveInput = {
    update: XOR<UserUpdateWithoutLeavesToApproveInput, UserUncheckedUpdateWithoutLeavesToApproveInput>
    create: XOR<UserCreateWithoutLeavesToApproveInput, UserUncheckedCreateWithoutLeavesToApproveInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeavesToApproveInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeavesToApproveInput, UserUncheckedUpdateWithoutLeavesToApproveInput>
  }

  export type UserUpdateWithoutLeavesToApproveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutLeavesToApproveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type LeaveAttachmentUpsertWithWhereUniqueWithoutLeaveInput = {
    where: LeaveAttachmentWhereUniqueInput
    update: XOR<LeaveAttachmentUpdateWithoutLeaveInput, LeaveAttachmentUncheckedUpdateWithoutLeaveInput>
    create: XOR<LeaveAttachmentCreateWithoutLeaveInput, LeaveAttachmentUncheckedCreateWithoutLeaveInput>
  }

  export type LeaveAttachmentUpdateWithWhereUniqueWithoutLeaveInput = {
    where: LeaveAttachmentWhereUniqueInput
    data: XOR<LeaveAttachmentUpdateWithoutLeaveInput, LeaveAttachmentUncheckedUpdateWithoutLeaveInput>
  }

  export type LeaveAttachmentUpdateManyWithWhereWithoutLeaveInput = {
    where: LeaveAttachmentScalarWhereInput
    data: XOR<LeaveAttachmentUpdateManyMutationInput, LeaveAttachmentUncheckedUpdateManyWithoutLeaveInput>
  }

  export type LeaveAttachmentScalarWhereInput = {
    AND?: LeaveAttachmentScalarWhereInput | LeaveAttachmentScalarWhereInput[]
    OR?: LeaveAttachmentScalarWhereInput[]
    NOT?: LeaveAttachmentScalarWhereInput | LeaveAttachmentScalarWhereInput[]
    id?: IntFilter<"LeaveAttachment"> | number
    leaveId?: StringFilter<"LeaveAttachment"> | string
    fileName?: StringFilter<"LeaveAttachment"> | string
    fileKey?: StringFilter<"LeaveAttachment"> | string
    fileType?: StringFilter<"LeaveAttachment"> | string
    uploadedAt?: DateTimeFilter<"LeaveAttachment"> | Date | string
  }

  export type LeaveStatusHistoryUpsertWithWhereUniqueWithoutLeaveInput = {
    where: LeaveStatusHistoryWhereUniqueInput
    update: XOR<LeaveStatusHistoryUpdateWithoutLeaveInput, LeaveStatusHistoryUncheckedUpdateWithoutLeaveInput>
    create: XOR<LeaveStatusHistoryCreateWithoutLeaveInput, LeaveStatusHistoryUncheckedCreateWithoutLeaveInput>
  }

  export type LeaveStatusHistoryUpdateWithWhereUniqueWithoutLeaveInput = {
    where: LeaveStatusHistoryWhereUniqueInput
    data: XOR<LeaveStatusHistoryUpdateWithoutLeaveInput, LeaveStatusHistoryUncheckedUpdateWithoutLeaveInput>
  }

  export type LeaveStatusHistoryUpdateManyWithWhereWithoutLeaveInput = {
    where: LeaveStatusHistoryScalarWhereInput
    data: XOR<LeaveStatusHistoryUpdateManyMutationInput, LeaveStatusHistoryUncheckedUpdateManyWithoutLeaveInput>
  }

  export type LeaveRequestCreateWithoutAttachmentsInput = {
    id?: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutLeavesRequestedInput
    manager: UserCreateNestedOneWithoutLeavesToApproveInput
    statusHistory?: LeaveStatusHistoryCreateNestedManyWithoutLeaveInput
  }

  export type LeaveRequestUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    employeeId: string
    managerId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutLeaveInput
  }

  export type LeaveRequestCreateOrConnectWithoutAttachmentsInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutAttachmentsInput, LeaveRequestUncheckedCreateWithoutAttachmentsInput>
  }

  export type LeaveRequestUpsertWithoutAttachmentsInput = {
    update: XOR<LeaveRequestUpdateWithoutAttachmentsInput, LeaveRequestUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<LeaveRequestCreateWithoutAttachmentsInput, LeaveRequestUncheckedCreateWithoutAttachmentsInput>
    where?: LeaveRequestWhereInput
  }

  export type LeaveRequestUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: LeaveRequestWhereInput
    data: XOR<LeaveRequestUpdateWithoutAttachmentsInput, LeaveRequestUncheckedUpdateWithoutAttachmentsInput>
  }

  export type LeaveRequestUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutLeavesRequestedNestedInput
    manager?: UserUpdateOneRequiredWithoutLeavesToApproveNestedInput
    statusHistory?: LeaveStatusHistoryUpdateManyWithoutLeaveNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutLeaveNestedInput
  }

  export type LeaveRequestCreateWithoutStatusHistoryInput = {
    id?: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutLeavesRequestedInput
    manager: UserCreateNestedOneWithoutLeavesToApproveInput
    attachments?: LeaveAttachmentCreateNestedManyWithoutLeaveInput
  }

  export type LeaveRequestUncheckedCreateWithoutStatusHistoryInput = {
    id?: string
    employeeId: string
    managerId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: LeaveAttachmentUncheckedCreateNestedManyWithoutLeaveInput
  }

  export type LeaveRequestCreateOrConnectWithoutStatusHistoryInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutStatusHistoryInput, LeaveRequestUncheckedCreateWithoutStatusHistoryInput>
  }

  export type UserCreateWithoutLeaveStatusHistoryInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutLeaveStatusHistoryInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutLeaveStatusHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaveStatusHistoryInput, UserUncheckedCreateWithoutLeaveStatusHistoryInput>
  }

  export type LeaveStatusAttachmentCreateWithoutHistoryInput = {
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput = {
    id?: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type LeaveStatusAttachmentCreateOrConnectWithoutHistoryInput = {
    where: LeaveStatusAttachmentWhereUniqueInput
    create: XOR<LeaveStatusAttachmentCreateWithoutHistoryInput, LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput>
  }

  export type LeaveStatusAttachmentCreateManyHistoryInputEnvelope = {
    data: LeaveStatusAttachmentCreateManyHistoryInput | LeaveStatusAttachmentCreateManyHistoryInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestUpsertWithoutStatusHistoryInput = {
    update: XOR<LeaveRequestUpdateWithoutStatusHistoryInput, LeaveRequestUncheckedUpdateWithoutStatusHistoryInput>
    create: XOR<LeaveRequestCreateWithoutStatusHistoryInput, LeaveRequestUncheckedCreateWithoutStatusHistoryInput>
    where?: LeaveRequestWhereInput
  }

  export type LeaveRequestUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: LeaveRequestWhereInput
    data: XOR<LeaveRequestUpdateWithoutStatusHistoryInput, LeaveRequestUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type LeaveRequestUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutLeavesRequestedNestedInput
    manager?: UserUpdateOneRequiredWithoutLeavesToApproveNestedInput
    attachments?: LeaveAttachmentUpdateManyWithoutLeaveNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: LeaveAttachmentUncheckedUpdateManyWithoutLeaveNestedInput
  }

  export type UserUpsertWithoutLeaveStatusHistoryInput = {
    update: XOR<UserUpdateWithoutLeaveStatusHistoryInput, UserUncheckedUpdateWithoutLeaveStatusHistoryInput>
    create: XOR<UserCreateWithoutLeaveStatusHistoryInput, UserUncheckedCreateWithoutLeaveStatusHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaveStatusHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaveStatusHistoryInput, UserUncheckedUpdateWithoutLeaveStatusHistoryInput>
  }

  export type UserUpdateWithoutLeaveStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaveStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type LeaveStatusAttachmentUpsertWithWhereUniqueWithoutHistoryInput = {
    where: LeaveStatusAttachmentWhereUniqueInput
    update: XOR<LeaveStatusAttachmentUpdateWithoutHistoryInput, LeaveStatusAttachmentUncheckedUpdateWithoutHistoryInput>
    create: XOR<LeaveStatusAttachmentCreateWithoutHistoryInput, LeaveStatusAttachmentUncheckedCreateWithoutHistoryInput>
  }

  export type LeaveStatusAttachmentUpdateWithWhereUniqueWithoutHistoryInput = {
    where: LeaveStatusAttachmentWhereUniqueInput
    data: XOR<LeaveStatusAttachmentUpdateWithoutHistoryInput, LeaveStatusAttachmentUncheckedUpdateWithoutHistoryInput>
  }

  export type LeaveStatusAttachmentUpdateManyWithWhereWithoutHistoryInput = {
    where: LeaveStatusAttachmentScalarWhereInput
    data: XOR<LeaveStatusAttachmentUpdateManyMutationInput, LeaveStatusAttachmentUncheckedUpdateManyWithoutHistoryInput>
  }

  export type LeaveStatusAttachmentScalarWhereInput = {
    AND?: LeaveStatusAttachmentScalarWhereInput | LeaveStatusAttachmentScalarWhereInput[]
    OR?: LeaveStatusAttachmentScalarWhereInput[]
    NOT?: LeaveStatusAttachmentScalarWhereInput | LeaveStatusAttachmentScalarWhereInput[]
    id?: IntFilter<"LeaveStatusAttachment"> | number
    historyId?: IntFilter<"LeaveStatusAttachment"> | number
    fileName?: StringFilter<"LeaveStatusAttachment"> | string
    fileKey?: StringFilter<"LeaveStatusAttachment"> | string
    fileType?: StringFilter<"LeaveStatusAttachment"> | string
    uploadedAt?: DateTimeFilter<"LeaveStatusAttachment"> | Date | string
  }

  export type LeaveStatusHistoryCreateWithoutAttachmentsInput = {
    status: $Enums.LeaveStatus
    comment?: string | null
    createdAt?: Date | string
    leave: LeaveRequestCreateNestedOneWithoutStatusHistoryInput
    changedBy: UserCreateNestedOneWithoutLeaveStatusHistoryInput
  }

  export type LeaveStatusHistoryUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    leaveId: string
    status: $Enums.LeaveStatus
    comment?: string | null
    changedById: string
    createdAt?: Date | string
  }

  export type LeaveStatusHistoryCreateOrConnectWithoutAttachmentsInput = {
    where: LeaveStatusHistoryWhereUniqueInput
    create: XOR<LeaveStatusHistoryCreateWithoutAttachmentsInput, LeaveStatusHistoryUncheckedCreateWithoutAttachmentsInput>
  }

  export type LeaveStatusHistoryUpsertWithoutAttachmentsInput = {
    update: XOR<LeaveStatusHistoryUpdateWithoutAttachmentsInput, LeaveStatusHistoryUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<LeaveStatusHistoryCreateWithoutAttachmentsInput, LeaveStatusHistoryUncheckedCreateWithoutAttachmentsInput>
    where?: LeaveStatusHistoryWhereInput
  }

  export type LeaveStatusHistoryUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: LeaveStatusHistoryWhereInput
    data: XOR<LeaveStatusHistoryUpdateWithoutAttachmentsInput, LeaveStatusHistoryUncheckedUpdateWithoutAttachmentsInput>
  }

  export type LeaveStatusHistoryUpdateWithoutAttachmentsInput = {
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leave?: LeaveRequestUpdateOneRequiredWithoutStatusHistoryNestedInput
    changedBy?: UserUpdateOneRequiredWithoutLeaveStatusHistoryNestedInput
  }

  export type LeaveStatusHistoryUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveId?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutDepartmentInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserCreateManyDepartmentInputEnvelope = {
    data: UserCreateManyDepartmentInput | UserCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type JobListingCreateWithoutDepartmentInput = {
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutJobListingInput
    applications?: JobApplicationCreateNestedManyWithoutJobListingInput
    position?: PositionCreateNestedOneWithoutJobListingsInput
  }

  export type JobListingUncheckedCreateWithoutDepartmentInput = {
    id?: number
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    locationId?: string | null
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
    applications?: JobApplicationUncheckedCreateNestedManyWithoutJobListingInput
  }

  export type JobListingCreateOrConnectWithoutDepartmentInput = {
    where: JobListingWhereUniqueInput
    create: XOR<JobListingCreateWithoutDepartmentInput, JobListingUncheckedCreateWithoutDepartmentInput>
  }

  export type JobListingCreateManyDepartmentInputEnvelope = {
    data: JobListingCreateManyDepartmentInput | JobListingCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
  }

  export type UserUpdateManyWithWhereWithoutDepartmentInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type JobListingUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: JobListingWhereUniqueInput
    update: XOR<JobListingUpdateWithoutDepartmentInput, JobListingUncheckedUpdateWithoutDepartmentInput>
    create: XOR<JobListingCreateWithoutDepartmentInput, JobListingUncheckedCreateWithoutDepartmentInput>
  }

  export type JobListingUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: JobListingWhereUniqueInput
    data: XOR<JobListingUpdateWithoutDepartmentInput, JobListingUncheckedUpdateWithoutDepartmentInput>
  }

  export type JobListingUpdateManyWithWhereWithoutDepartmentInput = {
    where: JobListingScalarWhereInput
    data: XOR<JobListingUpdateManyMutationInput, JobListingUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type JobListingScalarWhereInput = {
    AND?: JobListingScalarWhereInput | JobListingScalarWhereInput[]
    OR?: JobListingScalarWhereInput[]
    NOT?: JobListingScalarWhereInput | JobListingScalarWhereInput[]
    id?: IntFilter<"JobListing"> | number
    title?: StringFilter<"JobListing"> | string
    description?: StringFilter<"JobListing"> | string
    employmentType?: EnumEmploymentTypeFilter<"JobListing"> | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFilter<"JobListing"> | $Enums.WorkplaceType
    referralSource?: StringNullableFilter<"JobListing"> | string | null
    startDate?: DateTimeFilter<"JobListing"> | Date | string
    endDate?: DateTimeNullableFilter<"JobListing"> | Date | string | null
    status?: EnumJobStatusFilter<"JobListing"> | $Enums.JobStatus
    departmentId?: StringNullableFilter<"JobListing"> | string | null
    locationId?: StringNullableFilter<"JobListing"> | string | null
    keywords?: StringNullableListFilter<"JobListing">
    createdAt?: DateTimeFilter<"JobListing"> | Date | string
    updatedAt?: DateTimeFilter<"JobListing"> | Date | string
    positionId?: StringNullableFilter<"JobListing"> | string | null
  }

  export type UserCreateWithoutLocationInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutLocationInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutLocationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type UserCreateManyLocationInputEnvelope = {
    data: UserCreateManyLocationInput | UserCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type JobListingCreateWithoutLocationInput = {
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutJobListingInput
    applications?: JobApplicationCreateNestedManyWithoutJobListingInput
    position?: PositionCreateNestedOneWithoutJobListingsInput
  }

  export type JobListingUncheckedCreateWithoutLocationInput = {
    id?: number
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    departmentId?: string | null
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
    applications?: JobApplicationUncheckedCreateNestedManyWithoutJobListingInput
  }

  export type JobListingCreateOrConnectWithoutLocationInput = {
    where: JobListingWhereUniqueInput
    create: XOR<JobListingCreateWithoutLocationInput, JobListingUncheckedCreateWithoutLocationInput>
  }

  export type JobListingCreateManyLocationInputEnvelope = {
    data: JobListingCreateManyLocationInput | JobListingCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutLocationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLocationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
  }

  export type UserUpdateManyWithWhereWithoutLocationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLocationInput>
  }

  export type JobListingUpsertWithWhereUniqueWithoutLocationInput = {
    where: JobListingWhereUniqueInput
    update: XOR<JobListingUpdateWithoutLocationInput, JobListingUncheckedUpdateWithoutLocationInput>
    create: XOR<JobListingCreateWithoutLocationInput, JobListingUncheckedCreateWithoutLocationInput>
  }

  export type JobListingUpdateWithWhereUniqueWithoutLocationInput = {
    where: JobListingWhereUniqueInput
    data: XOR<JobListingUpdateWithoutLocationInput, JobListingUncheckedUpdateWithoutLocationInput>
  }

  export type JobListingUpdateManyWithWhereWithoutLocationInput = {
    where: JobListingScalarWhereInput
    data: XOR<JobListingUpdateManyMutationInput, JobListingUncheckedUpdateManyWithoutLocationInput>
  }

  export type UserCreateWithoutPositionInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPositionInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutPositionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput>
  }

  export type UserCreateManyPositionInputEnvelope = {
    data: UserCreateManyPositionInput | UserCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type JobListingCreateWithoutPositionInput = {
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutJobListingInput
    location?: LocationCreateNestedOneWithoutJobListingInput
    applications?: JobApplicationCreateNestedManyWithoutJobListingInput
  }

  export type JobListingUncheckedCreateWithoutPositionInput = {
    id?: number
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    departmentId?: string | null
    locationId?: string | null
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: JobApplicationUncheckedCreateNestedManyWithoutJobListingInput
  }

  export type JobListingCreateOrConnectWithoutPositionInput = {
    where: JobListingWhereUniqueInput
    create: XOR<JobListingCreateWithoutPositionInput, JobListingUncheckedCreateWithoutPositionInput>
  }

  export type JobListingCreateManyPositionInputEnvelope = {
    data: JobListingCreateManyPositionInput | JobListingCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutPositionInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPositionInput, UserUncheckedUpdateWithoutPositionInput>
    create: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPositionInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPositionInput, UserUncheckedUpdateWithoutPositionInput>
  }

  export type UserUpdateManyWithWhereWithoutPositionInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutPositionInput>
  }

  export type JobListingUpsertWithWhereUniqueWithoutPositionInput = {
    where: JobListingWhereUniqueInput
    update: XOR<JobListingUpdateWithoutPositionInput, JobListingUncheckedUpdateWithoutPositionInput>
    create: XOR<JobListingCreateWithoutPositionInput, JobListingUncheckedCreateWithoutPositionInput>
  }

  export type JobListingUpdateWithWhereUniqueWithoutPositionInput = {
    where: JobListingWhereUniqueInput
    data: XOR<JobListingUpdateWithoutPositionInput, JobListingUncheckedUpdateWithoutPositionInput>
  }

  export type JobListingUpdateManyWithWhereWithoutPositionInput = {
    where: JobListingScalarWhereInput
    data: XOR<JobListingUpdateManyMutationInput, JobListingUncheckedUpdateManyWithoutPositionInput>
  }

  export type ProjectCreateWithoutClientInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClientInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectCreateManyClientInputEnvelope = {
    data: ProjectCreateManyClientInput | ProjectCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
  }

  export type ProjectUpdateManyWithWhereWithoutClientInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientCreateWithoutProjectsInput = {
    id?: string
    name: string
    vatNumber: string
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    vatNumber: string
    email?: string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.ClientStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateOrConnectWithoutProjectsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
  }

  export type UserCreateWithoutManagedProjectsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutManagedProjectsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutManagedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedProjectsInput, UserUncheckedCreateWithoutManagedProjectsInput>
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    id?: string
    role?: $Enums.ProjectMemberRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    role?: $Enums.ProjectMemberRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TimeEntryCreateWithoutProjectInput = {
    id?: string
    description: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    status?: $Enums.TimeEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTimeEntriesInput
  }

  export type TimeEntryUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    description: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    status?: $Enums.TimeEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeEntryCreateOrConnectWithoutProjectInput = {
    where: TimeEntryWhereUniqueInput
    create: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput>
  }

  export type TimeEntryCreateManyProjectInputEnvelope = {
    data: TimeEntryCreateManyProjectInput | TimeEntryCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutProjectsInput = {
    update: XOR<ClientUpdateWithoutProjectsInput, ClientUncheckedUpdateWithoutProjectsInput>
    create: XOR<ClientCreateWithoutProjectsInput, ClientUncheckedCreateWithoutProjectsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutProjectsInput, ClientUncheckedUpdateWithoutProjectsInput>
  }

  export type ClientUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vatNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vatNumber?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutManagedProjectsInput = {
    update: XOR<UserUpdateWithoutManagedProjectsInput, UserUncheckedUpdateWithoutManagedProjectsInput>
    create: XOR<UserCreateWithoutManagedProjectsInput, UserUncheckedCreateWithoutManagedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedProjectsInput, UserUncheckedUpdateWithoutManagedProjectsInput>
  }

  export type UserUpdateWithoutManagedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type TimeEntryUpsertWithWhereUniqueWithoutProjectInput = {
    where: TimeEntryWhereUniqueInput
    update: XOR<TimeEntryUpdateWithoutProjectInput, TimeEntryUncheckedUpdateWithoutProjectInput>
    create: XOR<TimeEntryCreateWithoutProjectInput, TimeEntryUncheckedCreateWithoutProjectInput>
  }

  export type TimeEntryUpdateWithWhereUniqueWithoutProjectInput = {
    where: TimeEntryWhereUniqueInput
    data: XOR<TimeEntryUpdateWithoutProjectInput, TimeEntryUncheckedUpdateWithoutProjectInput>
  }

  export type TimeEntryUpdateManyWithWhereWithoutProjectInput = {
    where: TimeEntryScalarWhereInput
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProjectsInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    timeEntries?: TimeEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutProjectMembershipsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutProjectMembershipsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutProjectMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProjectsNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMembershipsInput = {
    update: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type UserUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type ProjectCreateWithoutTimeEntriesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProjectsInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTimeEntriesInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTimeEntriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTimeEntriesInput, ProjectUncheckedCreateWithoutTimeEntriesInput>
  }

  export type UserCreateWithoutTimeEntriesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutTimeEntriesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutTimeEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimeEntriesInput, UserUncheckedCreateWithoutTimeEntriesInput>
  }

  export type ProjectUpsertWithoutTimeEntriesInput = {
    update: XOR<ProjectUpdateWithoutTimeEntriesInput, ProjectUncheckedUpdateWithoutTimeEntriesInput>
    create: XOR<ProjectCreateWithoutTimeEntriesInput, ProjectUncheckedCreateWithoutTimeEntriesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTimeEntriesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTimeEntriesInput, ProjectUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type ProjectUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProjectsNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutTimeEntriesInput = {
    update: XOR<UserUpdateWithoutTimeEntriesInput, UserUncheckedUpdateWithoutTimeEntriesInput>
    create: XOR<UserCreateWithoutTimeEntriesInput, UserUncheckedCreateWithoutTimeEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimeEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimeEntriesInput, UserUncheckedUpdateWithoutTimeEntriesInput>
  }

  export type UserUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTimeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserCreateWithoutAnnouncementsChangedInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAnnouncementsChangedInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutAnnouncementsChangedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementsChangedInput, UserUncheckedCreateWithoutAnnouncementsChangedInput>
  }

  export type UserCreateWithoutAnnouncementsPublishedInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAnnouncementsPublishedInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    shifts?: ShiftEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
  }

  export type UserCreateOrConnectWithoutAnnouncementsPublishedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementsPublishedInput, UserUncheckedCreateWithoutAnnouncementsPublishedInput>
  }

  export type UserUpsertWithoutAnnouncementsChangedInput = {
    update: XOR<UserUpdateWithoutAnnouncementsChangedInput, UserUncheckedUpdateWithoutAnnouncementsChangedInput>
    create: XOR<UserCreateWithoutAnnouncementsChangedInput, UserUncheckedCreateWithoutAnnouncementsChangedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnouncementsChangedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnouncementsChangedInput, UserUncheckedUpdateWithoutAnnouncementsChangedInput>
  }

  export type UserUpdateWithoutAnnouncementsChangedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementsChangedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserUpsertWithoutAnnouncementsPublishedInput = {
    update: XOR<UserUpdateWithoutAnnouncementsPublishedInput, UserUncheckedUpdateWithoutAnnouncementsPublishedInput>
    create: XOR<UserCreateWithoutAnnouncementsPublishedInput, UserUncheckedCreateWithoutAnnouncementsPublishedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnouncementsPublishedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnouncementsPublishedInput, UserUncheckedUpdateWithoutAnnouncementsPublishedInput>
  }

  export type UserUpdateWithoutAnnouncementsPublishedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementsPublishedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
  }

  export type ShiftEntryCreateWithoutScheduleInput = {
    id?: string
    date: Date | string
    status?: $Enums.ShiftStatus
    isNightShift?: boolean
    workplaceType?: $Enums.WorkplaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShiftsInput
  }

  export type ShiftEntryUncheckedCreateWithoutScheduleInput = {
    id?: string
    userId: string
    date: Date | string
    status?: $Enums.ShiftStatus
    isNightShift?: boolean
    workplaceType?: $Enums.WorkplaceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftEntryCreateOrConnectWithoutScheduleInput = {
    where: ShiftEntryWhereUniqueInput
    create: XOR<ShiftEntryCreateWithoutScheduleInput, ShiftEntryUncheckedCreateWithoutScheduleInput>
  }

  export type ShiftEntryCreateManyScheduleInputEnvelope = {
    data: ShiftEntryCreateManyScheduleInput | ShiftEntryCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type ShiftEntryUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ShiftEntryWhereUniqueInput
    update: XOR<ShiftEntryUpdateWithoutScheduleInput, ShiftEntryUncheckedUpdateWithoutScheduleInput>
    create: XOR<ShiftEntryCreateWithoutScheduleInput, ShiftEntryUncheckedCreateWithoutScheduleInput>
  }

  export type ShiftEntryUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ShiftEntryWhereUniqueInput
    data: XOR<ShiftEntryUpdateWithoutScheduleInput, ShiftEntryUncheckedUpdateWithoutScheduleInput>
  }

  export type ShiftEntryUpdateManyWithWhereWithoutScheduleInput = {
    where: ShiftEntryScalarWhereInput
    data: XOR<ShiftEntryUpdateManyMutationInput, ShiftEntryUncheckedUpdateManyWithoutScheduleInput>
  }

  export type UserCreateWithoutShiftsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutUsersInput
    candidateNotes?: CandidateNoteCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryCreateNestedManyWithoutChangedByInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoCreateNestedOneWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberCreateNestedManyWithoutUserInput
    emails?: UserEmailCreateNestedManyWithoutUserInput
    phones?: UserPhoneCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressCreateNestedManyWithoutHiringManagerInput
    manager?: UserCreateNestedOneWithoutEmployeesInput
    employees?: UserCreateNestedManyWithoutManagerInput
    requestsMade?: RequestCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementCreateNestedManyWithoutPublishedByUserInput
    position?: PositionCreateNestedOneWithoutUsersInput
    location?: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutShiftsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
    candidateNotes?: CandidateNoteUncheckedCreateNestedManyWithoutCreatedByInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedCreateNestedManyWithoutChangedByInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    statusHistory?: UserStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    statusChangesBy?: UserStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    personalInfo?: PersonalInfoUncheckedCreateNestedOneWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    documentReviews?: DocumentVerificationUncheckedCreateNestedManyWithoutReviewedByInput
    DocumentVerification?: DocumentVerificationUncheckedCreateNestedManyWithoutUserInput
    OnboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    emergencyContacts?: EmergencyContactUncheckedCreateNestedManyWithoutUserInput
    dependentMembers?: DependentMemberUncheckedCreateNestedManyWithoutUserInput
    emails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    phones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    managedOnboardings?: OnboardingProgressUncheckedCreateNestedManyWithoutHiringManagerInput
    employees?: UserUncheckedCreateNestedManyWithoutManagerInput
    requestsMade?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    requestsToManage?: RequestUncheckedCreateNestedManyWithoutManagerInput
    requestHistory?: RequestStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    leavesRequested?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    leavesToApprove?: LeaveRequestUncheckedCreateNestedManyWithoutManagerInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    timeEntries?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    announcementsChanged?: AnnouncementUncheckedCreateNestedManyWithoutChangedByUserInput
    announcementsPublished?: AnnouncementUncheckedCreateNestedManyWithoutPublishedByUserInput
  }

  export type UserCreateOrConnectWithoutShiftsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
  }

  export type TimeScheduleCreateWithoutShiftsInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeScheduleUncheckedCreateWithoutShiftsInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeScheduleCreateOrConnectWithoutShiftsInput = {
    where: TimeScheduleWhereUniqueInput
    create: XOR<TimeScheduleCreateWithoutShiftsInput, TimeScheduleUncheckedCreateWithoutShiftsInput>
  }

  export type UserUpsertWithoutShiftsInput = {
    update: XOR<UserUpdateWithoutShiftsInput, UserUncheckedUpdateWithoutShiftsInput>
    create: XOR<UserCreateWithoutShiftsInput, UserUncheckedCreateWithoutShiftsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShiftsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShiftsInput, UserUncheckedUpdateWithoutShiftsInput>
  }

  export type UserUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type TimeScheduleUpsertWithoutShiftsInput = {
    update: XOR<TimeScheduleUpdateWithoutShiftsInput, TimeScheduleUncheckedUpdateWithoutShiftsInput>
    create: XOR<TimeScheduleCreateWithoutShiftsInput, TimeScheduleUncheckedCreateWithoutShiftsInput>
    where?: TimeScheduleWhereInput
  }

  export type TimeScheduleUpdateToOneWithWhereWithoutShiftsInput = {
    where?: TimeScheduleWhereInput
    data: XOR<TimeScheduleUpdateWithoutShiftsInput, TimeScheduleUncheckedUpdateWithoutShiftsInput>
  }

  export type TimeScheduleUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeScheduleUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateNoteCreateManyCreatedByInput = {
    id?: number
    candidateId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobApplicationHistoryCreateManyChangedByInput = {
    id?: number
    applicationId: number
    status: $Enums.ApplicationStatus
    comment?: string | null
    createdAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserStatusHistoryCreateManyUserInput = {
    id?: number
    status: $Enums.UserStatus
    comment?: string | null
    createdAt?: Date | string
    changedById: string
  }

  export type UserStatusHistoryCreateManyChangedByInput = {
    id?: number
    userId: string
    status: $Enums.UserStatus
    comment?: string | null
    createdAt?: Date | string
  }

  export type DocumentCreateManyUserInput = {
    id?: number
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    dependentMemberId?: number | null
    languageSkillId?: number | null
  }

  export type DocumentVerificationCreateManyReviewedByInput = {
    id?: number
    documentId: number
    status?: $Enums.VerificationStatus
    comments?: string | null
    reviewedAt?: Date | string | null
    userId?: string | null
  }

  export type DocumentVerificationCreateManyUserInput = {
    id?: number
    documentId: number
    status?: $Enums.VerificationStatus
    reviewedById: string
    comments?: string | null
    reviewedAt?: Date | string | null
  }

  export type EmergencyContactCreateManyUserInput = {
    id?: number
    fullName: string
    relationship: string
    primaryPhone: string
    secondaryPhone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DependentMemberCreateManyUserInput = {
    id?: number
    firstName: string
    lastName: string
    middleName?: string | null
    birthDate: Date | string
    relationship: string
    isStudent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmailCreateManyUserInput = {
    id?: number
    email: string
    type: $Enums.EmailType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhoneCreateManyUserInput = {
    id?: number
    phoneNumber: string
    countryCode?: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingProgressCreateManyHiringManagerInput = {
    id?: number
    userId: string
    applicationId: number
    currentPhase?: $Enums.Phase
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.OnboardingStatus
    hireDate: Date | string
  }

  export type UserCreateManyManagerInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
    locationId?: string | null
  }

  export type RequestCreateManyRequesterInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCreateManyManagerInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.RequestStatus
    requesterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestStatusHistoryCreateManyUserInput = {
    id?: number
    requestId: string
    status: $Enums.RequestStatus
    comment?: string | null
    createdAt?: Date | string
  }

  export type LeaveRequestCreateManyEmployeeInput = {
    id?: string
    managerId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestCreateManyManagerInput = {
    id?: string
    employeeId: string
    type: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    duration: number
    reason?: string | null
    status?: $Enums.LeaveStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveStatusHistoryCreateManyChangedByInput = {
    id?: number
    leaveId: string
    status: $Enums.LeaveStatus
    comment?: string | null
    createdAt?: Date | string
  }

  export type ProjectCreateManyManagerInput = {
    id?: string
    name: string
    description?: string | null
    clientId: string
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: string
    projectId: string
    role?: $Enums.ProjectMemberRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TimeEntryCreateManyUserInput = {
    id?: string
    projectId: string
    description: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    status?: $Enums.TimeEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftEntryCreateManyUserInput = {
    id?: string
    scheduleId: string
    date: Date | string
    status?: $Enums.ShiftStatus
    isNightShift?: boolean
    workplaceType?: $Enums.WorkplaceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateManyChangedByUserInput = {
    id?: string
    title: string
    content: string
    publishedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedBy: string
  }

  export type AnnouncementCreateManyPublishedByUserInput = {
    id?: string
    title: string
    content: string
    publishedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    changedBy: string
  }

  export type CandidateNoteUpdateWithoutCreatedByInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidate?: CandidateUpdateOneRequiredWithoutNotesNestedInput
  }

  export type CandidateNoteUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateNoteUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationHistoryUpdateWithoutChangedByInput = {
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: JobApplicationUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type JobApplicationHistoryUncheckedUpdateWithoutChangedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicationId?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationHistoryUncheckedUpdateManyWithoutChangedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicationId?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatusHistoryUpdateWithoutUserInput = {
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: UserUpdateOneRequiredWithoutStatusChangesByNestedInput
  }

  export type UserStatusHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedById?: StringFieldUpdateOperationsInput | string
  }

  export type UserStatusHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedById?: StringFieldUpdateOperationsInput | string
  }

  export type UserStatusHistoryUpdateWithoutChangedByInput = {
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStatusHistoryNestedInput
  }

  export type UserStatusHistoryUncheckedUpdateWithoutChangedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatusHistoryUncheckedUpdateManyWithoutChangedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUserInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentMember?: DependentMemberUpdateOneWithoutDocumentNestedInput
    verification?: DocumentVerificationUpdateOneWithoutDocumentNestedInput
    languageSkill?: LanguageSkillUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    languageSkillId?: NullableIntFieldUpdateOperationsInput | number | null
    verification?: DocumentVerificationUncheckedUpdateOneWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    languageSkillId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DocumentVerificationUpdateWithoutReviewedByInput = {
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: DocumentUpdateOneRequiredWithoutVerificationNestedInput
    User?: UserUpdateOneWithoutDocumentVerificationNestedInput
  }

  export type DocumentVerificationUncheckedUpdateWithoutReviewedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentVerificationUncheckedUpdateManyWithoutReviewedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentVerificationUpdateWithoutUserInput = {
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: DocumentUpdateOneRequiredWithoutVerificationNestedInput
    reviewedBy?: UserUpdateOneRequiredWithoutDocumentReviewsNestedInput
  }

  export type DocumentVerificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedById?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentVerificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedById?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyContactUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    primaryPhone?: StringFieldUpdateOperationsInput | string
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    primaryPhone?: StringFieldUpdateOperationsInput | string
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyContactUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    primaryPhone?: StringFieldUpdateOperationsInput | string
    secondaryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependentMemberUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUpdateManyWithoutDependentMemberNestedInput
  }

  export type DependentMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUncheckedUpdateManyWithoutDependentMemberNestedInput
  }

  export type DependentMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: StringFieldUpdateOperationsInput | string
    isStudent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumEmailTypeFieldUpdateOperationsInput | $Enums.EmailType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneUpdateWithoutUserInput = {
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    phoneNumber?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressUpdateWithoutHiringManagerInput = {
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingProgressNestedInput
    application?: JobApplicationUpdateOneRequiredWithoutOnboardingProgressNestedInput
    contract?: ContractUpdateOneWithoutOnboardingNestedInput
  }

  export type OnboardingProgressUncheckedUpdateWithoutHiringManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    applicationId?: IntFieldUpdateOperationsInput | number
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutOnboardingNestedInput
  }

  export type OnboardingProgressUncheckedUpdateManyWithoutHiringManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    applicationId?: IntFieldUpdateOperationsInput | number
    currentPhase?: EnumPhaseFieldUpdateOperationsInput | $Enums.Phase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOnboardingStatusFieldUpdateOperationsInput | $Enums.OnboardingStatus
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequestUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneRequiredWithoutRequestsToManageNestedInput
    attachments?: RequestAttachmentUpdateManyWithoutRequestNestedInput
    RequestStatusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: RequestAttachmentUncheckedUpdateManyWithoutRequestNestedInput
    RequestStatusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutRequestsMadeNestedInput
    attachments?: RequestAttachmentUpdateManyWithoutRequestNestedInput
    RequestStatusHistory?: RequestStatusHistoryUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    requesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: RequestAttachmentUncheckedUpdateManyWithoutRequestNestedInput
    RequestStatusHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    requesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusHistoryUpdateWithoutUserInput = {
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: RequestUpdateOneRequiredWithoutRequestStatusHistoryNestedInput
    attachments?: StatusAttachmentUpdateManyWithoutHistoryNestedInput
  }

  export type RequestStatusHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: StatusAttachmentUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type RequestStatusHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestId?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneRequiredWithoutLeavesToApproveNestedInput
    attachments?: LeaveAttachmentUpdateManyWithoutLeaveNestedInput
    statusHistory?: LeaveStatusHistoryUpdateManyWithoutLeaveNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: LeaveAttachmentUncheckedUpdateManyWithoutLeaveNestedInput
    statusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutLeaveNestedInput
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutLeavesRequestedNestedInput
    attachments?: LeaveAttachmentUpdateManyWithoutLeaveNestedInput
    statusHistory?: LeaveStatusHistoryUpdateManyWithoutLeaveNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: LeaveAttachmentUncheckedUpdateManyWithoutLeaveNestedInput
    statusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutLeaveNestedInput
  }

  export type LeaveRequestUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveStatusHistoryUpdateWithoutChangedByInput = {
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leave?: LeaveRequestUpdateOneRequiredWithoutStatusHistoryNestedInput
    attachments?: LeaveStatusAttachmentUpdateManyWithoutHistoryNestedInput
  }

  export type LeaveStatusHistoryUncheckedUpdateWithoutChangedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveId?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: LeaveStatusAttachmentUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveId?: StringFieldUpdateOperationsInput | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimeEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumTimeEntryStatusFieldUpdateOperationsInput | $Enums.TimeEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTimeEntriesNestedInput
  }

  export type TimeEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumTimeEntryStatusFieldUpdateOperationsInput | $Enums.TimeEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumTimeEntryStatusFieldUpdateOperationsInput | $Enums.TimeEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: TimeScheduleUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUpdateWithoutChangedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedByUser?: UserUpdateOneRequiredWithoutAnnouncementsPublishedNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutChangedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutChangedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnnouncementUpdateWithoutPublishedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedByUser?: UserUpdateOneRequiredWithoutAnnouncementsChangedNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutPublishedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutPublishedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: StringFieldUpdateOperationsInput | string
  }

  export type JobApplicationCreateManyJobListingInput = {
    id?: number
    candidateId: string
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
  }

  export type JobApplicationUpdateWithoutJobListingInput = {
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidate?: CandidateUpdateOneRequiredWithoutApplicationsNestedInput
    history?: JobApplicationHistoryUpdateManyWithoutApplicationNestedInput
    cvAnalysis?: CvAnalysisUpdateOneWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutJobListingInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: JobApplicationHistoryUncheckedUpdateManyWithoutApplicationNestedInput
    cvAnalysis?: CvAnalysisUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateManyWithoutJobListingInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateId?: StringFieldUpdateOperationsInput | string
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationCreateManyCandidateInput = {
    id?: number
    resumeKey?: string | null
    additionalNotes?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    jobListingId: number
    createdAt?: Date | string
  }

  export type CandidateNoteCreateManyCandidateInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type JobApplicationUpdateWithoutCandidateInput = {
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobListing?: JobListingUpdateOneRequiredWithoutApplicationsNestedInput
    history?: JobApplicationHistoryUpdateManyWithoutApplicationNestedInput
    cvAnalysis?: CvAnalysisUpdateOneWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutCandidateInput = {
    id?: IntFieldUpdateOperationsInput | number
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    jobListingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: JobApplicationHistoryUncheckedUpdateManyWithoutApplicationNestedInput
    cvAnalysis?: CvAnalysisUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutApplicationNestedInput
    OnboardingInvitation?: OnboardingInvitationUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateManyWithoutCandidateInput = {
    id?: IntFieldUpdateOperationsInput | number
    resumeKey?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    jobListingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateNoteUpdateWithoutCandidateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCandidateNotesNestedInput
  }

  export type CandidateNoteUncheckedUpdateWithoutCandidateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateNoteUncheckedUpdateManyWithoutCandidateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type JobApplicationHistoryCreateManyApplicationInput = {
    id?: number
    status: $Enums.ApplicationStatus
    comment?: string | null
    createdAt?: Date | string
    changedByUserId?: string | null
  }

  export type JobApplicationHistoryUpdateWithoutApplicationInput = {
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: UserUpdateOneWithoutJobApplicationHistoryNestedInput
  }

  export type JobApplicationHistoryUncheckedUpdateWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobApplicationHistoryUncheckedUpdateManyWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IdentificationDocumentCreateManyPersonalInfoInput = {
    id?: number
    type: $Enums.IdentificationDocumentType
    documentNumber: string
    issueDate: Date | string
    expiryDate?: Date | string | null
    issuingAuthority: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateManyPersonalInfoInput = {
    id?: number
    type?: $Enums.AddressType
    street: string
    streetNumber: string
    city: string
    region: string
    postalCode: string
    country: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountCreateManyPersonalInfoInput = {
    id?: number
    bank?: $Enums.GreekBank
    iban: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageSkillCreateManyPersonalInfoInput = {
    id?: number
    language: $Enums.Language
    proficiency: $Enums.Proficiency
    certificate?: string | null
    issueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentificationDocumentUpdateWithoutPersonalInfoInput = {
    type?: EnumIdentificationDocumentTypeFieldUpdateOperationsInput | $Enums.IdentificationDocumentType
    documentNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentificationDocumentUncheckedUpdateWithoutPersonalInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumIdentificationDocumentTypeFieldUpdateOperationsInput | $Enums.IdentificationDocumentType
    documentNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentificationDocumentUncheckedUpdateManyWithoutPersonalInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumIdentificationDocumentTypeFieldUpdateOperationsInput | $Enums.IdentificationDocumentType
    documentNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuingAuthority?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutPersonalInfoInput = {
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutPersonalInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyWithoutPersonalInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    street?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUpdateWithoutPersonalInfoInput = {
    bank?: EnumGreekBankFieldUpdateOperationsInput | $Enums.GreekBank
    iban?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateWithoutPersonalInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    bank?: EnumGreekBankFieldUpdateOperationsInput | $Enums.GreekBank
    iban?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyWithoutPersonalInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    bank?: EnumGreekBankFieldUpdateOperationsInput | $Enums.GreekBank
    iban?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageSkillUpdateWithoutPersonalInfoInput = {
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    proficiency?: EnumProficiencyFieldUpdateOperationsInput | $Enums.Proficiency
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutLanguageSkillNestedInput
  }

  export type LanguageSkillUncheckedUpdateWithoutPersonalInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    proficiency?: EnumProficiencyFieldUpdateOperationsInput | $Enums.Proficiency
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutLanguageSkillNestedInput
  }

  export type LanguageSkillUncheckedUpdateManyWithoutPersonalInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    proficiency?: EnumProficiencyFieldUpdateOperationsInput | $Enums.Proficiency
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyDependentMemberInput = {
    id?: number
    userId: string
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    languageSkillId?: number | null
  }

  export type DocumentUpdateWithoutDependentMemberInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    verification?: DocumentVerificationUpdateOneWithoutDocumentNestedInput
    languageSkill?: LanguageSkillUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDependentMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageSkillId?: NullableIntFieldUpdateOperationsInput | number | null
    verification?: DocumentVerificationUncheckedUpdateOneWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutDependentMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageSkillId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DocumentCreateManyLanguageSkillInput = {
    id?: number
    userId: string
    type: $Enums.DocumentType
    key: string
    uploadedAt?: Date | string
    dependentMemberId?: number | null
  }

  export type DocumentUpdateWithoutLanguageSkillInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    dependentMember?: DependentMemberUpdateOneWithoutDocumentNestedInput
    verification?: DocumentVerificationUpdateOneWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutLanguageSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    verification?: DocumentVerificationUncheckedUpdateOneWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutLanguageSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentMemberId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RequestAttachmentCreateManyRequestInput = {
    id?: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type RequestStatusHistoryCreateManyRequestInput = {
    id?: number
    status: $Enums.RequestStatus
    comment?: string | null
    changedBy: string
    createdAt?: Date | string
  }

  export type RequestAttachmentUpdateWithoutRequestInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestAttachmentUncheckedUpdateWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestAttachmentUncheckedUpdateManyWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestStatusHistoryUpdateWithoutRequestInput = {
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRequestHistoryNestedInput
    attachments?: StatusAttachmentUpdateManyWithoutHistoryNestedInput
  }

  export type RequestStatusHistoryUncheckedUpdateWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: StatusAttachmentUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type RequestStatusHistoryUncheckedUpdateManyWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAttachmentCreateManyHistoryInput = {
    id?: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type StatusAttachmentUpdateWithoutHistoryInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAttachmentUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAttachmentUncheckedUpdateManyWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveAttachmentCreateManyLeaveInput = {
    id?: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type LeaveStatusHistoryCreateManyLeaveInput = {
    id?: number
    status: $Enums.LeaveStatus
    comment?: string | null
    changedById: string
    createdAt?: Date | string
  }

  export type LeaveAttachmentUpdateWithoutLeaveInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveAttachmentUncheckedUpdateWithoutLeaveInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveAttachmentUncheckedUpdateManyWithoutLeaveInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveStatusHistoryUpdateWithoutLeaveInput = {
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: UserUpdateOneRequiredWithoutLeaveStatusHistoryNestedInput
    attachments?: LeaveStatusAttachmentUpdateManyWithoutHistoryNestedInput
  }

  export type LeaveStatusHistoryUncheckedUpdateWithoutLeaveInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: LeaveStatusAttachmentUncheckedUpdateManyWithoutHistoryNestedInput
  }

  export type LeaveStatusHistoryUncheckedUpdateManyWithoutLeaveInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveStatusAttachmentCreateManyHistoryInput = {
    id?: number
    fileName: string
    fileKey: string
    fileType: string
    uploadedAt?: Date | string
  }

  export type LeaveStatusAttachmentUpdateWithoutHistoryInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveStatusAttachmentUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveStatusAttachmentUncheckedUpdateManyWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileKey?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyDepartmentInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
    locationId?: string | null
  }

  export type JobListingCreateManyDepartmentInput = {
    id?: number
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    locationId?: string | null
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
  }

  export type UserUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobListingUpdateWithoutDepartmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutJobListingNestedInput
    applications?: JobApplicationUpdateManyWithoutJobListingNestedInput
    position?: PositionUpdateOneWithoutJobListingsNestedInput
  }

  export type JobListingUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    applications?: JobApplicationUncheckedUpdateManyWithoutJobListingNestedInput
  }

  export type JobListingUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyLocationInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    positionId?: string | null
  }

  export type JobListingCreateManyLocationInput = {
    id?: number
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    departmentId?: string | null
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
  }

  export type UserUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobListingUpdateWithoutLocationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutJobListingNestedInput
    applications?: JobApplicationUpdateManyWithoutJobListingNestedInput
    position?: PositionUpdateOneWithoutJobListingsNestedInput
  }

  export type JobListingUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    applications?: JobApplicationUncheckedUpdateManyWithoutJobListingNestedInput
  }

  export type JobListingUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyPositionInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    employmentType?: $Enums.EmploymentType
    jobStartDate?: Date | string | null
    jobEndDate?: Date | string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerId?: string | null
    locationId?: string | null
  }

  export type JobListingCreateManyPositionInput = {
    id?: number
    title: string
    description: string
    employmentType?: $Enums.EmploymentType
    workplaceType?: $Enums.WorkplaceType
    referralSource?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.JobStatus
    departmentId?: string | null
    locationId?: string | null
    keywords?: JobListingCreatekeywordsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    candidateNotes?: CandidateNoteUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUpdateOneWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUpdateManyWithoutUserNestedInput
    emails?: UserEmailUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUpdateManyWithoutHiringManagerNestedInput
    manager?: UserUpdateOneWithoutEmployeesNestedInput
    employees?: UserUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUpdateManyWithoutPublishedByUserNestedInput
    location?: LocationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateNotes?: CandidateNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    jobApplicationHistory?: JobApplicationHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    statusHistory?: UserStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    statusChangesBy?: UserStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    personalInfo?: PersonalInfoUncheckedUpdateOneWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    documentReviews?: DocumentVerificationUncheckedUpdateManyWithoutReviewedByNestedInput
    DocumentVerification?: DocumentVerificationUncheckedUpdateManyWithoutUserNestedInput
    OnboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    emergencyContacts?: EmergencyContactUncheckedUpdateManyWithoutUserNestedInput
    dependentMembers?: DependentMemberUncheckedUpdateManyWithoutUserNestedInput
    emails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    phones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    managedOnboardings?: OnboardingProgressUncheckedUpdateManyWithoutHiringManagerNestedInput
    employees?: UserUncheckedUpdateManyWithoutManagerNestedInput
    requestsMade?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    requestsToManage?: RequestUncheckedUpdateManyWithoutManagerNestedInput
    requestHistory?: RequestStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    leavesRequested?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    leavesToApprove?: LeaveRequestUncheckedUpdateManyWithoutManagerNestedInput
    leaveStatusHistory?: LeaveStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    shifts?: ShiftEntryUncheckedUpdateManyWithoutUserNestedInput
    announcementsChanged?: AnnouncementUncheckedUpdateManyWithoutChangedByUserNestedInput
    announcementsPublished?: AnnouncementUncheckedUpdateManyWithoutPublishedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    jobStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobListingUpdateWithoutPositionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutJobListingNestedInput
    location?: LocationUpdateOneWithoutJobListingNestedInput
    applications?: JobApplicationUpdateManyWithoutJobListingNestedInput
  }

  export type JobListingUncheckedUpdateWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: JobApplicationUncheckedUpdateManyWithoutJobListingNestedInput
  }

  export type JobListingUncheckedUpdateManyWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: JobListingUpdatekeywordsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyClientInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate: Date | string
    endDate?: Date | string | null
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    timeEntries?: TimeEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: string
    userId: string
    role?: $Enums.ProjectMemberRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TimeEntryCreateManyProjectInput = {
    id?: string
    userId: string
    description: string
    startTime: Date | string
    endTime?: Date | string | null
    duration: number
    status?: $Enums.TimeEntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimeEntryUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumTimeEntryStatusFieldUpdateOperationsInput | $Enums.TimeEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTimeEntriesNestedInput
  }

  export type TimeEntryUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumTimeEntryStatusFieldUpdateOperationsInput | $Enums.TimeEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: EnumTimeEntryStatusFieldUpdateOperationsInput | $Enums.TimeEntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftEntryCreateManyScheduleInput = {
    id?: string
    userId: string
    date: Date | string
    status?: $Enums.ShiftStatus
    isNightShift?: boolean
    workplaceType?: $Enums.WorkplaceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftEntryUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftEntryUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftEntryUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    workplaceType?: EnumWorkplaceTypeFieldUpdateOperationsInput | $Enums.WorkplaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}